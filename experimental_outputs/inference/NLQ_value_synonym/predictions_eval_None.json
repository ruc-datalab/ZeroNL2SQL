[
    {
        "input": "Translate the question into a SQL structure according to the database. question: The average age, minimum age, and maximum age of all French singers., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (Avg(t1.c5), min(t1.c5), max(t1.c5)",
            "SELECT-FROM-WHERE, AVG(t1.c5), min(t1.c5), max(t1.c5)",
            "SELECT-FROM-WHERE, AVG(t1.c5), MIN(t1.c5), MAX(t1.c5)",
            "SELECT-FROM-WHERE, AVG(t1.c5), Min(t1.c5), max(t1.c5)",
            "SELECT-FROM-WHERE, AVG(t1.c5), Min(t1.c5), Max(t1.c5)",
            "SELECT-FROM-WHERE (Avg(t1.c5), Min(t1.c5), Max(t1.c5)",
            "SELECT-FROM-WHERE, MINIMUM(t1.c5), MAX(t1.c5)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The average age, minimum age, and maximum age of all French singers., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select avg(t1.c5), min(t1.c5), max(t1.c5)",
        "label": "select avg(t1.c5), min(t1.c5), max(t1.c5)",
        "score": true,
        "real_pred": "select avg(singer.Age), min(singer.Age), max(singer.Age)",
        "real_label": "select avg(singer.Age), min(singer.Age), max(singer.Age)",
        "topk_preds": [
            "select avg(singer.Age), min(singer.Age), max(singer.Age)",
            "select avg(singer.Age), min(singer.Age), max(singer.Age)",
            "select avg(singer.Age), min(singer.Age), max(singer.Is_male)",
            "select avg(singer.Age), min(singer.Age) and max(singer.Age)",
            "select avg(singer.Age), min(singer.Age), max(singer.Age)",
            "select avg(singer.Age), min(singer.Age),max(singer.Age)",
            "select avg(singer.Is_male), min(singer.Age), max(singer.Age)",
            "select avg(singer.Age), min(singer.Is_male), max(singer.Age)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The average age, minimum age, and maximum age of all French singers., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the average, minimum, and maximum ages of all French singers., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (AVG(t1.c5), min(t1.c5), max(t1.c5)",
            "SELECT-FROM-WHERE (Avg(t1.c5), min(t1.c5), max(t1.c5)",
            "SELECT-FROM-WHERE, AVG(t1.c5), min(t1.c5), max(t1.c5)",
            "SELECT-FROM-WHERE AVG(t1.c5), min(t1.c5), max(t1.c5)",
            "SELECT-FROM-WHERE (AVG(t1.c5), MIN(t1.c5), MAX(t1.c5)",
            "SELECT-FROM-WHERE (AVG(t1.c5), MINI(t1.c5), MAX(t1.c5)",
            "SELECT-FROM-WHERE (AVG(t1.c5), MIN(t1.c5), max(t1.c5)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the average, minimum, and maximum ages of all French singers., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select avg(t1.c5), min(t1.c5), max(t1.c5)",
        "label": "select avg(t1.c5), min(t1.c5), max(t1.c5)",
        "score": true,
        "real_pred": "select avg(singer.Age), min(singer.Age), max(singer.Age)",
        "real_label": "select avg(singer.Age), min(singer.Age), max(singer.Age)",
        "topk_preds": [
            "select avg(singer.Age), min(singer.Age), max(singer.Age)",
            "select avg(singer.Age), min(singer.Age), max(singer.Age)",
            "select avg(singer.Age), min(singer.Age), max(singer.Is_male)",
            "select avg(singer.Is_male), min(singer.Age), max(singer.Age)",
            "select avg(singer.Age), min(singer.Age), max(singer.Age)",
            "select avg(singer.Age), min(singer.Age) and max(singer.Age)",
            "select avg(singer.Age), min(singer.Is_male), max(singer.Age)",
            "select avg(singer.Age), min(singer.Age),max(singer.Age)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the average, minimum, and maximum ages of all French singers., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the average age, minimum age, and maximum age of all French Singers., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (Avg(t1.c5), min(t1.c5), max(t1.c5)",
            "SELECT-FROM-WHERE (AVG(t1.c5), min(t1.c5), max(t1.c5)",
            "SELECT-FROM-WHERE (AVG(t1.c5), MIN(t1.c5), MAX(t1.c5)",
            "SELECT-FROM-WHERE, AVG(t1.c5), min(t1.c5), max(t1.c5)",
            "SELECT-FROM-WHERE (AVG(t1.c5), MINI(t1.c5), MAX(t1.c5)",
            "SELECT-FROM-WHERE (Avg(t1.c5), Min(t1.c5), Max(t1.c5)",
            "SELECT-FROM-WHERE (Avg(t1.c5), Min(t1.c5), max(t1.c5)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the average age, minimum age, and maximum age of all French Singers., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select avg(t1.c5), min(t1.c5), max(t1.c5)",
        "label": "select avg(t1.c5), min(t1.c5), max(t1.c5)",
        "score": true,
        "real_pred": "select avg(singer.Age), min(singer.Age), max(singer.Age)",
        "real_label": "select avg(singer.Age), min(singer.Age), max(singer.Age)",
        "topk_preds": [
            "select avg(singer.Age), min(singer.Age), max(singer.Age)",
            "select avg(singer.Age), min(singer.Age), max(singer.Age)",
            "select avg(singer.Age), min(singer.Age), max(singer.Is_male)",
            "select avg(singer.Age), min(singer.Age) and max(singer.Age)",
            "select avg(singer.Age), min(singer.Age), max(singer.Age)",
            "select avg(singer.Age), min(singer.Age),max(singer.Age)",
            "select avg(singer.Is_male), min(singer.Age), max(singer.Age)",
            "select avg(singer.Age), min(singer.Is_male), max(singer.Age)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the average age, minimum age, and maximum age of all French Singers., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all the countries with singers above twenty years old., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all the countries with singers above twenty years old., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c2",
        "label": "select distinct t1.c2",
        "score": false,
        "real_pred": "select singer.Country",
        "real_label": "select distinct singer.Country",
        "topk_preds": [
            "select singer.Country",
            "select distinct singer.Country",
            "select singer.Country, singer.Age",
            "select singer.Country, singer.Is_male",
            "select distinct singer.Country, singer.Age",
            "select singer.Country, singer.Song_Name",
            "select distinct singer.Country, singer.Is_male",
            "select singer.Country, singer.Song_release_year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all the countries with singers above twenty years old., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The different countries with singers that exceed twenty years old., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY (UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The different countries with singers that exceed twenty years old., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select distinct t1.c2",
        "label": "select distinct t1.c2",
        "score": true,
        "real_pred": "select distinct singer.Country",
        "real_label": "select distinct singer.Country",
        "topk_preds": [
            "select distinct singer.Country",
            "select count(distinct singer.Country)",
            "select distinct singer.Country, singer.Song_Name",
            "select distinct singer.Country, singer.Age",
            "select distinct singer.Country, singer.Is_male",
            "select distinct singer.Country, singer.Song_release_year",
            "select distinct singer.Country,",
            "select distinct singer.Country, t1.c7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The different countries with singers that exceed twenty years old., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the location and names of all stadiums between 5,000 and 10,000 seats., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the location and names of all stadiums between 5,000 and 10,000 seats., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select stadium.Location, stadium.Name",
        "real_label": "select stadium.Location, stadium.Name",
        "topk_preds": [
            "select stadium.Location, stadium.Name",
            "select stadium.Stadium_ID, stadium.Location, stadium.Name",
            "select stadium.Location., stadium.Name",
            "select t0, stadium.Location, stadium.Name",
            "select stadium.Location, stadium.Name, stadium.Capacity",
            "select t0.c 1, stadium.Name",
            "select stadium.Location, stadium.Name",
            "select stadium.Location, stadium.Name,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the location and names of all stadiums between 5,000 and 10,000 seats., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "stadium",
        "real_label": "stadium",
        "topk_preds": [
            "stadium",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the locations and names of all arenas whose size is from 5k to 10k, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the locations and names of all arenas whose size is from 5k to 10k, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select stadium.Location, stadium.Name",
        "real_label": "select stadium.Location, stadium.Name",
        "topk_preds": [
            "select stadium.Location, stadium.Name",
            "select stadium.Location., stadium.Name",
            "select t0, stadium.Location, stadium.Name",
            "select stadium.Location, stadium.Name, stadium.Stadium_ID",
            "select t0.c 1, stadium.Name",
            "select stadium.Location, stadium.Name, stadium.Capacity",
            "select stadium.Location, stadium.Name",
            "select stadium.Location, stadium.Name,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the locations and names of all arenas whose size is from 5k to 10k, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "stadium",
        "real_label": "stadium",
        "topk_preds": [
            "stadium",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all stations that can fit 5-10k passengers and their locations and names., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (T0.c1), SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, t0.c1, t0.c2",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (t0.c1), t0.c2",
            "SELECT-FROM-WHERE (t0.c1), SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all stations that can fit 5-10k passengers and their locations and names., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select stadium.Location, stadium.Name",
        "real_label": "select stadium.Location, stadium.Name",
        "topk_preds": [
            "select stadium.Location, stadium.Name",
            "select stadium.Stadium_ID, stadium.Location, stadium.Name",
            "select stadium.Location, stadium.Name, stadium.Capacity",
            "select stadium.Capacity, stadium.Location, stadium.Name",
            "select stadium.Location, stadium.Name, stadium.Stadium_ID",
            "select stadium.Location, stadium.Name",
            "select stadium.Location, stadium.Name, stadium.Capacity",
            "select stadium.Location, stadium.Name, stadium.Stadium_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all stations that can fit 5-10k passengers and their locations and names., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "stadium",
        "real_label": "stadium",
        "topk_preds": [
            "stadium",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find all stations between 5,000 and 10,000 in size and show me their locations and names., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SATELLITE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (t0.c1), SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (t0.c1), t0.c2",
            "SELECT-FROM-WHERE (SATELLITE-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find all stations between 5,000 and 10,000 in size and show me their locations and names., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select stadium.Location, stadium.Name",
        "real_label": "select stadium.Location, stadium.Name",
        "topk_preds": [
            "select stadium.Location, stadium.Name",
            "select concert.concert_Name, stadium.Name",
            "select stadium.Name, stadium.Location",
            "select stadium.Location., stadium.Name",
            "select singer_in_concert.Singer_ID, stadium.Name",
            "select stadium.Location, stadium.Name",
            "select stadium.Stadium_ID, stadium.Name",
            "select t0.c 1, stadium.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find all stations between 5,000 and 10,000 in size and show me their locations and names., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "stadium",
        "real_label": "stadium",
        "topk_preds": [
            "stadium",
            "stadium concert",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the location and name of all stations with capacity between 5,000 and 10,000., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the location and name of all stations with capacity between 5,000 and 10,000., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select stadium.Location, stadium.Name",
        "real_label": "select stadium.Location, stadium.Name",
        "topk_preds": [
            "select stadium.Location, stadium.Name",
            "select stadium.Stadium_ID, stadium.Location, stadium.Name",
            "select stadium.Location., stadium.Name",
            "select t0.c 1, stadium.Name",
            "select stadium.Location, stadium.Name",
            "select stadium.Location, stadium.Name,",
            "select stadium.Location, stadium.Name, stadium.Stadium_ID",
            "select stadium.Location, stadium.Name, stadium.Capacity"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the location and name of all stations with capacity between 5,000 and 10,000., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "stadium",
        "real_label": "stadium",
        "topk_preds": [
            "stadium",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Determine the number of pets in which weighs over 10Kg., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Determine the number of pets in which weighs over 10Kg., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Pets.PetID",
            "select count(*), Pets.PetID",
            "select count(*) dependant on Pets.PetID",
            "select count(*) dependant on the Pets.PetID",
            "select count(*), Pets.PetType",
            "select count(*) in Pets.PetID",
            "select count(*) the Pets.PetID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Determine the number of pets in which weighs over 10Kg., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "Has_Pet Pets",
            "",
            "",
            "",
            "",
            "",
            "Student Pets"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of pets owned by students who are over twenty years old., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-COUNT(*)",
            "SELECT-FROM-WHERE-NUM(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of pets owned by students who are over twenty years old., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.StuID",
            "select count(*), Student.LName, Student.Age",
            "select count(*), Student.LName, Student.Fname",
            "select count(*), Student.LName",
            "select count(*), Student.StuID, Student.Age",
            "select count(*), Student.Fname, Student.Age",
            "select count(distinct Has_Pet.PetID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of pets owned by students who are over twenty years old., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1",
        "score": false,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet Pets",
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many pets are owned by older than twenty years old students., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM when t0.c0"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many pets are owned by older than twenty years old students., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.StuID",
            "select count(*), Student.LName, Student.Age",
            "select count(distinct Has_Pet.PetID)",
            "select count(*), Student.StuID, Student.Age",
            "select count(*), Student.LName",
            "select count(*), Student.StuID",
            "select count(*), Student.LName, Student.Fname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many pets are owned by older than twenty years old students., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1",
        "score": false,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet Pets",
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show how many pets are owned by students that are over twenty years old., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-COUNT(*)",
            "SELECT-FROM-WHERE count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show how many pets are owned by students that are over twenty years old., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.StuID",
            "select count(*), Student.LName, Student.Age",
            "select count(*), Student.StuID, Student.Age",
            "select count(*), Student.LName, Student.Fname",
            "select count(*), Student.LName",
            "select count(distinct Has_Pet.PetID)",
            "select count(*), Student.Fname, Student.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show how many pets are owned by students that are over twenty years old., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1",
        "score": false,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet Pets",
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many pets are owned by students over the age of twenty?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY (approximately count(*)",
            "SELECT-FROM-WHERE (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many pets are owned by students over the age of twenty?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.StuID",
            "select count(*), Student.LName, Student.Age",
            "select count(*), Student.LName",
            "select count(*), Student.LName, Student.Age",
            "select count(*), Student.LName, Student.Fname",
            "select count(distinct Has_Pet.PetID)",
            "select count(*), Student.StuID, Student.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many pets are owned by students over the age of twenty?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1",
        "score": false,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet Pets",
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the numbers of pets owned by students that have an age greater than twenty., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GENUM(*)",
            "SELECT-FROM-WHERE-GROUP BY HAVING",
            "SELECT-FROM-WHERE count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the numbers of pets owned by students that have an age greater than twenty., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.StuID",
            "select count(*), Student.LName, Student.Age",
            "select count(*), Student.LName",
            "select count(*), Student.LName, Pets.pet_age",
            "select count(*), Student.LName, Student.Fname",
            "select count(*), Student.StuID, Student.Age",
            "select count(*), Student.StuID, Pets.pet_age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the numbers of pets owned by students that have an age greater than twenty., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1",
        "score": false,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet Pets",
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the number of student dogs owned by females., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE.GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the number of student dogs owned by females., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.Sex",
            "select count(*), Student.StuID",
            "select count(distinct Has_Pet.StuID)",
            "select count(*), Student.Fname",
            "select count(*), Student.Sex",
            "select count(distinct Has_Pet.PetID)",
            "select count(*), Student.LName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the number of student dogs owned by females., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: show me the number of dogs being owned by females student., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE/GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE/GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: show me the number of dogs being owned by females student., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.Sex",
            "select count(*), Student.StuID",
            "select count(distinct Pets.PetType)",
            "select count(*), Student.LName",
            "select count(*), Student.Fname",
            "select count(*), Student.Sex",
            "select count(*), Student.StuID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: show me the number of dogs being owned by females student., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "",
            "Student Has_Pet",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the identification and the weight of all pets whose age is more than one., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the identification and the weight of all pets whose age is more than one., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t2.c0, t2.c3",
        "label": "select t2.c0, t2.c3",
        "score": true,
        "real_pred": "select Pets.PetID, Pets.weight",
        "real_label": "select Pets.PetID, Pets.weight",
        "topk_preds": [
            "select Pets.PetID, Pets.weight",
            "select Pets.PetID, Pets.pet_age",
            "select Pets.PetType, Pets.weight",
            "select Pets.PetID-, Pets.weight",
            "select Has_Pet.StuID, Pets.weight",
            "select Pets.PetID, Pets.weight.",
            "select Pets.PetID, Pets.weight)",
            "select Pets.PetID, Pets.weight,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the identification and the weight of all pets whose age is more than one., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return all the IDs and weights of pets who are over one years old., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return all the IDs and weights of pets who are over one years old., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t2.c0, t2.c3",
        "label": "select t2.c0, t2.c3",
        "score": true,
        "real_pred": "select Pets.PetID, Pets.weight",
        "real_label": "select Pets.PetID, Pets.weight",
        "topk_preds": [
            "select Pets.PetID, Pets.weight",
            "select Pets.PetID, Pets.weight.",
            "select Pets.PetID, Pets.weight)",
            "select Pets.PetID, Pets.weight,",
            "select Pets.PetType, Pets.weight",
            "select Pets.PetID-, Pets.weight",
            "select Pets.PetID, Pets.pet_age",
            "select t2.C0, Pets.weight"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return all the IDs and weights of pets who are over one years old., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the last name of the student that has a cat aged three years old., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (cat), c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the last name of the student that has a cat aged three years old., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (cat), c2: pet_age, c3: weight).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Student.LName",
        "real_label": "select Student.LName",
        "topk_preds": [
            "select Student.LName",
            "select Student.LName, Student.Fname, Student.Age",
            "select Student.LName, Student.Fname",
            "select Student.LName, Student.Age",
            "select Student.LName, Student.Fname, Student.Age",
            "select Student.LName, Student.Fname, Student.Age",
            "select Student.LName, Student.Age, Student.Fname",
            "select Student.LName, Student.Age, Student.Sex"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the last name of the student that has a cat aged three years old., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (cat), c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the last name of the student who has a cat that is three years old., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (cat), c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the last name of the student who has a cat that is three years old., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (cat), c2: pet_age, c3: weight).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Student.LName",
        "real_label": "select Student.LName",
        "topk_preds": [
            "select Student.LName",
            "select Student.LName, Student.Fname, Student.Age",
            "select Student.LName, Student.Fname",
            "select Student.LName, Student.Age",
            "select Student.LName Student.Fname, Student.Age",
            "select Student.LName, Student.Fname, Student.Age",
            "select Student.LName, Student.Fname, Student.Age",
            "select Student.LName, Student.Age, Student.Fname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the last name of the student who has a cat that is three years old., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (cat), c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the last name of the student who has a cat age three., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (cat), c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the last name of the student who has a cat age three., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (cat), c2: pet_age, c3: weight).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Student.LName",
        "real_label": "select Student.LName",
        "topk_preds": [
            "select Student.LName",
            "select Student.LName, Student.Fname, Student.Age",
            "select Student.LName, Student.Fname",
            "select Student.LName, Student.Age",
            "select Student.LName, Student.Fname, Student.Age",
            "select Student.LName, Student.Fname, Student.Age",
            "select Student.LName, Student.Fname Student.Age",
            "select Student.LName, Student.Age, Student.Fname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the last name of the student who has a cat age three., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (cat), c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "Student Pets",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the last name of the student whose cat is three years old?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (cat), c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the last name of the student whose cat is three years old?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (cat), c2: pet_age, c3: weight).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Student.LName",
        "real_label": "select Student.LName",
        "topk_preds": [
            "select Student.LName",
            "select Student.LName, Student.Fname, Student.Age",
            "select Student.LName, Student.Fname",
            "select Student.LName, Student.Age",
            "select Student.LName Student.Fname, Student.Age",
            "select Student.LName, Student.Fname, Student.Age",
            "select Student.LName, Student.Fname, Student.Age",
            "select Student.StuID, Student.LName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the last name of the student whose cat is three years old?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (cat), c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "",
            "",
            "Student Has_Pet",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The last name of the student who has a cat age is three years)., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (cat), c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The last name of the student who has a cat age is three years)., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (cat), c2: pet_age, c3: weight).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Student.LName",
        "real_label": "select Student.LName",
        "topk_preds": [
            "select Student.LName",
            "select Student.LName, Student.Fname, Student.Age",
            "select Student.LName, Student.Age",
            "select Student.LName Student.Fname, Student.Age",
            "select Student.LName, Student.Fname",
            "select Student.StuID, Student.LName",
            "select Student.LName de, Student.Fname, Student.Age",
            "select Student.LName, Student.Age, Student.Fname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The last name of the student who has a cat age is three years)., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (cat), c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The name of the different car maker who produced a car in 70'., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The name of the different car maker who produced a car in 70'., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select distinct t2.c2",
        "label": "select distinct t2.c1",
        "score": false,
        "real_pred": "select distinct car_makers.FullName",
        "real_label": "select distinct car_makers.Maker",
        "topk_preds": [
            "select distinct car_makers.FullName",
            "select distinct car_makers.FullName, car_makers.Maker",
            "select distinct car_makers.Maker, car_makers.FullName",
            "select distinct car_makers.Maker",
            "select distinct car_makers.Id, car_makers.FullName",
            "select car_makers.Maker, car_makers.FullName",
            "select car_makers.FullName, car_makers.Maker",
            "select distinct car_makers.FullName&car_makers.Maker"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The name of the different car maker who produced a car in 70'., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers car_names",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers car_names",
            "car_makers car_names cars_data",
            "",
            "",
            "",
            "",
            "continents car_makers car_names",
            "car_makers cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of French automobile manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE (*)",
            "SELECT-FROM-WHERE-COUNT(*)",
            "SELECT-FROM-WHERE ",
            "SELECT SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of French automobile manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), car_makers.Country",
            "select count(*), car_makers.Id",
            "select count(*) dependant on car_makers.Maker",
            "select count(*), car_makers.Maker",
            "select count(*), car_makers.Id3",
            "select count(*) the car_makers.Maker",
            "select count(*) (car_makers.Maker)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of French automobile manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the number of car models made in the United States., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the number of car models made in the United States., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(distinct model_list.Model)",
            "select count(*), car_makers.Maker",
            "select count(*), car_makers.Maker, car_makers.Country",
            "select count(distinct car_names.Model)",
            "select count(*), car_makers.Maker, car_makers.Country",
            "select count(*), car_makers.Country",
            "select count(*), car_makers.Maker, car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the number of car models made in the United States., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "car_makers model_list car_names",
        "real_label": "countries car_makers model_list",
        "topk_preds": [
            "car_makers model_list car_names",
            "countries car_makers model_list car_names",
            "continents car_makers model_list car_names",
            "car_makers model_list car_makers car_names",
            "",
            "",
            "car_makers model_list",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the statistics about how many cars were produced in the US., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (GROUP BY-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE.GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE.GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the statistics about how many cars were produced in the US., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select car_makers.Country, count(*)",
            "select sum(car_makers.Country)",
            "select sum(t2.c4)",
            "select sum(t2.c5)",
            "select sum(t2.c8)",
            "select stats(*)",
            "select sum(t2.c6)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the statistics about how many cars were produced in the US., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "car_makers",
        "real_label": "countries car_makers model_list",
        "topk_preds": [
            "car_makers",
            "car_makers car_names",
            "",
            "car_makers cars_data",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: show me how many car models are produced in the United States., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE, count(distinct t3.c2)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: show me how many car models are produced in the United States., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(distinct model_list.Model)",
            "select count(*), car_makers.Maker",
            "select count(distinct car_names.Model)",
            "select count(*), car_makers.Country",
            "select count(*), car_makers.Id",
            "select count(distinct model_list.Maker)",
            "select count(model_list.Model)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: show me how many car models are produced in the United States., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "car_makers model_list car_names",
        "real_label": "countries car_makers model_list",
        "topk_preds": [
            "car_makers model_list car_names",
            "countries car_makers model_list car_names",
            "car_makers model_list",
            "car_makers car_names",
            "car_makers model_list car_makers car_names",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of car models that are produced in the U.S.., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE/GROUP BY",
            "SELECT-FROM-WHERE/GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of car models that are produced in the U.S.., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(distinct model_list.Model)",
            "select count(distinct car_names.Model)",
            "select count(*), car_makers.Country",
            "select count(*), car_makers.Maker",
            "select count(distinct model_list.Maker)",
            "select count(model_list.Model)",
            "select count(distinct model_list.Model)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of car models that are produced in the U.S.., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "car_makers model_list car_names",
        "real_label": "countries car_makers model_list",
        "topk_preds": [
            "car_makers model_list car_names",
            "car_makers car_names",
            "countries car_makers model_list car_names",
            "car_makers model_list car_makers car_names",
            "car_makers model_list",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many car models are produced in the United States?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many car models are produced in the United States?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(distinct model_list.Model)",
            "select count(*), car_makers.Maker",
            "select count(model_list.Model)",
            "select count(*), car_makers.Country",
            "select count(*), car_makers.Id",
            "select count(distinct car_names.Model)",
            "select count(distinct model_list.Maker)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many car models are produced in the United States?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "car_makers model_list car_names",
        "real_label": "countries car_makers model_list",
        "topk_preds": [
            "car_makers model_list car_names",
            "car_makers model_list",
            "countries car_makers model_list car_names",
            "car_makers car_names",
            "car_makers model_list car_makers car_names",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many car models are manufactured in the United States?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE, count(distinct t3.c2)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(distinct t3.c2)",
            "SELECT-FROM-WHERE, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many car models are manufactured in the United States?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(distinct model_list.Model)",
            "select count(distinct car_names.Model)",
            "select count(distinct model_list.Maker)",
            "select count(model_list.Model)",
            "select count(distinct model_list.Model)",
            "select count(distinct car_makers.FullName)",
            "select count(*), car_makers.Maker"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many car models are manufactured in the United States?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "car_makers model_list car_names",
        "real_label": "countries car_makers model_list",
        "topk_preds": [
            "car_makers model_list car_names",
            "car_makers car_names",
            "countries car_makers model_list car_names",
            "car_makers model_list",
            "car_makers model_list car_makers car_names",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of car models produced in the United States., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-GROUP BY -ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of car models produced in the United States., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(distinct model_list.Model)",
            "select count(*), car_makers.Maker",
            "select count(*), car_makers.Country",
            "select count(distinct car_names.Model)",
            "select count(model_list.Model)",
            "select count(distinct model_list.Maker)",
            "select count(*), car_makers.Id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of car models produced in the United States., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "car_makers model_list car_names",
        "real_label": "countries car_makers model_list",
        "topk_preds": [
            "car_makers model_list car_names",
            "countries car_makers model_list car_names",
            "continents car_makers model_list car_names",
            "car_makers model_list",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Number of car manufacturers produced in the U.S., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE/GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE PERCENT(*)",
            "SELECT-FROM-WHERE (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Number of car manufacturers produced in the U.S., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), car_makers.Id",
            "select count(*), car_makers.Maker",
            "select count(distinct car_makers.Maker)",
            "select count(*), car_makers.Country",
            "select count(*) dependant on car_makers.Maker",
            "select count(*), car_makers.Id",
            "select count(*) (car_makers.Maker)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Number of car manufacturers produced in the U.S., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "car_makers",
        "real_label": "countries car_makers model_list",
        "topk_preds": [
            "car_makers",
            "car_makers model_list",
            "countries car_makers",
            "",
            "continents car_makers",
            "car_makers model_list car_names",
            "car_makers car_names",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the average miles per gallon of the cars with four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE (Avg(t5.c1)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the average miles per gallon of the cars with four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c1)",
        "label": "select avg(t5.c1)",
        "score": true,
        "real_pred": "select avg(cars_data.MPG)",
        "real_label": "select avg(cars_data.MPG)",
        "topk_preds": [
            "select avg(cars_data.MPG)",
            "select avg(avg(cars_data.MPG)",
            "select an avg(cars_data.MPG)",
            "select  avg(cars_data.MPG)",
            "select avg(cars_data.MPG)",
            "select avg(cars_data.MPG).",
            "select the avg(cars_data.MPG)",
            "select Avg(cars_data.MPG)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the average miles per gallon of the cars with four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the average miles per gallon for four-cylinder cars., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE (Avg(t5.c1)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the average miles per gallon for four-cylinder cars., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c1)",
        "label": "select avg(t5.c1)",
        "score": true,
        "real_pred": "select avg(cars_data.MPG)",
        "real_label": "select avg(cars_data.MPG)",
        "topk_preds": [
            "select avg(cars_data.MPG)",
            "select an avg(cars_data.MPG)",
            "select avg(avg(cars_data.MPG)",
            "select avg(cars_data.MPG)",
            "select  avg(cars_data.MPG)",
            "select avg(cars_data.MPG) (cars_data.Id)",
            "select avg(cars_data.MPG).",
            "select the avg(cars_data.MPG)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the average miles per gallon for four-cylinder cars., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the average mpg (miles per gallon) for four-cylinder cars., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (Avg(t5.c1)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the average mpg (miles per gallon) for four-cylinder cars., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c1)",
        "label": "select avg(t5.c1)",
        "score": true,
        "real_pred": "select avg(cars_data.MPG)",
        "real_label": "select avg(cars_data.MPG)",
        "topk_preds": [
            "select avg(cars_data.MPG)",
            "select an avg(cars_data.MPG)",
            "select  avg(cars_data.MPG)",
            "select avg(cars_data.MPG)",
            "select the avg(cars_data.MPG)",
            "select Avg(cars_data.MPG)",
            "select avg(cars_data.MPG).",
            "select avg(cars_data.MPG),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the average mpg (miles per gallon) for four-cylinder cars., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The average miles per gallon of all the cars with four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (avg(t5.c1)",
            "SELECT-FROM-WHERE (Avg(t5.c1)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The average miles per gallon of all the cars with four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c1)",
        "label": "select avg(t5.c1)",
        "score": true,
        "real_pred": "select avg(cars_data.MPG)",
        "real_label": "select avg(cars_data.MPG)",
        "topk_preds": [
            "select avg(cars_data.MPG)",
            "select an avg(cars_data.MPG)",
            "select avg(avg(cars_data.MPG)",
            "select  avg(cars_data.MPG)",
            "select avg(cars_data.MPG)",
            "select Avg(cars_data.MPG)",
            "select avg(cars_data.MPG) (cars_data.MPG)",
            "select the avg(cars_data.MPG)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The average miles per gallon of all the cars with four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The average mpg of cars with four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (avg(t5.c1)",
            "SELECT-FROM-WHERE (Avg(t5.c1)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The average mpg of cars with four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c1)",
        "label": "select avg(t5.c1)",
        "score": true,
        "real_pred": "select avg(cars_data.MPG)",
        "real_label": "select avg(cars_data.MPG)",
        "topk_preds": [
            "select avg(cars_data.MPG)",
            "select an avg(cars_data.MPG)",
            "select  avg(cars_data.MPG)",
            "select avg(cars_data.MPG)",
            "select Avg(cars_data.MPG)",
            "select avg(cars_data.MPG).",
            "select the avg(cars_data.MPG)",
            "select \u0430vg(cars_data.MPG)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The average mpg of cars with four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the mileage averages on the four-cylinder cars., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the mileage averages on the four-cylinder cars., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c1)",
        "label": "select avg(t5.c1)",
        "score": true,
        "real_pred": "select avg(cars_data.MPG)",
        "real_label": "select avg(cars_data.MPG)",
        "topk_preds": [
            "select avg(cars_data.MPG)",
            "select avg(cars_data.MPG), cars_data.Cylinders",
            "select an avg(cars_data.MPG)",
            "select avg(avg(cars_data.MPG)",
            "select avg(cars_data.MPG)",
            "select the avg(cars_data.MPG)",
            "select  avg(cars_data.MPG)",
            "select avg(cars_data.MPG),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the mileage averages on the four-cylinder cars., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the averages of all cars that have four cylinders in terms of MPG., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AGGRESS-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the averages of all cars that have four cylinders in terms of MPG., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c1)",
        "label": "select avg(t5.c1)",
        "score": true,
        "real_pred": "select avg(cars_data.MPG)",
        "real_label": "select avg(cars_data.MPG)",
        "topk_preds": [
            "select avg(cars_data.MPG)",
            "select cars_data.Id, avg(cars_data.MPG)",
            "select cars_data.MPG, avg(cars_data.MPG)",
            "select avg(cars_data.MPG)",
            "select cars_data.MPG, avg(cars_data.Cylinders)",
            "select an avg(cars_data.MPG)",
            "select  avg(cars_data.MPG)",
            "select cars_data.MPG, avg(t5.c8)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the averages of all cars that have four cylinders in terms of MPG., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all cars that have four cylinders and their MPG., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all cars that have four cylinders and their MPG., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c0, t5.c1",
        "label": "select avg(t5.c1)",
        "score": false,
        "real_pred": "select cars_data.Id, cars_data.MPG",
        "real_label": "select avg(cars_data.MPG)",
        "topk_preds": [
            "select cars_data.Id, cars_data.MPG",
            "select cars_data.MPG, cars_data.Id",
            "select cars_data.MPG, cars_data.Cylinders",
            "select cars_data.Id, cars_data.MPG",
            "select car_names.MakeId, cars_data.MPG",
            "select cars_data.MPG, cars_data.Horsepower",
            "select cars_data.MPG, car_names.Make",
            "select t5.d0, cars_data.MPG"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all cars that have four cylinders and their MPG., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the average MPG of all cars that have four cylinders and return this value., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (avg(t5.c1)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (Avg(t5.c1)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the average MPG of all cars that have four cylinders and return this value., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c1)",
        "label": "select avg(t5.c1)",
        "score": true,
        "real_pred": "select avg(cars_data.MPG)",
        "real_label": "select avg(cars_data.MPG)",
        "topk_preds": [
            "select avg(cars_data.MPG)",
            "select an avg(cars_data.MPG)",
            "select  avg(cars_data.MPG)",
            "select Avg(cars_data.MPG)",
            "select avg(avg(cars_data.MPG)",
            "select avg(cars_data.MPG)",
            "select the avg(cars_data.MPG)",
            "select avg(cars_data.MPG)."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the average MPG of all cars that have four cylinders and return this value., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: show the average miles per gallon of all cars with four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (Avg(t5.c1)",
            "SELECT-FROM-WHERE (avg(t5.c1)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: show the average miles per gallon of all cars with four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c1)",
        "label": "select avg(t5.c1)",
        "score": true,
        "real_pred": "select avg(cars_data.MPG)",
        "real_label": "select avg(cars_data.MPG)",
        "topk_preds": [
            "select avg(cars_data.MPG)",
            "select avg(avg(cars_data.MPG)",
            "select an avg(cars_data.MPG)",
            "select  avg(cars_data.MPG)",
            "select avg(cars_data.MPG)",
            "select Avg(cars_data.MPG)",
            "select avg(cars_data.MPG).",
            "select the avg(cars_data.MPG)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: show the average miles per gallon of all cars with four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Calculate the average miles per gallon of all the cars with four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (Avg(t5.c1)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (avg(t5.c1)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Calculate the average miles per gallon of all the cars with four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c1)",
        "label": "select avg(t5.c1)",
        "score": true,
        "real_pred": "select avg(cars_data.MPG)",
        "real_label": "select avg(cars_data.MPG)",
        "topk_preds": [
            "select avg(cars_data.MPG)",
            "select an avg(cars_data.MPG)",
            "select avg(avg(cars_data.MPG)",
            "select  avg(cars_data.MPG)",
            "select avg(cars_data.MPG)",
            "select Avg(cars_data.MPG)",
            "select the avg(cars_data.MPG)",
            "select avg(cars_data.MPG)."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Calculate the average miles per gallon of all the cars with four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The lightest weight of eight-cylinder vehicle made in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The lightest weight of eight-cylinder vehicle made in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select max(t5.c5)",
        "label": "select min(t5.c5)",
        "score": false,
        "real_pred": "select max(cars_data.Weight)",
        "real_label": "select min(cars_data.Weight)",
        "topk_preds": [
            "select max(cars_data.Weight)",
            "select min(cars_data.Weight)",
            "select cars_data.Weight",
            "select minima(cars_data.Weight)",
            "select minim(cars_data.Weight)",
            "select Max(cars_data.Weight)",
            "select maximum(cars_data.Weight)",
            "select minimum(cars_data.Weight)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The lightest weight of eight-cylinder vehicle made in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "model_list car_names cars_data",
            "model_list cars_data",
            "car_makers cars_data",
            "",
            "countries cars_data",
            "cars_data car_names cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What was the smallest weight of cars with eight engines manufactured in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-MIN(t5.c5)",
            "SELECT-FROM-WHERE -ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (MIN(t5.c5)",
            "SELECT-FROM-WHERE, min(t5.c5)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What was the smallest weight of cars with eight engines manufactured in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select min(t5.c5)",
        "label": "select min(t5.c5)",
        "score": true,
        "real_pred": "select min(cars_data.Weight)",
        "real_label": "select min(cars_data.Weight)",
        "topk_preds": [
            "select min(cars_data.Weight)",
            "select min(cars_data.Weight), cars_data.Year",
            "select min(cars_data.Weight), cars_data.Accelerate",
            "select min(cars_data.Weight), cars_data.Id",
            "select cars_data.Weight",
            "select minimum(cars_data.Weight)",
            "select min(cars_data.Weight), t5.c8",
            "select max(cars_data.Weight)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What was the smallest weight of cars with eight engines manufactured in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "model_list cars_data",
            "",
            "",
            "car_makers cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The minimum weight of the car with eight cylinders from 1974 was what?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-1974",
            "SELECT-FROM-WHERE-MIN(t5.c5)",
            "SELECT-FROM-WHERE (MIN(t5.c5)",
            "SELECT-FROM-WHERE-UNITED-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The minimum weight of the car with eight cylinders from 1974 was what?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select min(t5.c5)",
        "label": "select min(t5.c5)",
        "score": true,
        "real_pred": "select min(cars_data.Weight)",
        "real_label": "select min(cars_data.Weight)",
        "topk_preds": [
            "select min(cars_data.Weight)",
            "select min(cars_data.Weight), cars_data.Year",
            "select min(cars_data.Weight), cars_data.Accelerate",
            "select min(cars_data.Weight), t5.dcars_data.Accelerate",
            "select min(cars_data.Weight), t5.dcars_data.Year",
            "select min(cars_data.Weight), cars_data.Cylinders",
            "select min(cars_data.Weight), t5.dcars_data.Id",
            "select min(cars_data.Weight), t5.c8"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The minimum weight of the car with eight cylinders from 1974 was what?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "model_list cars_data",
            "car_names cars_data",
            "car_makers cars_data",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Display the minimum weight of 1974 cars with eight cylinder., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-MIN(t5.c5)",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Display the minimum weight of 1974 cars with eight cylinder., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select min(t5.c5)",
        "label": "select min(t5.c5)",
        "score": true,
        "real_pred": "select min(cars_data.Weight)",
        "real_label": "select min(cars_data.Weight)",
        "topk_preds": [
            "select min(cars_data.Weight)",
            "select min(cars_data.Weight), cars_data.Cylinders",
            "select min(cars_data.Weight), cars_data.Accelerate",
            "select min(cars_data.Weight), t5.c8",
            "select min(cars_data.Weight), cars_data.Year",
            "select min(cars_data.Weight), cars_data.Id",
            "select min(cars_data.Weight), cars_data.MPG",
            "select min(cars_data.Weight) (cars_data.Accelerate)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Display the minimum weight of 1974 cars with eight cylinder., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "model_list cars_data",
            "",
            "car_names cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How much is the minimum weight of the car with eight cylinders produced in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-MIN(t5.c5)",
            "SELECT-FROM-WHERE (MIN(t5.c5)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How much is the minimum weight of the car with eight cylinders produced in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select min(t5.c5)",
        "label": "select min(t5.c5)",
        "score": true,
        "real_pred": "select min(cars_data.Weight)",
        "real_label": "select min(cars_data.Weight)",
        "topk_preds": [
            "select min(cars_data.Weight)",
            "select min(cars_data.Weight), cars_data.Year",
            "select min(cars_data.Weight), cars_data.Accelerate",
            "select min(cars_data.Weight), cars_data.Cylinders",
            "select min(cars_data.Weight), t5.dcars_data.Accelerate",
            "select min(cars_data.Weight), t5.c8",
            "select min(cars_data.Weight), t5.dcars_data.Year",
            "select min(cars_data.Weight), cars_data.Id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How much is the minimum weight of the car with eight cylinders produced in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "model_list cars_data",
            "car_makers cars_data",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the European countries that have 3 or more car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAUSS-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the European countries that have 3 or more car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName, t0.c4",
            "select countries.CountryName, continents.ContId2",
            "select countries.CountryName, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the European countries that have 3 or more car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the list of countries in Europe where there is at least three car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the list of countries in Europe where there is at least three car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, continents.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the list of countries in Europe where there is at least three car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "",
            "",
            "countries car_makers",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the European countries that have at least three car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the European countries that have at least three car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName pour continents.Continent",
            "select countries.CountryName, t0.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the European countries that have at least three car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "",
            "",
            "countries car_makers",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all European countries with 3 or more car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GATHERING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all European countries with 3 or more car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, t0.c4",
            "select countries.CountryName, car_makers.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all European countries with 3 or more car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the list of all European countries where there is at least three manufactures., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GEOGRAPHIC-GROUP BY-HAVING",
            "SELECT-FROM-GEOGRAPHY-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the list of all European countries where there is at least three manufactures., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, t0.c4",
            "select countries.CountryName, countries.CountryId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the list of all European countries where there is at least three manufactures., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "continents car_makers",
            "",
            "countries car_makers",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of all European countries that have at least three manufactures., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of all European countries that have at least three manufactures., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName pour continents.Continent",
            "select countries.CountryName, continents.ContId2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of all European countries that have at least three manufactures., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "continents car_makers",
            "",
            "",
            "",
            "",
            "continents countries",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the list of all European countries with three or more manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GHOST-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the list of all European countries with three or more manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName, t0.c4",
            "select countries.CountryName, continents.ContId2",
            "select countries.CountryName, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the list of all European countries with three or more manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "continents car_makers",
            "countries car_makers",
            "",
            "",
            "",
            "continents countries",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all of Europe's nations with no less than three makers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all of Europe's nations with no less than three makers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, t0.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all of Europe's nations with no less than three makers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "continents car_makers",
            "",
            "",
            "countries car_makers",
            "continents countries",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all country names in Europe with three or more manufacturer., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all country names in Europe with three or more manufacturer., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, t0.c, max(car_makers.Maker)",
            "select countries.CountryName, t0.c, car_makers.Maker",
            "select countries.CountryName, continents.Continent, max(car_makers.Maker)",
            "select countries.CountryName, t0.c, min(car_makers.Maker)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all country names in Europe with three or more manufacturer., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "continents countries",
            "countries car_makers",
            "",
            "continents countries car_makers model_list",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the name of all European countries with three or more manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GAUSS-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GHOST-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the name of all European countries with three or more manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName (continents.ContId)",
            "select countries.CountryName, t0.c4",
            "select countries.CountryName de continents.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the name of all European countries with three or more manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "countries car_makers",
            "continents countries",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of all European countries that have three or more manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAUSS-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAUSS-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of all European countries that have three or more manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName pour continents.Continent",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, t0.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of all European countries that have three or more manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "continents car_makers",
            "countries car_makers",
            "",
            "",
            "continents countries",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the maximum horse power and the make of cars with three cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C1, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-C4, t4.c2"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the maximum horse power and the make of cars with three cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select max(t5.c4), t4.c2",
        "label": "select t5.c4, t4.c2",
        "score": false,
        "real_pred": "select max(cars_data.Horsepower), car_names.Make",
        "real_label": "select cars_data.Horsepower, car_names.Make",
        "topk_preds": [
            "select max(cars_data.Horsepower), car_names.Make",
            "select max(cars_data.Horsepower), cars_data.Cylinders",
            "select max(cars_data.Accelerate), car_names.Make",
            "select max(cars_data.Horsepower), car_names.Make)",
            "select Max(cars_data.Horsepower), car_names.Make",
            "select max(cars_data.Weight), car_names.Make",
            "select max(cars_data.Horsepower), car_makers.FullName",
            "select max(cars_data.Horsepower), car_names.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the maximum horse power and the make of cars with three cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "",
            "car_makers cars_data",
            "model_list car_names cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "model_list cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the maximum horsepower and the make of the car models with three cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the maximum horsepower and the make of the car models with three cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select max(t5.c4), t4.c2",
        "label": "select t5.c4, t4.c2",
        "score": false,
        "real_pred": "select max(cars_data.Horsepower), car_names.Make",
        "real_label": "select cars_data.Horsepower, car_names.Make",
        "topk_preds": [
            "select max(cars_data.Horsepower), car_names.Make",
            "select max(cars_data.Horsepower), cars_data.Cylinders",
            "select max(cars_data.Accelerate), car_names.Make",
            "select max(cars_data.Horsepower), car_names.Make)",
            "select Max(cars_data.Horsepower), car_names.Make",
            "select max(cars_data.Weight), car_names.Make",
            "select max(cars_data.Horsepower), car_makers.FullName",
            "select max(cars_data.Horsepower), t4c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the maximum horsepower and the make of the car models with three cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "countries car_names cars_data",
            "car_makers cars_data",
            "continents car_names cars_data",
            "",
            "model_list cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the maximum horsepower for cars with three cylinders and what makes they are., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-ORDER BY max(t5.c4), t4.c2",
            "SELECT-FROM-WHERE-INDICAT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY maxim(t5.c4), t4.c2"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the maximum horsepower for cars with three cylinders and what makes they are., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select max(t5.c4), t4.c2",
        "label": "select t5.c4, t4.c2",
        "score": false,
        "real_pred": "select max(cars_data.Horsepower), car_names.Make",
        "real_label": "select cars_data.Horsepower, car_names.Make",
        "topk_preds": [
            "select max(cars_data.Horsepower), car_names.Make",
            "select max(cars_data.Horsepower), cars_data.Cylinders",
            "select Max(cars_data.Horsepower), car_names.Make",
            "select max(cars_data.Accelerate), car_names.Make",
            "select cars_data.Horsepower, car_names.Make",
            "select max(cars_data.Weight), car_names.Make",
            "select max(cars_data.Horsepower), car_makers.FullName",
            "select max(cars_data.Horsepower), car_names.Make)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the maximum horsepower for cars with three cylinders and what makes they are., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "car_makers car_names cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the largest amount of horsepower for the models with three cylinders and what make is it?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the largest amount of horsepower for the models with three cylinders and what make is it?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select max(t5.c4), t4.c2",
        "label": "select t5.c4, t4.c2",
        "score": false,
        "real_pred": "select max(cars_data.Horsepower), car_names.Make",
        "real_label": "select cars_data.Horsepower, car_names.Make",
        "topk_preds": [
            "select max(cars_data.Horsepower), car_names.Make",
            "select cars_data.Horsepower, car_names.Make",
            "select max(cars_data.Horsepower), car_names.Make",
            "select max(cars_data.Horsepower), car_names.Model",
            "select maximum(cars_data.Horsepower), car_names.Make",
            "select max(cars_data.Horsepower), cars_data.Cylinders",
            "select max(cars_data.Accelerate), car_names.Make",
            "select car_names.Model, car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the largest amount of horsepower for the models with three cylinders and what make is it?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "countries car_names cars_data",
            "car_makers cars_data",
            "model_list cars_data",
            "continents car_names cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of cars that have more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE(count(*)",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of cars that have more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.Cylinders",
            "select count(*) (cars_data.Id)",
            "select count(0.c0)",
            "select count(*),",
            "select count(*), cars_data.MPG",
            "select count(cars_data.Id)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of cars that have more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show how many vehicles have more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE count(*)",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE(count(*)",
            "SELECT-FROM-WHERE-NUM(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show how many vehicles have more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.Cylinders",
            "select count(*) (cars_data.Id)",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.MPG",
            "select count(*), t5.dcars_data.Cylinders",
            "select count(cars_data.Id)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show how many vehicles have more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of cars with more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE(*)",
            "SELECT-FROM-WHERE(count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of cars with more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.Cylinders",
            "select count(*), cars_data.MPG, cars_data.Cylinders",
            "select count(*) (cars_data.Id)",
            "select count(*), cars_data.Cylinders, cars_data.Edispl",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.Id, cars_data.Cylinders"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of cars with more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the number of cars that have more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE(count(*)",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE count(*)",
            "SELECT-FROM-WHERE(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the number of cars that have more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.Cylinders",
            "select count(*) (cars_data.Id)",
            "select count(0.c0)",
            "select count(*),",
            "select count(*), cars_data.MPG",
            "select count(cars_data.Id)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the number of cars that have more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show how many cars have more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE count(*)",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE(count(*)",
            "SELECT-FROM-WHERE(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show how many cars have more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.Cylinders",
            "select count(*) (cars_data.Id)",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.MPG",
            "select count(*), t5.dcars_data.Cylinders",
            "select count(*),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show how many cars have more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of cars that have more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE(count(*)",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of cars that have more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.Cylinders",
            "select count(*) (cars_data.Id)",
            "select count(0.c0)",
            "select count(*),",
            "select count(*), cars_data.MPG",
            "select count(cars_data.Id)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of cars that have more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many cars have a cylinder count greater than four?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many cars have a cylinder count greater than four?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.MPG, cars_data.Cylinders",
            "select count(*), cars_data.Id, cars_data.Cylinders",
            "select count(*) (cars_data.Id)",
            "select count(*), t5.datum(cars_data.Id)",
            "select count(*), cars_data.Cylinders",
            "select count(*), t5.dcars_data.Id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many cars have a cylinder count greater than four?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many cars were produced for having more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many cars were produced for having more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.Cylinders",
            "select count(*) dependant on cars_data.Cylinders",
            "select count(*), t5.dcars_data.Id",
            "select count(*) (cars_data.Id)",
            "select count(*) denoted by cars_data.Id",
            "select count(*), cars_data.MPG"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many cars were produced for having more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "cars_data car_names",
            "car_names cars_data",
            "cars_data car_names cars_data",
            "",
            "model_list cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Count how many cars have more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE(t5.c0)",
            "SELECT SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE(count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Count how many cars have more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.Cylinders",
            "select count(*), t5.dcars_data.Id",
            "select count(*) (cars_data.Id)",
            "select count(*), cars_data.MPG",
            "select count(*), t5.dcars_data.Cylinders",
            "select count(*), t5.dcars_data.MPG"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Count how many cars have more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the numbers of cars with more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE_GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the numbers of cars with more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.Cylinders",
            "select count(*), cars_data.MPG, cars_data.Cylinders",
            "select count(*) (cars_data.Id)",
            "select count(*), cars_data.Cylinders, cars_data.Edispl",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.MPG"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the numbers of cars with more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of cars with more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE(*)",
            "SELECT-FROM-WHERE(count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of cars with more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.Cylinders",
            "select count(*), cars_data.MPG, cars_data.Cylinders",
            "select count(*) (cars_data.Id)",
            "select count(*), cars_data.Cylinders, cars_data.Edispl",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.Id, cars_data.Cylinders"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of cars with more than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show how many cars were made by the producer called American Motor Corporation., database: Database: car_1. t0: continents(c0: contid, c1: continent (america)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show how many cars were made by the producer called American Motor Corporation., database: Database: car_1. t0: continents(c0: contid, c1: continent (america)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), car_makers.FullName, car_makers.Maker",
            "select count(*), car_makers.Maker, car_makers.FullName",
            "select count(*), car_makers.FullName",
            "select count(*), car_makers.Maker",
            "select count(*), car_makers.FullName, car_makers.Maker",
            "select count(*), car_makers.Maker, car_makers.Country",
            "select count(*), car_makers.Maker, car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show how many cars were made by the producer called American Motor Corporation., database: Database: car_1. t0: continents(c0: contid, c1: continent (america)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4",
        "label": "t2 t3",
        "score": false,
        "real_pred": "car_makers car_names",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "car_makers car_names",
            "continents car_makers car_names",
            "countries car_makers car_names",
            "",
            "car_makers car_makers car_names",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all car models from the car-maker American Motors Corporation., database: Database: car_1. t0: continents(c0: contid, c1: continent (america)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all car models from the car-maker American Motors Corporation., database: Database: car_1. t0: continents(c0: contid, c1: continent (america)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select count(*)",
        "score": false,
        "real_pred": "select car_names.Model",
        "real_label": "select count(*)",
        "topk_preds": [
            "select car_names.Model",
            "select model_list.Model",
            "select car_names.Model, car_makers.FullName",
            "select car_names.Model, car_names.Make",
            "select model_list.Model, model_list.Maker",
            "select car_makers.FullName, model_list.Maker",
            "select model_list.Model, car_makers.Maker",
            "select car_makers.FullName, car_names.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all car models from the car-maker American Motors Corporation., database: Database: car_1. t0: continents(c0: contid, c1: continent (america)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t2 t3",
        "score": false,
        "real_pred": "car_makers model_list car_names",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "car_makers model_list car_names",
            "countries car_makers model_list car_names",
            "continents car_makers model_list car_names",
            "model_list car_names",
            "",
            "",
            "car_makers model_list car_makers car_names",
            "countries model_list car_names"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of car models made by the company American Motors., database: Database: car_1. t0: continents(c0: contid, c1: continent (america)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-GROUP BY -ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of car models made by the company American Motors., database: Database: car_1. t0: continents(c0: contid, c1: continent (america)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(distinct model_list.Model)",
            "select count(distinct car_names.Model)",
            "select count(*), car_makers.FullName",
            "select count(*), car_makers.Maker",
            "select count(distinct car_names.Make)",
            "select count(distinct model_list.Maker)",
            "select count(1, car_names.Model)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of car models made by the company American Motors., database: Database: car_1. t0: continents(c0: contid, c1: continent (america)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t2 t3 t4",
        "label": "t2 t3",
        "score": false,
        "real_pred": "continents car_makers model_list car_names",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "continents car_makers model_list car_names",
            "car_makers model_list car_names",
            "continents countries car_makers model_list car_names",
            "countries car_makers model_list car_names",
            "",
            "continents car_makers model_list",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of brands built by American Motors., database: Database: car_1. t0: continents(c0: contid, c1: continent (america)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (count(distinct t4.c2)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE(count(distinct t4.c2)",
            "SELECT-FROM-WHERE (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of brands built by American Motors., database: Database: car_1. t0: continents(c0: contid, c1: continent (america)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(distinct car_names.Make)",
            "select count(car_names.Make)",
            "select count(distinct car_names.Make), continents.Continent",
            "select count(distinct car_names.Model)",
            "select count(*), continents.Continent",
            "select count(distinct car_names.Make)",
            "select count(*), car_makers.Maker, car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of brands built by American Motors., database: Database: car_1. t0: continents(c0: contid, c1: continent (america)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t2 t4",
        "label": "t2 t3",
        "score": false,
        "real_pred": "continents car_makers car_names",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "continents car_makers car_names",
            "car_makers car_names",
            "",
            "continents countries car_makers car_names",
            "",
            "countries car_makers car_names",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the manufacturers that have created more than three car model., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the manufacturers that have created more than three car model., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c2, t2.c0",
        "score": false,
        "real_pred": "select car_makers.Maker",
        "real_label": "select car_makers.FullName, car_makers.Id",
        "topk_preds": [
            "select car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName",
            "select car_makers.Maker, car_makers.FullName, car_makers.Country",
            "select car_makers.FullName, car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName, car_makers.Id",
            "select car_makers.Maker, car_makers.FullName, car_makers.Country",
            "select car_makers.Id, car_makers.FullName, car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName, car_makers.Maker"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the manufacturers that have created more than three car model., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t2 t3",
        "score": false,
        "real_pred": "car_makers model_list car_names",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "car_makers model_list car_names",
            "car_makers model_list",
            "countries car_makers model_list car_names",
            "countries model_list car_names",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show full name of designers that made more than three car models and return their IDs., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show full name of designers that made more than three car models and return their IDs., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2, t2.c0",
        "label": "select t2.c2, t2.c0",
        "score": true,
        "real_pred": "select car_makers.FullName, car_makers.Id",
        "real_label": "select car_makers.FullName, car_makers.Id",
        "topk_preds": [
            "select car_makers.FullName, car_makers.Id",
            "select car_makers.Maker, car_makers.FullName, car_makers.Id",
            "select car_makers.FullName, car_names.Model, car_makers.Id",
            "select car_makers.FullName, model_list.Maker",
            "select car_makers.FullName, car_names.Model",
            "select car_makers.Id, car_makers.FullName",
            "select car_makers.Maker, car_makers.FullName, model_list.Maker",
            "select car_makers.FullName, car_names.Model, car_makers.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show full name of designers that made more than three car models and return their IDs., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t2 t3",
        "score": false,
        "real_pred": "car_makers model_list car_names",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "car_makers model_list car_names",
            "",
            "",
            "",
            "car_makers car_names",
            "car_makers model_list",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which designers designed more than three car models? List full name and the ID., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING, SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which designers designed more than three car models? List full name and the ID., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2, t2.c0",
        "label": "select t2.c2, t2.c0",
        "score": true,
        "real_pred": "select car_makers.FullName, car_makers.Id",
        "real_label": "select car_makers.FullName, car_makers.Id",
        "topk_preds": [
            "select car_makers.FullName, car_makers.Id",
            "select car_makers.Maker, car_makers.FullName, car_makers.Id",
            "select t2.c4, car_makers.FullName, car_makers.Id",
            "select car_makers.FullName, car_makers.Maker, car_makers.Id",
            "select car_makers.FullName, model_list.Maker, car_makers.Id",
            "select car_makers.FullName, car_makers.Id.",
            "select car_makers.FullName, car_makers.Id, car_makers.FullName",
            "select car_makers.FullName, car_makers.Id, car_makers.Maker"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which designers designed more than three car models? List full name and the ID., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t2 t3",
        "score": false,
        "real_pred": "car_makers model_list car_names",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "car_makers model_list car_names",
            "countries car_makers model_list car_names",
            "",
            "car_makers model_list",
            "",
            "car_makers car_names",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the full names and IDs of car designers that have designed more than three models., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the full names and IDs of car designers that have designed more than three models., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2, t2.c0",
        "label": "select t2.c2, t2.c0",
        "score": true,
        "real_pred": "select car_makers.FullName, car_makers.Id",
        "real_label": "select car_makers.FullName, car_makers.Id",
        "topk_preds": [
            "select car_makers.FullName, car_makers.Id",
            "select car_makers.Maker, car_makers.FullName, car_makers.Id",
            "select car_makers.FullName, car_makers.Id, car_makers.Country",
            "select t2.c5, car_makers.FullName, car_makers.Id",
            "select t2.c4, car_makers.FullName, car_makers.Id",
            "select car_makers.FullName, car_makers.Id, car_makers.Country",
            "select car_makers.FullName, car_makers.Id, car_makers.Maker",
            "select car_makers.FullName.c2, car_makers.Id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the full names and IDs of car designers that have designed more than three models., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t2 t3",
        "score": false,
        "real_pred": "car_makers model_list car_names",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "car_makers model_list car_names",
            "car_makers model_list",
            "car_makers car_names",
            "countries car_makers model_list car_names",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name and id of all manufacturers that have made more than three models?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name and id of all manufacturers that have made more than three models?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2, t2.c0",
        "label": "select t2.c2, t2.c0",
        "score": true,
        "real_pred": "select car_makers.FullName, car_makers.Id",
        "real_label": "select car_makers.FullName, car_makers.Id",
        "topk_preds": [
            "select car_makers.FullName, car_makers.Id",
            "select car_makers.Maker, car_makers.Id",
            "select car_makers.FullName, model_list.Maker",
            "select car_makers.Id, car_makers.FullName",
            "select t2.c4, car_makers.FullName",
            "select model_list.Maker, car_makers.FullName",
            "select car_makers.FullName, t2c0",
            "select countries.Continent, car_makers.Id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name and id of all manufacturers that have made more than three models?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "car_makers model_list",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "car_makers model_list",
            "car_makers model_list car_names",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all makers who have more than three models and show their names and IDs., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING, SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all makers who have more than three models and show their names and IDs., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2, t2.c0",
        "label": "select t2.c2, t2.c0",
        "score": true,
        "real_pred": "select car_makers.FullName, car_makers.Id",
        "real_label": "select car_makers.FullName, car_makers.Id",
        "topk_preds": [
            "select car_makers.FullName, car_makers.Id",
            "select car_makers.Maker, car_makers.Id",
            "select car_makers.Maker, model_list.ModelId",
            "select car_makers.FullName, model_list.Maker, model_list.ModelId",
            "select car_makers.Maker, car_makers.FullName, car_makers.Id",
            "select car_makers.Maker, car_makers.FullName, model_list.ModelId",
            "select car_makers.Maker, model_list.Maker, model_list.ModelId",
            "select model_list.Maker, car_makers.FullName, model_list.ModelId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all makers who have more than three models and show their names and IDs., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "car_makers model_list",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "car_makers model_list",
            "car_makers model_list car_names",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all makers who have more than three models and return their ids and names., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all makers who have more than three models and return their ids and names., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c0, t2.c2",
        "label": "select t2.c2, t2.c0",
        "score": false,
        "real_pred": "select car_makers.Id, car_makers.FullName",
        "real_label": "select car_makers.FullName, car_makers.Id",
        "topk_preds": [
            "select car_makers.Id, car_makers.FullName",
            "select model_list.Maker, car_makers.FullName",
            "select model_list.Maker, car_makers.Id, car_makers.FullName",
            "select model_list.Maker, car_makers.Id",
            "select car_makers.Id, car_makers.Maker",
            "select model_list.Maker, car_makers.Maker, car_makers.FullName",
            "select car_makers.Id, car_makers.Maker, car_makers.FullName",
            "select car_makers.Id, car_makers.FullName, model_list.Maker"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all makers who have more than three models and return their ids and names., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "car_makers model_list",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "car_makers model_list",
            "car_makers model_list car_names",
            "",
            "",
            "countries car_makers model_list",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all manufacturers with more than three models and return their names and ids., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all manufacturers with more than three models and return their names and ids., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2, t2.c0",
        "label": "select t2.c2, t2.c0",
        "score": true,
        "real_pred": "select car_makers.FullName, car_makers.Id",
        "real_label": "select car_makers.FullName, car_makers.Id",
        "topk_preds": [
            "select car_makers.FullName, car_makers.Id",
            "select car_makers.Maker, model_list.ModelId",
            "select car_makers.FullName, model_list.Maker, model_list.ModelId",
            "select car_makers.Maker, car_makers.Id",
            "select car_makers.FullName, model_list.Maker",
            "select car_makers.FullName, model_list.ModelId",
            "select car_makers.FullName, car_names.Model, car_names.MakeId",
            "select car_makers.FullName, car_names.Model, model_list.ModelId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all manufacturers with more than three models and return their names and ids., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t2 t3",
        "score": false,
        "real_pred": "car_makers model_list car_names",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "car_makers model_list car_names",
            "car_makers model_list",
            "continents car_makers model_list car_names",
            "",
            "countries model_list car_names",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all the makers that have more than three models and return their names and identifiers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all the makers that have more than three models and return their names and identifiers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2, t2.c0",
        "label": "select t2.c2, t2.c0",
        "score": true,
        "real_pred": "select car_makers.FullName, car_makers.Id",
        "real_label": "select car_makers.FullName, car_makers.Id",
        "topk_preds": [
            "select car_makers.FullName, car_makers.Id",
            "select car_makers.Maker, car_makers.Id",
            "select car_makers.FullName, model_list.Maker, model_list.ModelId",
            "select car_makers.Maker, car_makers.FullName, car_makers.Id",
            "select car_makers.Maker, model_list.Maker, model_list.ModelId",
            "select car_makers.FullName, model_list.Maker",
            "select car_makers.FullName, model_list.Maker, car_makers.Id",
            "select model_list.Maker, car_makers.FullName, car_makers.Id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all the makers that have more than three models and return their names and identifiers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "car_makers model_list",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "car_makers model_list",
            "car_makers model_list car_names",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names and ids of all makers with more than three models., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names and ids of all makers with more than three models., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2, t3.c1",
        "label": "select t2.c2, t2.c0",
        "score": false,
        "real_pred": "select car_makers.FullName, model_list.Maker",
        "real_label": "select car_makers.FullName, car_makers.Id",
        "topk_preds": [
            "select car_makers.FullName, model_list.Maker",
            "select car_makers.FullName, car_makers.Id",
            "select car_makers.Maker, model_list.Maker",
            "select car_makers.Maker, model_list.ModelId",
            "select car_makers.FullName, model_list.ModelId",
            "select car_makers.Maker, car_makers.Id",
            "select car_makers.FullName, car_names.Model",
            "select car_makers.FullName, t03.c1"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names and ids of all makers with more than three models., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "car_makers model_list",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "car_makers model_list",
            "car_makers model_list car_names",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the distinct models that can be manufactured by General Motors company and weigh more than 3,500 kg., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM cars-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the distinct models that can be manufactured by General Motors company and weigh more than 3,500 kg., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select distinct t3.c2",
        "label": "select distinct t3.c2",
        "score": true,
        "real_pred": "select distinct model_list.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select distinct model_list.Model",
            "select distinct model_list.Model, car_makers.Maker",
            "select distinct model_list.Model, car_makers.FullName",
            "select model_list.Model",
            "select distinct model_list.Model.c2",
            "select distinct model_list.Model, car_makers.Country",
            "select distinct model_list.Model, model_list.Maker",
            "select distinct model_list.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the distinct models that can be manufactured by General Motors company and weigh more than 3,500 kg., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers model_list cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers model_list cars_data",
            "car_makers model_list car_names",
            "countries car_makers model_list cars_data",
            "continents car_makers model_list cars_data",
            "",
            "countries car_makers model_list car_names",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all the cars made by the company General Motors and weighing over 3,500 lbs., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all the cars made by the company General Motors and weighing over 3,500 lbs., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select distinct t3.c2",
        "score": false,
        "real_pred": "select car_names.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.MakeId",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, car_makers.FullName",
            "select car_makers.Maker, car_names.Model",
            "select car_makers.Maker, car_makers.FullName",
            "select car_names.MakeId, car_makers.FullName",
            "select car_names.MakeId, car_names.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all the cars made by the company General Motors and weighing over 3,500 lbs., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers car_names cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "continents car_makers car_names cars_data",
            "countries car_makers car_names cars_data",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which distinctive models are made by the manufacturer General Motors or weigh more than 3,500?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which distinctive models are made by the manufacturer General Motors or weigh more than 3,500?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select distinct t3.c2",
        "label": "select distinct t3.c2",
        "score": true,
        "real_pred": "select distinct model_list.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select distinct model_list.Model",
            "select distinct model_list.Model, car_makers.Maker",
            "select distinct car_names.Model",
            "select distinct car_names.Model, car_names.Make",
            "select distinct model_list.Model, model_list.Maker",
            "select distinct car_names.Model, model_list.Model",
            "select distinct model_list.Maker",
            "select distinct model_list.Model, car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which distinctive models are made by the manufacturer General Motors or weigh more than 3,500?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers model_list car_names",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers model_list car_names",
            "car_makers model_list cars_data",
            "car_makers model_list car_names cars_data",
            "",
            "car_makers model_list car_makers car_names",
            "",
            "countries car_makers model_list cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the models made by either GM or weighing more than 3500., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (gm), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the models made by either GM or weighing more than 3500., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (gm), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c2",
        "label": "select distinct t3.c2",
        "score": false,
        "real_pred": "select model_list.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select model_list.Model",
            "select car_makers.Maker, model_list.Model",
            "select car_makers.Maker, car_makers.FullName",
            "select model_list.Model, car_makers.Maker",
            "select car_names.Model",
            "select car_makers.Maker, car_names.Make",
            "select model_list.Maker, model_list.Model",
            "select car_makers.Maker, model_list.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the models made by either GM or weighing more than 3500., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (gm), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers model_list cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers model_list cars_data",
            "countries car_makers model_list cars_data",
            "car_makers model_list car_names cars_data",
            "car_makers model_list car_names",
            "continents car_makers model_list cars_data",
            "model_list car_makers car_names cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: In which years cars weights no less than 3 thousand and no more than 4 thousand?., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: In which years cars weights no less than 3 thousand and no more than 4 thousand?., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c7",
        "label": "select distinct t5.c7",
        "score": false,
        "real_pred": "select cars_data.Year",
        "real_label": "select distinct cars_data.Year",
        "topk_preds": [
            "select cars_data.Year",
            "select distinct cars_data.Year",
            "select cars_data.Year, cars_data.Accelerate",
            "select cars_data.Year, t5.c8",
            "select cars_data.Year, cars_data.Cylinders",
            "select distinct cars_data.Year, t5.c8",
            "select cars_data.Year, cars_data.MPG",
            "select cars_data.Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: In which years cars weights no less than 3 thousand and no more than 4 thousand?., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Cars that weigh no less than 3,000 but no more than 4,000 were manufactured in what years?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-WHERE",
            "SELECT-FROM-WHERE-UNITED-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Cars that weigh no less than 3,000 but no more than 4,000 were manufactured in what years?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c7",
        "label": "select distinct t5.c7",
        "score": false,
        "real_pred": "select cars_data.Year",
        "real_label": "select distinct cars_data.Year",
        "topk_preds": [
            "select cars_data.Year",
            "select distinct cars_data.Year",
            "select specific cars_data.Year",
            "select cars_data.Year",
            "select the cars_data.Year",
            "select exact cars_data.Year",
            "select year(cars_data.Year)",
            "select years(cars_data.Year)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Cars that weigh no less than 3,000 but no more than 4,000 were manufactured in what years?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "model_list cars_data",
            "",
            "",
            "car_names cars_data",
            "",
            "cars_data car_names cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What year was it when cars were produced weighing no less than 3,000 and no more than 4,000?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What year was it when cars were produced weighing no less than 3,000 and no more than 4,000?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c7",
        "label": "select distinct t5.c7",
        "score": false,
        "real_pred": "select cars_data.Year",
        "real_label": "select distinct cars_data.Year",
        "topk_preds": [
            "select cars_data.Year",
            "select cars_data.Year",
            "select cars_data.Year (or t5.c8)",
            "select cars_data.Year (cars_data.Accelerate)",
            "select the cars_data.Year",
            "select cars_data.Year (in milliseconds)",
            "select cars_data.Year (t5.c8)",
            "select cars_data.Year (cars_data.Id)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What year was it when cars were produced weighing no less than 3,000 and no more than 4,000?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "model_list cars_data",
            "",
            "car_makers cars_data",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How about in which years the cars were produced weighting no less than 3,000 and no less than 4,000 kgs?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ACT-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How about in which years the cars were produced weighting no less than 3,000 and no less than 4,000 kgs?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c7",
        "label": "select distinct t5.c7",
        "score": false,
        "real_pred": "select cars_data.Year",
        "real_label": "select distinct cars_data.Year",
        "topk_preds": [
            "select cars_data.Year",
            "select distinct cars_data.Year",
            "select avg(cars_data.Year)",
            "select cars_data.Year",
            "select cars_data.Year, t5.c8",
            "select cars_data.Year, cars_data.Accelerate",
            "select cars_data.Year, cars_data.Cylinders",
            "select cars_data.Year,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How about in which years the cars were produced weighting no less than 3,000 and no less than 4,000 kgs?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "model_list cars_data",
            "car_names cars_data",
            "",
            "car_makers cars_data",
            "",
            "cars_data car_names",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What years had cars manufactured weighed no less than 3000 pounds and no more than 4,000 pounds?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What years had cars manufactured weighed no less than 3000 pounds and no more than 4,000 pounds?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c7",
        "label": "select distinct t5.c7",
        "score": false,
        "real_pred": "select cars_data.Year",
        "real_label": "select distinct cars_data.Year",
        "topk_preds": [
            "select cars_data.Year",
            "select distinct cars_data.Year",
            "select specific cars_data.Year",
            "select only cars_data.Year",
            "select unique cars_data.Year",
            "select years(cars_data.Year)",
            "select cars_data.Year",
            "select valid cars_data.Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What years had cars manufactured weighed no less than 3000 pounds and no more than 4,000 pounds?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "model_list cars_data",
            "",
            "",
            "",
            "car_makers cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all the years when there were cars produced that weighed less than 4,000 and also cars that weighed more than 3,000., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM both-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROMWHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTRACCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all the years when there were cars produced that weighed less than 4,000 and also cars that weighed more than 3,000., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c7",
        "label": "select distinct t5.c7",
        "score": false,
        "real_pred": "select cars_data.Year",
        "real_label": "select distinct cars_data.Year",
        "topk_preds": [
            "select cars_data.Year",
            "select cars_data.Year, cars_data.Accelerate",
            "select cars_data.Year, t5.c8",
            "select cars_data.Year, cars_data.MPG",
            "select cars_data.Year, cars_data.Cylinders",
            "select cars_data.Year",
            "select cars_data.Year, cars_data.Id",
            "select cars_data.Year, cars_data.Horsepower"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all the years when there were cars produced that weighed less than 4,000 and also cars that weighed more than 3,000., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "model_list cars_data",
            "",
            "car_makers cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the years when there was production of cars that weighed less than 4,000 and also cars that weight more than 3,000., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM both-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROMWHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM when-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM -WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the years when there was production of cars that weighed less than 4,000 and also cars that weight more than 3,000., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c7",
        "label": "select distinct t5.c7",
        "score": false,
        "real_pred": "select cars_data.Year",
        "real_label": "select distinct cars_data.Year",
        "topk_preds": [
            "select cars_data.Year",
            "select cars_data.Year, cars_data.Accelerate",
            "select cars_data.Year, t5.c8",
            "select cars_data.Year, cars_data.MPG",
            "select cars_data.Year, cars_data.Cylinders",
            "select cars_data.Year, cars_data.Horsepower",
            "select cars_data.Year, cars_data.MPG2",
            "select cars_data.Year, cars_data.MPG0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the years when there was production of cars that weighed less than 4,000 and also cars that weight more than 3,000., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "cars_data car_names",
            "",
            "",
            "model_list cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: In which years were cars produced that weigh less than 4000 and those that weight more than 3,000?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-SEPARATE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: In which years were cars produced that weigh less than 4000 and those that weight more than 3,000?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c7",
        "label": "select distinct t5.c7",
        "score": false,
        "real_pred": "select cars_data.Year",
        "real_label": "select distinct cars_data.Year",
        "topk_preds": [
            "select cars_data.Year",
            "select distinct cars_data.Year",
            "select cars_data.Year, t5.c8",
            "select cars_data.Year, cars_data.Accelerate",
            "select cars_data.Year, cars_data.MPG0",
            "select cars_data.Year, cars_data.Cylinders",
            "select cars_data.Year, cars_data.MPG2",
            "select cars_data.Year, cars_data.MPG"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: In which years were cars produced that weigh less than 4000 and those that weight more than 3,000?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "model_list cars_data",
            "car_makers cars_data",
            "",
            "car_names cars_data",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: show how many countries have more than two car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM QUARTER-GROUP BY-HAVING",
            "SELECT-FROM \"GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: show how many countries have more than two car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), countries.CountryName",
            "select count(*), car_makers.Country",
            "select count(*), countries.CountryId",
            "select count(distinct countries.CountryName)",
            "select count(1, car_makers.Country)",
            "select count(distinct car_makers.Country)",
            "select count(*) dependant on car_makers.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: show how many countries have more than two car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "countries car_makers model_list",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show how many countries have more than two carmakers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups by-GROUP BY-HAVING",
            "SELECT-FROM groups of carmakers-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show how many countries have more than two carmakers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), countries.CountryName",
            "select count(*), car_makers.Country",
            "select count(*), countries.CountryId",
            "select count(distinct countries.CountryName)",
            "select count(distinct car_makers.Country)",
            "select count(*) dependant on car_makers.Country",
            "select count(countries.CountryName)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show how many countries have more than two carmakers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show how many countries has more than two car makers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups by-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show how many countries has more than two car makers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), car_makers.Country",
            "select count(*), countries.CountryName",
            "select count(*), countries.CountryId",
            "select count(distinct countries.CountryName)",
            "select count(1, car_makers.Country)",
            "select count(distinct car_makers.Country)",
            "select count(countries.CountryName)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show how many countries has more than two car makers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "countries car_makers model_list",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of countries whose is more than two car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups by-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of countries whose is more than two car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), countries.CountryName",
            "select count(*), car_makers.Country",
            "select count(*), countries.CountryId",
            "select count(1, car_makers.Country)",
            "select count(distinct countries.CountryName)",
            "select count(*) dependant on car_makers.Country",
            "select count(countries.CountryName)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of countries whose is more than two car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of nations with more than two car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups by-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM gROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of nations with more than two car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), countries.CountryName",
            "select count(*), car_makers.Country",
            "select count(*) dependant on car_makers.Country",
            "select count(*), countries.CountryId",
            "select count(*),",
            "select count(*), http://countries.CountryName",
            "select count(*) descended from car_makers.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of nations with more than two car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of countries where there are more than two car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups by-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of countries where there are more than two car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), countries.CountryName",
            "select count(*), car_makers.Country",
            "select count(distinct countries.CountryName)",
            "select count(1, car_makers.Country)",
            "select count(*), countries.CountryId",
            "select count(distinct car_makers.Country)",
            "select count(*),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of countries where there are more than two car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of countries that have more than two car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups by-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of countries that have more than two car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), countries.CountryName",
            "select count(*), car_makers.Country",
            "select count(*), countries.CountryId",
            "select count(distinct countries.CountryName)",
            "select count(1, car_makers.Country)",
            "select count(*),",
            "select count(*) dependant on car_makers.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of countries that have more than two car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of countries where there are more than two car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups by-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of countries where there are more than two car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), car_makers.Country",
            "select count(*), countries.CountryName",
            "select count(distinct car_makers.Country)",
            "select count(1, car_makers.Country)",
            "select count(distinct countries.CountryName)",
            "select count(countries.CountryName)",
            "select count(*),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of countries where there are more than two car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "car_makers",
            "continents countries car_makers",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the numbers of countries with more than two car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups by-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the numbers of countries with more than two car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), countries.CountryName",
            "select count(*), car_makers.Country",
            "select count(*), countries.CountryName, car_makers.Country",
            "select count(*), countries.CountryId",
            "select count(*), countries.CountryName, countries.CountryId",
            "select count(*), countries.CountryName, countries.Continent",
            "select count(*), countries.CountryId, countries.CountryName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the numbers of countries with more than two car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many countries have more than two car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM QUANTITIES-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups by-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many countries have more than two car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), countries.CountryName",
            "select count(*), car_makers.Country",
            "select count(distinct countries.CountryName)",
            "select count(*), countries.CountryId",
            "select count(1, car_makers.Country)",
            "select count(distinct car_makers.Country)",
            "select count(countries.CountryName)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many countries have more than two car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "countries car_makers model_list",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Identify the number of car models that have over six cylinder engines., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE(count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Identify the number of car models that have over six cylinder engines., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(distinct car_names.Model)",
            "select count(*), cars_data.Cylinders",
            "select count(*), cars_data.Id",
            "select count(*), car_names.Model",
            "select count(*), cars_data.MPG",
            "select count(distinct car_names.MakeId)",
            "select count(*),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Identify the number of car models that have over six cylinder engines., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t5",
        "score": false,
        "real_pred": "car_names cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "car_makers cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "countries cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me how many cars were over six cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE_GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me how many cars were over six cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Cylinders",
            "select count(*), cars_data.Id",
            "select count(*) (cars_data.Id)",
            "select count(*), t5.dcars_data.Cylinders",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.MPG",
            "select t5.c count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me how many cars were over six cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show how many cars have more than six cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE count(*)",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE(*)",
            "SELECT-FROM-WHERE(count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show how many cars have more than six cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.Cylinders",
            "select count(*) (cars_data.Id)",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.MPG",
            "select count(*), t5.dcars_data.Cylinders",
            "select count(*),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show how many cars have more than six cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: show the number of cars that have over six cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE in count(*)",
            "SELECT-FROM-WHERE(count(*)",
            "SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: show the number of cars that have over six cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Cylinders",
            "select count(*), cars_data.Id",
            "select count(*) dependant on cars_data.Cylinders",
            "select count(*) (cars_data.Id)",
            "select count(*) dependant on cars_data.Id",
            "select count(*),",
            "select count(*), cars_data.MPG"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: show the number of cars that have over six cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of cars with more than six cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE(*)",
            "SELECT-FROM-WHERE(count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of cars with more than six cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.Cylinders",
            "select count(*), cars_data.MPG, cars_data.Cylinders",
            "select count(*) (cars_data.Id)",
            "select count(*), cars_data.Cylinders, cars_data.Edispl",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.Id, cars_data.Cylinders"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of cars with more than six cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of vehicles with over six cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE_GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of vehicles with over six cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.MPG, cars_data.Cylinders",
            "select count(*), cars_data.Cylinders",
            "select count(*) (cars_data.Id)",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.Id, cars_data.Cylinders",
            "select count(*), cars_data.MPG"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of vehicles with over six cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of vehicles with more than six cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE (t5.c0)",
            "SELECT-FROM-WHERE(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of vehicles with more than six cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*) (cars_data.Id)",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.Cylinders",
            "select count(*),",
            "select count(*), cars_data.MPG",
            "select count(0.c0)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of vehicles with more than six cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show how many cars have over six cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show how many cars have over six cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.Cylinders",
            "select count(*) (cars_data.Id)",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.MPG",
            "select count(*), t5.dcars_data.Cylinders",
            "select count(*),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show how many cars have over six cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The number of cars that have more than six cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE count(*)",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE(count(*)",
            "SELECT-FROM-WHERE(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The number of cars that have more than six cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*) (cars_data.Id)",
            "select count(*), cars_data.Cylinders",
            "select count(*),",
            "select count(*), cars_data.MPG",
            "select count(0.c0)",
            "select count(cars_data.Id)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The number of cars that have more than six cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For the four-cylinder cars, what model is the largest horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE ORDER BY-LIMIT",
            "SELECT-FROM-WHEREORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For the four-cylinder cars, what model is the largest horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, cars_data.Cylinders",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, cars_data.Id",
            "select car_names.Model, cars_data.Edispl",
            "select car_names.Model (cars_data.Cylinders)",
            "select car_names.Model, cars_data.Accelerate",
            "select car_names.Model, car_names.MakeId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For the four-cylinder cars, what model is the largest horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "car_makers cars_data",
            "continents car_names cars_data",
            "countries cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For cars with four cylinders, show me the car models that have the most horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For cars with four cylinders, show me the car models that have the most horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, cars_data.Cylinders",
            "select car_names.Model, cars_data.Id",
            "select car_names.Model, t4.c3",
            "select car_names.Model, model_list.Model",
            "select car_names.Model, car_names.MakeId",
            "select car_names.Model (car_names.Make)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For cars with four cylinders, show me the car models that have the most horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "car_makers cars_data",
            "countries cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which car model with four cylinder engines has the largest power., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which car model with four cylinder engines has the largest power., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, model_list.Model",
            "select car_names.Model, cars_data.Cylinders",
            "select car_names.Model (car_names.Make)",
            "select car_names.Model, t4.c3",
            "select car_names.Model, car_makers.FullName",
            "select car_names.Model, countries.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which car model with four cylinder engines has the largest power., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "countries car_names cars_data",
            "continents model_list car_names cars_data",
            "continents car_names cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For all four-cylinder cars, what model has the most horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For all four-cylinder cars, what model has the most horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, cars_data.Cylinders",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, cars_data.Id",
            "select car_names.Model (cars_data.Cylinders)",
            "select car_names.Model, cars_data.Edispl",
            "select car_names.Model, cars_data.Weight",
            "select car_names.Model, cars_data.Accelerate"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For all four-cylinder cars, what model has the most horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "car_makers cars_data",
            "countries cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the models of four cylinder cars that have the highest horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the models of four cylinder cars that have the highest horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select model_list.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, model_list.Model",
            "select car_names.Model (car_names.Make)",
            "select model_list.Model, car_names.Model",
            "select car_names.Make",
            "select car_names.Model, t4.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the models of four cylinder cars that have the highest horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list cars_data",
            "model_list car_names cars_data",
            "car_names cars_data",
            "countries car_names cars_data",
            "car_makers car_names cars_data",
            "car_makers model_list cars_data",
            "continents model_list cars_data",
            "car_makers cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For the four-cylinder cars show which models have the greatest horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE or-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE\u2013ORDER BY-LIMIT",
            "SELECT-FROM-WHEREORDER BY-LIMIT",
            "SELECT-FROM-WHERE,-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For the four-cylinder cars show which models have the greatest horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, cars_data.Cylinders",
            "select car_names.Model, cars_data.Id",
            "select car_names.Model, car_names.MakeId",
            "select car_names.Model (cars_data.Cylinders)",
            "select car_names.Model def. cars_data.Cylinders",
            "select car_names.Model, cars_data.Edispl"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For the four-cylinder cars show which models have the greatest horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "cars_data",
            "model_list car_names cars_data",
            "continents car_names cars_data",
            "car_makers cars_data",
            "countries cars_data",
            "model_list cars_data",
            "continents cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the models of four-cylinder cars with the most power., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the models of four-cylinder cars with the most power., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select model_list.Model",
            "select car_names.Model, model_list.Model",
            "select car_names.Model, car_names.Make",
            "select model_list.Model, car_names.Model",
            "select car_names.Make",
            "select car_names.Model (car_names.Make)",
            "select car_names.Model, t4.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the models of four-cylinder cars with the most power., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list cars_data",
            "model_list car_names cars_data",
            "car_makers model_list cars_data",
            "countries car_names cars_data",
            "car_names cars_data",
            "car_makers car_names cars_data",
            "continents model_list cars_data",
            "car_makers cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For all cars of the four-cylinder engine, show me the car model that has the greatest power., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For all cars of the four-cylinder engine, show me the car model that has the greatest power., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, cars_data.Cylinders",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, cars_data.Edispl",
            "select car_names.Model, model_list.Model",
            "select car_names.Model, t4.c3",
            "select car_names.Model (cars_data.Horsepower)",
            "select car_names.Model, cars_data.Accelerate"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For all cars of the four-cylinder engine, show me the car model that has the greatest power., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "car_makers cars_data",
            "countries cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Among the cars with more than the lowest horsepower, which ones do not have more than three cylinders? List the car make and make name., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE, SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Among the cars with more than the lowest horsepower, which ones do not have more than three cylinders? List the car make and make name., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c2, t4.c2",
        "label": "select t4.c0, t4.c2",
        "score": false,
        "real_pred": "select car_names.Make, car_names.Make",
        "real_label": "select car_names.MakeId, car_names.Make",
        "topk_preds": [
            "select car_names.Make, car_names.Make",
            "select car_names.Make, car_names.Model",
            "select car_names.Make, t4.c4",
            "select car_names.Make, t4.c3",
            "select car_names.Make, car_names.MakeId",
            "select car_names.Model, car_names.Make",
            "select distinct car_names.Make, car_names.MakeId",
            "select car_names.MakeId, car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Among the cars with more than the lowest horsepower, which ones do not have more than three cylinders? List the car make and make name., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "car_makers car_names cars_data",
            "model_list car_names cars_data",
            "car_makers cars_data",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Among the cars with more than lowest horsepower, which ones do not have more than three cylinders? Explain the makeid and make name., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE -EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE.EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE but-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2014EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Among the cars with more than lowest horsepower, which ones do not have more than three cylinders? Explain the makeid and make name., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c0, t4.c2",
        "label": "select t4.c0, t4.c2",
        "score": true,
        "real_pred": "select car_names.MakeId, car_names.Make",
        "real_label": "select car_names.MakeId, car_names.Make",
        "topk_preds": [
            "select car_names.MakeId, car_names.Make",
            "select car_names.Model, car_names.Make",
            "select car_makers.Id, car_names.Make",
            "select car_names.Make, car_names.MakeId",
            "select car_names.MakeId, car_names.Make",
            "select distinct car_names.MakeId, car_names.Make",
            "select cars_data.Id, car_names.Make",
            "select t4.c, car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Among the cars with more than lowest horsepower, which ones do not have more than three cylinders? Explain the makeid and make name., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "countries car_names cars_data",
            "car_makers cars_data",
            "model_list cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Among the cars that do not have the minimum power, what are the make IDs and names of all those with less than four cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WITH-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Among the cars that do not have the minimum power, what are the make IDs and names of all those with less than four cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c0, t4.c2",
        "label": "select t4.c0, t4.c2",
        "score": true,
        "real_pred": "select car_names.MakeId, car_names.Make",
        "real_label": "select car_names.MakeId, car_names.Make",
        "topk_preds": [
            "select car_names.MakeId, car_names.Make",
            "select car_names.Make, car_names.Make",
            "select car_names.Make, car_names.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.MakeId, car_names.Model",
            "select car_makers.Id, car_names.Make",
            "select distinct car_names.MakeId, car_names.Make",
            "select car_names.Make, t4.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Among the cars that do not have the minimum power, what are the make IDs and names of all those with less than four cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "car_makers cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the mileage per gallon of the car produced in 1980 or earlier that have eight cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the mileage per gallon of the car produced in 1980 or earlier that have eight cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c1",
        "label": "select max(t5.c1)",
        "score": false,
        "real_pred": "select cars_data.MPG",
        "real_label": "select max(cars_data.MPG)",
        "topk_preds": [
            "select cars_data.MPG",
            "select cars_data.MPG, cars_data.Cylinders",
            "select avg(cars_data.MPG)",
            "select mpg(cars_data.MPG)",
            "select cars_data.MPG, t5.c8",
            "select cars_data.MPG, cars_data.Year",
            "select cars_data.MPG (cars_data.Cylinders)",
            "select cars_data.MPG, cars_data.Accelerate"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the mileage per gallon of the car produced in 1980 or earlier that have eight cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "cars_data car_names cars_data",
            "car_names cars_data",
            "model_list cars_data",
            "cars_data car_names",
            "",
            "car_makers cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the maximum MPG of the car that has at least eight cylinders and was produced before 1980., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (max(t5.c1)",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the maximum MPG of the car that has at least eight cylinders and was produced before 1980., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select max(t5.c1)",
        "label": "select max(t5.c1)",
        "score": true,
        "real_pred": "select max(cars_data.MPG)",
        "real_label": "select max(cars_data.MPG)",
        "topk_preds": [
            "select max(cars_data.MPG)",
            "select max(cars_data.MPG), cars_data.Cylinders",
            "select max(cars_data.MPG), cars_data.Year",
            "select max(cars_data.MPG) delegated to cars_data.Id",
            "select max(cars_data.MPG), cars_data.Accelerate",
            "select max(cars_data.MPG), cars_data.Id",
            "select max(cars_data.MPG), cars_data.Cylinders",
            "select max(cars_data.MPG) delegated to cars_data.Cylinders"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the maximum MPG of the car that has at least eight cylinders and was produced before 1980., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            "cars_data car_names cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the mileage per gallon of eight-cylinder cars or produced before 1980., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the mileage per gallon of eight-cylinder cars or produced before 1980., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c1",
        "label": "select max(t5.c1)",
        "score": false,
        "real_pred": "select cars_data.MPG",
        "real_label": "select max(cars_data.MPG)",
        "topk_preds": [
            "select cars_data.MPG",
            "select cars_data.MPG, cars_data.Cylinders",
            "select avg(cars_data.MPG)",
            "select cars_data.MPG, t5.c8",
            "select cars_data.MPG, cars_data.Accelerate",
            "select mpg(cars_data.MPG)",
            "select cars_data.MPG, cars_data.Year",
            "select distinct cars_data.MPG"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the mileage per gallon of eight-cylinder cars or produced before 1980., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Determine the mpg of the cars that had eight cylinders or were produced before 1980., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Determine the mpg of the cars that had eight cylinders or were produced before 1980., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c1",
        "label": "select max(t5.c1)",
        "score": false,
        "real_pred": "select cars_data.MPG",
        "real_label": "select max(cars_data.MPG)",
        "topk_preds": [
            "select cars_data.MPG",
            "select cars_data.MPG, cars_data.Cylinders, cars_data.Year",
            "select cars_data.MPG, cars_data.Cylinders",
            "select avg(cars_data.MPG)",
            "select cars_data.MPG, cars_data.Year",
            "select cars_data.MPG, cars_data.Cylinders ou cars_data.Year",
            "select cars_data.MPG, t5.c8",
            "select cars_data.MPG, cars_data.Cylinders or cars_data.Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Determine the mpg of the cars that had eight cylinders or were produced before 1980., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the mileage of the cars that had eight cylinders or were produced before 1980., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the mileage of the cars that had eight cylinders or were produced before 1980., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c1",
        "label": "select max(t5.c1)",
        "score": false,
        "real_pred": "select cars_data.MPG",
        "real_label": "select max(cars_data.MPG)",
        "topk_preds": [
            "select cars_data.MPG",
            "select cars_data.MPG, cars_data.Cylinders, cars_data.Year",
            "select cars_data.MPG, cars_data.Cylinders",
            "select cars_data.MPG, cars_data.Cylinders ou cars_data.Year",
            "select cars_data.MPG, cars_data.Cylinders.c3, cars_data.Year",
            "select avg(cars_data.MPG)",
            "select cars_data.MPG, cars_data.Cylinders or cars_data.Year",
            "select cars_data.MPG, cars_data.Cylinders oder cars_data.Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the mileage of the cars that had eight cylinders or were produced before 1980., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: show me the models that are lighter than 3.5K but not made by the 'Ford Corporation'., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE,-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE.EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: show me the models that are lighter than 3.5K but not made by the 'Ford Corporation'., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c2",
        "label": "select distinct t3.c2",
        "score": false,
        "real_pred": "select model_list.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select model_list.Model",
            "select car_names.Model",
            "select car_names.Make",
            "select car_names.Model, model_list.Maker",
            "select model_list.Model, model_list.Maker",
            "select model_list.Maker",
            "select car_names.Make, model_list.Maker",
            "select t3.c3, model_list.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: show me the models that are lighter than 3.5K but not made by the 'Ford Corporation'., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "model_list cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "model_list cars_data",
            "model_list car_names",
            "car_makers model_list car_names",
            "car_makers model_list cars_data",
            "continents car_makers model_list car_names",
            "countries model_list car_names",
            "continents car_makers model_list cars_data",
            "countries model_list cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which cars are lighter than 3500 pounds but not made by Ford?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE,-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE but-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2014EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which cars are lighter than 3500 pounds but not made by Ford?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select distinct t3.c2",
        "score": false,
        "real_pred": "select car_names.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.MakeId",
            "select car_names.Model, car_names.Make",
            "select car_names.MakeId, car_names.Model",
            "select car_names.Make",
            "select car_makers.FullName, car_names.Model",
            "select car_names.Model-, car_names.Make",
            "select car_names.Model, car_names.MakeId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which cars are lighter than 3500 pounds but not made by Ford?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers car_names cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers car_names cars_data",
            "car_names cars_data",
            "model_list car_names cars_data",
            "countries car_makers car_names cars_data",
            "model_list car_makers car_names cars_data",
            "continents car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "countries car_names cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show model cars that weigh less than 3500 and are NOT manufactured by Ford., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE AND-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-CHER-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show model cars that weigh less than 3500 and are NOT manufactured by Ford., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select distinct t3.c2",
        "score": false,
        "real_pred": "select car_names.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, model_list.Model",
            "select cars_data.Weight, car_names.Model",
            "select cars_data.Weight",
            "select car_names.Model, model_list.Maker",
            "select car_names.MakeId",
            "select cars_data.Weight, model_list.Maker"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show model cars that weigh less than 3500 and are NOT manufactured by Ford., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "model_list car_names cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "model_list car_names cars_data",
            "car_makers model_list car_names cars_data",
            "model_list car_names",
            "car_makers model_list car_names",
            "countries model_list car_names cars_data",
            "continents model_list car_names cars_data",
            "",
            "countries car_names cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which are the auto-makers which produce two or more models and more three auto makers? List the ids along with the makes., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING AND-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUPGROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING/INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM groups BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which are the auto-makers which produce two or more models and more three auto makers? List the ids along with the makes., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c0, t4.c2",
        "label": "select t2.c0, t2.c1",
        "score": false,
        "real_pred": "select car_names.MakeId, car_names.Make",
        "real_label": "select car_makers.Id, car_makers.Maker",
        "topk_preds": [
            "select car_names.MakeId, car_names.Make",
            "select car_names.Model, car_names.Make",
            "select car_names.Make, car_names.Model",
            "select car_names.Make, car_names.MakeId",
            "select car_names.MakeId, car_names.Make",
            "select car_names.Model, car_names.Make",
            "select t4.c make, car_names.MakeId",
            "select car_makers.Id, car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which are the auto-makers which produce two or more models and more three auto makers? List the ids along with the makes., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4",
        "label": "t2 t3 t4",
        "score": false,
        "real_pred": "model_list car_names",
        "real_label": "car_makers model_list car_names",
        "topk_preds": [
            "model_list car_names",
            "car_names",
            "car_makers model_list car_names",
            "car_makers car_names",
            "continents model_list car_names",
            "countries car_names",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the ids and makers of all car manufacturers that produce at least two models and make more than three cars., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING/INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING AND-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING AND-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING\u2013INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTENT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the ids and makers of all car manufacturers that produce at least two models and make more than three cars., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c0, t2.c1",
        "label": "select t2.c0, t2.c1",
        "score": true,
        "real_pred": "select car_makers.Id, car_makers.Maker",
        "real_label": "select car_makers.Id, car_makers.Maker",
        "topk_preds": [
            "select car_makers.Id, car_makers.Maker",
            "select car_names.Model, car_makers.Maker",
            "select model_list.Maker, car_makers.Maker",
            "select car_names.Make, car_makers.Maker",
            "select model_list.ModelId, car_makers.Maker",
            "select car_names.MakeId, car_makers.Maker",
            "select countries.CountryId, car_makers.Maker",
            "select car_makers.Maker, car_makers.Id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the ids and makers of all car manufacturers that produce at least two models and make more than three cars., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t2 t3 t4",
        "score": true,
        "real_pred": "car_makers model_list car_names",
        "real_label": "car_makers model_list car_names",
        "topk_preds": [
            "car_makers model_list car_names",
            "countries car_makers model_list car_names",
            "continents car_makers model_list car_names",
            "",
            "countries model_list car_names",
            "model_list car_names",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the id's and manufactures of all car makers that have two or more models and makes three or more cars?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-SECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-SECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-SCALE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-SUIT-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the id's and manufactures of all car makers that have two or more models and makes three or more cars?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c0, t2.c1",
        "label": "select t2.c0, t2.c1",
        "score": true,
        "real_pred": "select car_makers.Id, car_makers.Maker",
        "real_label": "select car_makers.Id, car_makers.Maker",
        "topk_preds": [
            "select car_makers.Id, car_makers.Maker",
            "select car_names.Model, car_makers.Maker",
            "select model_list.ModelId, car_makers.Maker",
            "select car_names.Model, car_names.Model",
            "select car_names.MakeId, car_makers.Maker",
            "select car_names.Model, car_names.Make",
            "select model_list.Maker, car_makers.Maker",
            "select car_names.Make, car_makers.Id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the id's and manufactures of all car makers that have two or more models and makes three or more cars?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t2 t3 t4",
        "score": true,
        "real_pred": "car_makers model_list car_names",
        "real_label": "car_makers model_list car_names",
        "topk_preds": [
            "car_makers model_list car_names",
            "model_list car_names",
            "countries car_makers model_list car_names",
            "countries model_list car_names",
            "continents car_makers model_list car_names",
            "",
            "car_makers car_names",
            "countries car_makers car_names"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the ids and names of the countries that make more than three cars or produce Fiat vehicles., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-SPECIFIC-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the ids and names of the countries that make more than three cars or produce Fiat vehicles., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c0, t1.c1",
        "label": "select t1.c0, t1.c1",
        "score": true,
        "real_pred": "select countries.CountryId, countries.CountryName",
        "real_label": "select countries.CountryId, countries.CountryName",
        "topk_preds": [
            "select countries.CountryId, countries.CountryName",
            "select car_makers.Id, countries.CountryName",
            "select countries.CountryName, countries.CountryId",
            "select car_makers.Maker, countries.CountryName",
            "select car_makers.Country, countries.CountryName",
            "select countries.CountryId, countries.CountryName,",
            "select countries.Continent, countries.CountryName",
            "select countries.CountryId-, countries.CountryName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the ids and names of the countries that make more than three cars or produce Fiat vehicles., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers model_list",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "countries car_makers car_names",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the ids and names of all countries that either have more than three car makers or produce Fiat models?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-3-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the ids and names of all countries that either have more than three car makers or produce Fiat models?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c0, t1.c1",
        "label": "select t1.c0, t1.c1",
        "score": true,
        "real_pred": "select countries.CountryId, countries.CountryName",
        "real_label": "select countries.CountryId, countries.CountryName",
        "topk_preds": [
            "select countries.CountryId, countries.CountryName",
            "select car_makers.Id, countries.CountryName",
            "select countries.CountryId, countries.CountryName, car_makers.Country",
            "select t1, car_makers.Id, countries.CountryName",
            "select countries.CountryName, countries.CountryId",
            "select car_names.Model, countries.CountryId",
            "select car_names.Model, countries.CountryId, countries.CountryName",
            "select countries.CountryId, countries.CountryName,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the ids and names of all countries that either have more than three car makers or produce Fiat models?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2 t3 t4",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "countries car_makers model_list car_names",
        "real_label": "countries car_makers model_list",
        "topk_preds": [
            "countries car_makers model_list car_names",
            "countries car_makers model_list",
            "",
            "countries model_list car_names",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the country which is the home of airline \"JetBlue Airlines\"., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the country which is the home of airline \"JetBlue Airlines\"., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c3",
        "label": "select t0.c3",
        "score": true,
        "real_pred": "select airlines.Country",
        "real_label": "select airlines.Country",
        "topk_preds": [
            "select airlines.Country",
            "select airlines.Country, airlines.Abbreviation",
            "select airlines.Country (https://airlines.Country)",
            "select t0, airlines.Country",
            "select airlines.Country (http://airlines.Country)",
            "select airlines.Country, t0.c4",
            "select airlines.Country (flight_2.c3)",
            "select airlines.Country, airlines.Airline"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the country which is the home of airline \"JetBlue Airlines\"., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: which country is jetblue associated with?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INSERT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: which country is jetblue associated with?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c3",
        "label": "select t0.c3",
        "score": true,
        "real_pred": "select airlines.Country",
        "real_label": "select airlines.Country",
        "topk_preds": [
            "select airlines.Country",
            "select airlines.Country, airlines.Abbreviation",
            "select airlines.Country, airlines.Abbreviation, airlines.Country",
            "select airlines.Country, airlines.Abbreviation, airlines.Airline",
            "select airlines.Country, t0.c4",
            "select airlines.Country, airlines.Abbreviation, airlines.uid",
            "select distinct airlines.Country",
            "select airlines.Country, airlines.Abbreviation, t0.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: which country is jetblue associated with?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: show me the countries that JetBlue is affiliated with., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: show me the countries that JetBlue is affiliated with., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c3",
        "label": "select t0.c3",
        "score": true,
        "real_pred": "select airlines.Country",
        "real_label": "select airlines.Country",
        "topk_preds": [
            "select airlines.Country",
            "select distinct airlines.Country",
            "select affiliated airlines.Country",
            "select airlines.Country, airlines.Abbreviation",
            "select airlines.Country, t0.c4",
            "select list(airlines.Country)",
            "select distinct airlines.Country, airlines.Abbreviation",
            "select distinct airlines.Country, t0.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: show me the countries that JetBlue is affiliated with., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "airlines airports",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me which countries JetBlue Airlines is affiliated with., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACCESS-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACCESS-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me which countries JetBlue Airlines is affiliated with., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c3",
        "label": "select t0.c3",
        "score": true,
        "real_pred": "select airlines.Country",
        "real_label": "select airlines.Country",
        "topk_preds": [
            "select airlines.Country",
            "select distinct airlines.Country",
            "select airlines.Country, airlines.Abbreviation",
            "select affiliated airlines.Country",
            "select list(airlines.Country)",
            "select airlines.Country, t0.c4",
            "select distinct airlines.Country, airlines.Abbreviation",
            "select distinct airlines.Country, t0.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me which countries JetBlue Airlines is affiliated with., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the abbreviated name of Airline Jet Blue?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the abbreviated name of Airline Jet Blue?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select airlines.Abbreviation",
        "real_label": "select airlines.Abbreviation",
        "topk_preds": [
            "select airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.uid, airlines.Abbreviation",
            "select airlines.Abbreviation, airlines.Airline",
            "select airlines.Abbreviation, airlines.Country",
            "select airlines.uid, airlines.Airline",
            "select airlines.Airline-, airlines.Abbreviation",
            "select airlines.Abbreviation (or airlines.Airline)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the abbreviated name of Airline Jet Blue?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Identify JetBLueAirways using abbreviations., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Identify JetBLueAirways using abbreviations., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select airlines.Abbreviation",
        "real_label": "select airlines.Abbreviation",
        "topk_preds": [
            "select airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.uid, airlines.Abbreviation",
            "select airlines.Abbreviation, airlines.Airline",
            "select airlines.Airline",
            "select airlines.Abbreviation (select airlines.Airline)",
            "select airlines.uid, airlines.Airline",
            "select distinct airlines.Abbreviation"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Identify JetBLueAirways using abbreviations., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "airlines airports",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all airline name and their abbreviations in United States of America., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (American), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all airline name and their abbreviations in United States of America., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (American), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select airlines.Airline, airlines.Abbreviation",
        "real_label": "select airlines.Airline, airlines.Abbreviation",
        "topk_preds": [
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation2",
            "select airlines.Airline, airlines.uid2",
            "select airlines.Airline, airlines.Abbreviation,",
            "select airlines.Airline, airlines.Abbreviation0",
            "select airlines.Airline, airlines.Abbreviation-",
            "select airlines.Airline, airlines.Abbreviation)",
            "select airlines.Airline, t0.c 2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all airline name and their abbreviations in United States of America., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (American), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: list the all airline names and its abbreviation from US., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev (US)). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: list the all airline names and its abbreviation from US., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev (US)). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select airlines.Airline, airlines.Abbreviation",
        "real_label": "select airlines.Airline, airlines.Abbreviation",
        "topk_preds": [
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation2",
            "select airlines.Airline, airlines.Abbreviation,",
            "select airlines.Airline, airlines.uid2",
            "select airlines.Airline, airlines.Abbreviation)",
            "select airlines.Airline, airlines.Abbreviation-",
            "select airlines.Airline, airlines.Abbreviation0",
            "select airlines.Airline, airlines.Abbreviation."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: list the all airline names and its abbreviation from US., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev (US)). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names and the abbreviations for the United States' Airlines in the United States., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names and the abbreviations for the United States' Airlines in the United States., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select airlines.Airline, airlines.Abbreviation",
        "real_label": "select airlines.Airline, airlines.Abbreviation",
        "topk_preds": [
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.uid, airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation, airlines.Country",
            "select t0, airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation,",
            "select airlines.Airline, airlines.Abbreviation2",
            "select airlines.Airline, airlines.uid2",
            "select airlines.Airline, airlines.Abbreviation"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names and the abbreviations for the United States' Airlines in the United States., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all airline names in United States and their abbreviations., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all airline names in United States and their abbreviations., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select airlines.Airline, airlines.Abbreviation",
        "real_label": "select airlines.Airline, airlines.Abbreviation",
        "topk_preds": [
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation2",
            "select airlines.Airline, airlines.Abbreviation,",
            "select airlines.Airline, airlines.uid2",
            "select airlines.Airline, t0.c 2",
            "select airlines.Airline, airlines.Abbreviation-",
            "select airlines.Airline, airlines.Abbreviation)",
            "select airlines.Airline, airlines.Abbreviation0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all airline names in United States and their abbreviations., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all airline names and their abbreviations in the United States of America., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (American), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all airline names and their abbreviations in the United States of America., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (American), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select airlines.Airline, airlines.Abbreviation",
        "real_label": "select airlines.Airline, airlines.Abbreviation",
        "topk_preds": [
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation2",
            "select airlines.Airline, airlines.uid2",
            "select airlines.Airline, airlines.Abbreviation,",
            "select airlines.Airline, airlines.Abbreviation0",
            "select airlines.Airline, airlines.Abbreviation-",
            "select airlines.Airline, airlines.Abbreviation)",
            "select airlines.Airline, airlines.Abbreviation."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all airline names and their abbreviations in the United States of America., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (American), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the airline name abbreviation for airlines from United States., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNITED-SECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the airline name abbreviation for airlines from United States., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": false,
        "real_pred": "select airlines.Abbreviation",
        "real_label": "select airlines.Airline, airlines.Abbreviation",
        "topk_preds": [
            "select airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline",
            "select airlines.uid, airlines.Abbreviation",
            "select airlines.Airline-, airlines.Abbreviation",
            "select airlines.Abbreviation, airlines.Country",
            "select airlines.uid, airlines.Airline",
            "select airlines.Abbreviation, airlines.Airline"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the airline name abbreviation for airlines from United States., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For the United States airline names and abbreviations., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For the United States airline names and abbreviations., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select airlines.Airline, airlines.Abbreviation",
        "real_label": "select airlines.Airline, airlines.Abbreviation",
        "topk_preds": [
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.uid, airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation, airlines.Country",
            "select distinct airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation,",
            "select airlines.Airline, airlines.Abbreviation2",
            "select t0.c 1, airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For the United States airline names and abbreviations., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show an airline abbreviations for airlines in the US., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev (US)). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ON-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ON-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show an airline abbreviations for airlines in the US., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev (US)). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": false,
        "real_pred": "select airlines.Abbreviation",
        "real_label": "select airlines.Airline, airlines.Abbreviation",
        "topk_preds": [
            "select airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Abbreviation, airlines.Country",
            "select airlines.Country, airlines.Abbreviation",
            "select airlines.uid, airlines.Abbreviation",
            "select airlines.Abbreviation (flying-in-the-US)",
            "select airlines.Abbreviation, airlines.Airline",
            "select airlines.Abbreviation (or airlines.Airline)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show an airline abbreviations for airlines in the US., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev (US)). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the airline names and abbreviations for airlines in the United States., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the airline names and abbreviations for airlines in the United States., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select airlines.Airline, airlines.Abbreviation",
        "real_label": "select airlines.Airline, airlines.Abbreviation",
        "topk_preds": [
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.uid, airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation, airlines.Country",
            "select airlines.Airline, airlines.Abbreviation,",
            "select airlines.Airline, airlines.Abbreviation2",
            "select airlines.Airline, airlines.uid2",
            "select airlines.Airline, airlines.Abbreviation)",
            "select airlines.Airline, t0.c 2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the airline names and abbreviations for airlines in the United States., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the different airline companies and abbreviations in the United States?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the different airline companies and abbreviations in the United States?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select distinct t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": false,
        "real_pred": "select distinct airlines.Airline, airlines.Abbreviation",
        "real_label": "select airlines.Airline, airlines.Abbreviation",
        "topk_preds": [
            "select distinct airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation",
            "select different airlines.Airline, airlines.Abbreviation",
            "select count(distinct airlines.Airline), airlines.Abbreviation",
            "select unique airlines.Airline, airlines.Abbreviation",
            "select distinct airlines.Airline, airlines.Abbreviation, airlines.Country",
            "select separate airlines.Airline, airlines.Abbreviation",
            "select distinct airlines.Airline, airlines.Abbreviation"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the different airline companies and abbreviations in the United States?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the list of the airlines and their abbreviations used in the United States., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the list of the airlines and their abbreviations used in the United States., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select airlines.Airline, airlines.Abbreviation",
        "real_label": "select airlines.Airline, airlines.Abbreviation",
        "topk_preds": [
            "select airlines.Airline, airlines.Abbreviation",
            "select distinct airlines.Airline, airlines.Abbreviation",
            "select airlines.uid, airlines.Abbreviation",
            "select airlines.Airline.c1, airlines.Abbreviation",
            "select list airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation,",
            "select t0.c 1, airlines.Abbreviation"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the list of the airlines and their abbreviations used in the United States., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of American airlines., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (American Airlines), c2: abbreviation (American), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of American airlines., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (American Airlines), c2: abbreviation (American), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Airline",
            "select count(*), airlines.Airline, airlines.Abbreviation",
            "select count(*) dependant on airlines.Airline",
            "select count(*), airlines.Airline, airlines.Abbreviation",
            "select count(*), abbreviation(airlines.Airline)",
            "select count(*), airlines.Airline, airlines.Country",
            "select count(*), airlines.Airline - airlines.Abbreviation"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of American airlines., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (American Airlines), c2: abbreviation (American), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of airline companies from United States of America., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (American), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE count(*)",
            "SELECT-FROM-WHERE-COUNT(*)",
            "SELECT-FROM-WHERE "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of airline companies from United States of America., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (American), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Country",
            "select count(*), airlines.Abbreviation",
            "select count(*), airlines.Airline",
            "select count(distinct airlines.Airline)",
            "select count(*), airlines.Country",
            "select count(*), airlines.uid3",
            "select count(*) the airlines.Airline"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of airline companies from United States of America., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (American), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the number of airlines originating in the United States of America., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (American), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-FROM-WHERE",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-COUNT(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the number of airlines originating in the United States of America., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (American), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Country",
            "select count(*), airlines.Abbreviation",
            "select count(*), airlines.Airline",
            "select count(distinct airlines.Airline)",
            "select count(*), airlines.uid",
            "select count(*) airlines.Airline",
            "select count(*), airlines.uid3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the number of airlines originating in the United States of America., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (American), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return how many airlines there are in the US., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev (US)). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-NUM(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return how many airlines there are in the US., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev (US)). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Country",
            "select count(*), airlines.Country, airports.CountryAbbrev",
            "select count(*), airlines.Airline",
            "select count(*), airlines.Country, airlines.Abbreviation",
            "select count(*) dependant on airlines.Airline",
            "select count(*) delegated, airlines.Country",
            "select count(*), airlines.Country, t0.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return how many airlines there are in the US., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev (US)). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "airlines airports",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show how many airlines there is in the US., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev (US)). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY -LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show how many airlines there is in the US., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev (US)). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Country",
            "select count(*), airlines.Airline",
            "select count(*), airlines.Country",
            "select count(*), airlines.Abbreviation",
            "select count(*) in airlines.Airline",
            "select count(*), airlines.uid",
            "select count(*) the airlines.Airline"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show how many airlines there is in the US., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev (US)). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "airlines airports",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the number of airlines in the United States., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the number of airlines in the United States., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Country",
            "select count(*) dependant on airlines.Airline",
            "select count(*) dependant on airlines.Country",
            "select count(*), airlines.Airline",
            "select count(*) delegated airlines.Airline",
            "select count(*), airlines.Abbreviation",
            "select count(*) the airlines.Airline"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the number of airlines in the United States., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country (United States), c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return how many times were there flights into Atlanta Airport., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE.GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return how many times were there flights into Atlanta Airport., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airports.AirportName",
            "select count(*), airports.AirportName, airports.City",
            "select count(*), airports.City",
            "select count(*), airports.AirportName, airports.AirportCode",
            "select count(*), airports.AirportName, airports.Country",
            "select count(*) dependant on airports.City, airports.AirportName",
            "select count(*), airports.AirportName, flights.SourceAirport"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return how many times were there flights into Atlanta Airport., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t2",
        "score": false,
        "real_pred": "airports flights",
        "real_label": "flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many flights went in to Atlanta?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY -LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many flights went in to Atlanta?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airports.AirportName",
            "select count(*), airports.City",
            "select count(*) descended on airports.AirportName",
            "select count(*) descended from airports.AirportName",
            "select count(flights.FlightNo)",
            "select count(*), airports.City2",
            "select count(*) descended to airports.AirportName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many flights went in to Atlanta?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t2",
        "score": false,
        "real_pred": "airports flights",
        "real_label": "flights",
        "topk_preds": [
            "airports flights",
            "airlines airports flights",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of flights that have entered Atlanta., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of flights that have entered Atlanta., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airports.AirportName",
            "select count(*), airports.City",
            "select count(*), airports.AirportName",
            "select count(*), airports.City2",
            "select count(*), airports.AirportCode",
            "select count(*) descended on airports.AirportName",
            "select flights.SourceAirport, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of flights that have entered Atlanta., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t2",
        "score": false,
        "real_pred": "airports flights",
        "real_label": "flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me how many flights Jetblue has., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE/GROUP BY",
            "SELECT-FROM-WHERE/GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me how many flights Jetblue has., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Abbreviation",
            "select count(*), airlines.Airline",
            "select count(*) dependant on airlines.Airline",
            "select count(*), airlines.Abbreviation",
            "select count(*) dependant on airlines.Abbreviation",
            "select count(*), airlines.uid",
            "select count(*), airlines.Airline"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me how many flights Jetblue has., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "airlines airports flights",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many flights does airline JetBlue has?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE/GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many flights does airline JetBlue has?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Airline",
            "select count(*), airlines.Abbreviation",
            "select count(*), airlines.Airline, flights.Airline",
            "select count(*), airlines.Airline, flights.FlightNo",
            "select count(*), airlines.Airline, flights.Airline",
            "select count(*), airlines.Airline, flights.FlightNo",
            "select count(*) dependant on airlines.Airline"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many flights does airline JetBlue has?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the count of the jet blue airways flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-WHERE.GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY -ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the count of the jet blue airways flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Airline",
            "select count(*), airlines.Abbreviation",
            "select count(*), airlines.Airline, airlines.Country",
            "select count(*), airlines.Airline, airlines.Abbreviation",
            "select count(*), airlines.Airline, flights.SourceAirport",
            "select flights.Airline, count(*)",
            "select count(*), airlines.Airline, airlines.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the count of the jet blue airways flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "airlines airports flights",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Provide the number of Jet blue flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Provide the number of Jet blue flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Airline",
            "select count(distinct flights.FlightNo)",
            "select count(*), flights.Airline",
            "select count(*), airlines.Abbreviation",
            "select count(*), flights.FlightNo",
            "select count(distinct flights.Airline)",
            "select count(*), airports.AirportName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Provide the number of Jet blue flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "airlines airports flights",
            "airports flights",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Count the number of planes of Air United flying in ASY airport., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (ASY), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (ASY), c3: destairport (ASY)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Count the number of planes of Air United flying in ASY airport., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (ASY), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (ASY), c3: destairport (ASY)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airports.AirportCode",
            "select count(*), airlines.Airline",
            "select count(*), airports.AirportCode, airlines.Abbreviation",
            "select count(*), t1, flights.SourceAirport",
            "select count(*), flights.SourceAirport",
            "select count(*), airlines.Airline, airports.AirportCode",
            "select count(*), airlines.Airline, airports.AirportCode"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Count the number of planes of Air United flying in ASY airport., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (ASY), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (ASY), c3: destairport (ASY)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t1 t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "airlines airports flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the number of United flights arriving in ASY airport., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (ASY), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (ASY), c3: destairport (ASY)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE PER-GROUP BY",
            "SELECT-FROM-WHERE/GROUP BY",
            "SELECT-FROM-WHERE PER-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the number of United flights arriving in ASY airport., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (ASY), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (ASY), c3: destairport (ASY)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Airline",
            "select count(*), flights.Airline",
            "select count(*), flights.SourceAirport",
            "select flights.Airline, count(*)",
            "select count(*), airports.AirportCode",
            "select count(distinct flights.FlightNo)",
            "select count(*), flights.FlightNo"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the number of United flights arriving in ASY airport., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (ASY), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (ASY), c3: destairport (ASY)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t1 t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "airlines airports flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines airports flights",
            "flights",
            "airlines flights",
            "airports flights",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the total count of United flights departing from airport AHD., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE.GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE/GROUP BY",
            "SELECT-FROM-WHERE/GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the total count of United flights departing from airport AHD., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), flights.SourceAirport, flights.DestAirport",
            "select count(*), flights.SourceAirport",
            "select flights.Airline, count(*)",
            "select count(*), airlines.Airline",
            "select count(*), flights.Airline",
            "select t2.c count(*)",
            "select count(*), flights.DestAirport"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the total count of United flights departing from airport AHD., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "flights",
            "airlines airports flights",
            "airports flights",
            "airlines flights",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the number of UA-flights to Aberdeen., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-WHERE/GROUP BY",
            "SELECT-FROM-WHERE (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the number of UA-flights to Aberdeen., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airports.City",
            "select count(*), airports.City, flights.FlightNo",
            "select count(*), flights.Airline",
            "select count(*), airports.City, airports.AirportName",
            "select count(*), flights.FlightNo",
            "select count(*), airlines.Airline",
            "select count(*), flights.Airline, airports.City"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the number of UA-flights to Aberdeen., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t0 t1 t2",
        "score": false,
        "real_pred": "airports flights",
        "real_label": "airlines airports flights",
        "topk_preds": [
            "airports flights",
            "airlines airports flights",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: show the flights that United Airline goes to Aberdeen city., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: show the flights that United Airline goes to Aberdeen city., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t2.c1",
        "label": "select count(*)",
        "score": false,
        "real_pred": "select flights.FlightNo",
        "real_label": "select count(*)",
        "topk_preds": [
            "select flights.FlightNo",
            "select flights.Airline",
            "select flights.Airline, flights.FlightNo",
            "select flights.FlightNo, airlines.Airline",
            "select airlines.Airline, flights.FlightNo",
            "select flights.FlightNo, airlines.Country",
            "select flights.FlightNo, airlines.Airline",
            "select flights.FlightNo, airports.City"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: show the flights that United Airline goes to Aberdeen city., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "airlines airports flights",
        "real_label": "airlines airports flights",
        "topk_preds": [
            "airlines airports flights",
            "airlines airports airports flights",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: show the number of United airplanes that get to Aberdeen., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-WHERE/GROUP BY",
            "SELECT-FROM-WHERE/GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: show the number of United airplanes that get to Aberdeen., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Airline",
            "select count(distinct flights.Airline)",
            "select count(*), airports.City",
            "select count(distinct flights.FlightNo)",
            "select count(*), flights.Airline",
            "select count(distinct airlines.uid)",
            "select flights.Airline, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: show the number of United airplanes that get to Aberdeen., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "airlines airports flights",
        "real_label": "airlines airports flights",
        "topk_preds": [
            "airlines airports flights",
            "",
            "airports flights",
            "",
            "",
            "airlines airports airports flights",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many United flights arrive in Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE.GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many United flights arrive in Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Airline",
            "select count(*), airports.City",
            "select count(*), flights.Airline",
            "select count(*), airlines.Airline, airports.AirportName",
            "select count(*), t1, flights.Airline",
            "select count(*), airlines.Airline, airports.City",
            "select count(*), t1, airlines.Airline"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many United flights arrive in Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "airlines airports flights",
        "real_label": "airlines airports flights",
        "topk_preds": [
            "airlines airports flights",
            "airports flights",
            "",
            "",
            "",
            "",
            "airlines airports airports flights",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all aircraft (United) that arrive in Aberdeen., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all aircraft (United) that arrive in Aberdeen., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t2.c0",
        "label": "select count(*)",
        "score": false,
        "real_pred": "select flights.Airline",
        "real_label": "select count(*)",
        "topk_preds": [
            "select flights.Airline",
            "select flights.FlightNo",
            "select flights.Airline, flights.FlightNo",
            "select flights.Airline, airports.AirportName",
            "select flights.FlightNo, airports.AirportName",
            "select flights.Airline, flights.DestAirport",
            "select flights.FlightNo, airports.City",
            "select flights.Airline"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all aircraft (United) that arrive in Aberdeen., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t0 t1 t2",
        "score": false,
        "real_pred": "airports flights",
        "real_label": "airlines airports flights",
        "topk_preds": [
            "airports flights",
            "airlines airports flights",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the number of airlines that have at least ten flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROMgROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the number of airlines that have at least ten flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select count(*)",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select count(*)",
            "select count(distinct flights.Airline)",
            "select count(*), flights.Airline",
            "select count(*), airlines.Airline",
            "select count(distinct airlines.Airline)",
            "select count(distinct flights.FlightNo)",
            "select count(distinct t2.c)",
            "select count(*),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the number of airlines that have at least ten flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "flights",
            "airlines flights",
            "airports flights",
            "airlines airports flights",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all airlines that have at least ten flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all airlines that have at least ten flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline, flights.FlightNo",
            "select airlines.Airline, flights.SourceAirport",
            "select airlines.Airline, t2",
            "select airlines.Airline, flights.DestAirport"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all airlines that have at least ten flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all the airlines that have at least ten flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all the airlines that have at least ten flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline, flights.FlightNo",
            "select airlines.Airline, flights.SourceAirport",
            "select flights.Airline, airlines.Airline",
            "select airlines.Airline, flights.DestAirport"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all the airlines that have at least ten flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the air carriers who have between zero and two hundred flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROMGROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the air carriers who have between zero and two hundred flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, flights.SourceAirport",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline, flights.FlightNo",
            "select airlines.Airline, flights.DestAirport",
            "select airlines.Airline, airlines.Abbreviation"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the air carriers who have between zero and two hundred flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the numbers of flights that land in Aberdeen or Abilene, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen, Abilene), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-OPT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the numbers of flights that land in Aberdeen or Abilene, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen, Abilene), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airports.City",
            "select count(*), airports.City-UNION-SELECT-FROM-WHERE",
            "select count(*), airports.City, flights.FlightNo",
            "select count(*), airports.City-Aberdeen, airports.City",
            "select count(*), airports.City-Aberdeen, airports.AirportName",
            "select count(*), airports.City, airports.AirportName",
            "select count(*) aeroports airports.City, flights.FlightNo"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the numbers of flights that land in Aberdeen or Abilene, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen, Abilene), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the locations where there is more than one city where an employee under the age of thirty comes from., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERES-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERECOUPING-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the locations where there is more than one city where an employee under the age of thirty comes from., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c3",
        "label": "select t0.c3",
        "score": true,
        "real_pred": "select employee.City",
        "real_label": "select employee.City",
        "topk_preds": [
            "select employee.City",
            "select employee.City, count(distinct employee.City)",
            "select employee.City, count(*)",
            "select employee.City, employee.Age",
            "select employee.City, count(distinct employee.Age)",
            "select employee.City, max(distinct employee.City)",
            "select employee.City, max(employee.City)",
            "select employee.City, t0.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the locations where there is more than one city where an employee under the age of thirty comes from., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "employee",
        "real_label": "employee",
        "topk_preds": [
            "employee",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all cities in which there are more than one employees under the age of thirty., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERES-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INSTALL-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all cities in which there are more than one employees under the age of thirty., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c3",
        "label": "select t0.c3",
        "score": true,
        "real_pred": "select employee.City",
        "real_label": "select employee.City",
        "topk_preds": [
            "select employee.City",
            "select employee.City the SELECT-FROM-WHERE-GROUP BY-HAVING",
            "select employee.City, count(*)",
            "select employee.City the SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "select employee.City the SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "select employee.City the SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "select employee.City the SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "select employee.City the SELECT-FROM-WHERE-GROUP BY-HAVING-INSTALL-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all cities in which there are more than one employees under the age of thirty., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "employee",
        "real_label": "employee",
        "topk_preds": [
            "employee",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all cities that have two or more employees under the age of thirty., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERES-GROUP BY-HAVING",
            "SELECT-FROM-WHEREGROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all cities that have two or more employees under the age of thirty., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c3",
        "label": "select t0.c3",
        "score": true,
        "real_pred": "select employee.City",
        "real_label": "select employee.City",
        "topk_preds": [
            "select employee.City",
            "select employee.City, count(*)",
            "select employee.City for employee.Age",
            "select employee.City as the employee.City",
            "select employee.City as employee.Age",
            "select t0, employee.City",
            "select employee.City (employee.Age)",
            "select employee.City as employee.City"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all cities that have two or more employees under the age of thirty., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "employee",
        "real_label": "employee",
        "topk_preds": [
            "employee",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which district in the dataset has both stores with less than 3,000 products and stores with more than 10,000 products?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE AND-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT-FROM\u2013WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which district in the dataset has both stores with less than 3,000 products and stores with more than 10,000 products?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select shop.District",
        "real_label": "select shop.District",
        "topk_preds": [
            "select shop.District",
            "select shop.District, shop.Number_products",
            "select shop.District, shop.Location",
            "select shop.District,",
            "select shop.District.c3",
            "select shop.District del.icio.us",
            "select shop.District delhi",
            "select shop.District (shop.District)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which district in the dataset has both stores with less than 3,000 products and stores with more than 10,000 products?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: show the districts that have stores with less than 10 000 products and more than 100 000., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE.INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-intersect-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: show the districts that have stores with less than 10 000 products and more than 100 000., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select shop.District",
        "real_label": "select shop.District",
        "topk_preds": [
            "select shop.District",
            "select shop.District, shop.Number_products",
            "select shop.District, shop.Location",
            "select shop.District,",
            "select shop.District, shop.District",
            "select shop.District, shop.Manager_name",
            "select shop.District, t1.c6",
            "select distinct shop.District"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: show the districts that have stores with less than 10 000 products and more than 100 000., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the number of districts that have both stores with less than 3,000 products and stores with more than 10,000 products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-COUPLE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the number of districts that have both stores with less than 3,000 products and stores with more than 10,000 products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select count(distinct t1.c3)",
        "label": "select t1.c3",
        "score": false,
        "real_pred": "select count(distinct shop.District)",
        "real_label": "select shop.District",
        "topk_preds": [
            "select count(distinct shop.District)",
            "select count(*)",
            "select count(distinct shop.District),",
            "select count(distinct shop.Location)",
            "select count(distinct shop.Number_products)",
            "select count(distinct shop.District).",
            "select count(distinct t1).c3)",
            "select count(distinct shop.Manager_name)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the number of districts that have both stores with less than 3,000 products and stores with more than 10,000 products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the districts where there is both shops selling less than 3000 products and shops selling more than 10,000 products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM both-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM\u2013WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the districts where there is both shops selling less than 3000 products and shops selling more than 10,000 products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select shop.District",
        "real_label": "select shop.District",
        "topk_preds": [
            "select shop.District",
            "select shop.District, shop.Number_products",
            "select shop.District, shop.Location",
            "select shop.District Then shop.Number_products",
            "select shop.District, shop.Manager_name",
            "select shop.District, t1.c6",
            "select shop.District, shop.District",
            "select shop.District Then shop.Location"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the districts where there is both shops selling less than 3000 products and shops selling more than 10,000 products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the districts that have both shops selling less than 3,000 products and shops selling more than 10,000 products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE AND-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT-FROM-WHERE,-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the districts that have both shops selling less than 3,000 products and shops selling more than 10,000 products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select shop.District",
        "real_label": "select shop.District",
        "topk_preds": [
            "select shop.District",
            "select shop.District, shop.Number_products",
            "select shop.District Then-intersect shop.District",
            "select shop.District Then-intersect-shop.District",
            "select shop.District Then-intersect shop.Location",
            "select shop.District, shop.Location",
            "select shop.District Then-intersect-shop.Location",
            "select shop.District Then-intersect shop.Number_products"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the districts that have both shops selling less than 3,000 products and shops selling more than 10,000 products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all districts where there is both shops selling less than 3,000 products and shops selling more than 10000 products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT-FROM both-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2013WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all districts where there is both shops selling less than 3,000 products and shops selling more than 10000 products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select shop.District",
        "real_label": "select shop.District",
        "topk_preds": [
            "select shop.District",
            "select shop.District Then I'll see if there's a shop selling less than 3,000 products AND a shop selling more than 10000 products",
            "select shop.District Then I'll see if there's a shop selling less than 3,000 products, a shop selling more than 10000 products",
            "select shop.District Then I'll see if there's a shop selling less than 3,000 products and a shop selling more than 10000 products",
            "select shop.District Then I'll see if there's a shop selling less than 3,000 products as well as a shop selling more than 10000 products",
            "select shop.District Then I'll see if there's a shop selling less than 3,000 products, and a shop selling more than 10000 products",
            "select shop.District Then I'll see if there's a shop selling less than 3,000 products or a shop selling more than 10000 products",
            "select shop.District Then I'll see if there's a shop selling less than 3,000 products AND a shop selling more than 10,000 products"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all districts where there is both shops selling less than 3,000 products and shops selling more than 10000 products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Document ID, Template ID, and Document Description for the document named \"RobbinCV\", database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Robbin CV), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Document ID, Template ID, and Document Description for the document named \"RobbinCV\", database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Robbin CV), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c0, t2.c1, t2.c3",
        "label": "select t2.c0, t2.c1, t2.c3",
        "score": true,
        "real_pred": "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Description",
        "real_label": "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Description",
        "topk_preds": [
            "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Description.",
            "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Name",
            "select Documents.Document_ID-, Documents.Template_ID, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Description,",
            "select Documents.Document_ID, Documents.Template_ID & Documents.Document_Description",
            "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Description)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Document ID, Template ID, and Document Description for the document named \"RobbinCV\", database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Robbin CV), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Documents",
        "real_label": "Documents",
        "topk_preds": [
            "Documents",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of documents that use the PowerPoint template., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE.GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of documents that use the PowerPoint template., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Documents.Template_ID",
            "select count(*), Templates.Template_Details",
            "select count(*), Templates.Template_Type_Code",
            "select count(Documents.Document_ID)",
            "select count(*), Documents.Document_ID",
            "select count(*) dependant on Documents.Template_ID",
            "select count(*), Templates.Date_Effective_From"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of documents that use the PowerPoint template., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "Documents",
            "Ref_Template_Types Templates Documents",
            "",
            "",
            "Paragraphs Documents",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the version number and template type code for the template with version number later than five., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the version number and template type code for the template with version number later than five., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select Templates.Version_Number, Templates.Template_Type_Code",
        "real_label": "select Templates.Version_Number, Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Version_Number, Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Version_Number.c2, Templates.Version_Number",
            "select Templates.Template_ID, Templates.Template_Type_Code",
            "select Templates.Version_Number, Templates.Template_Type_Code, Templates.Template_ID",
            "select t1.c 1, Templates.Template_Type_Code",
            "select Documents.Template_ID, Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Version_Number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the version number and template type code for the template with version number later than five., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the version numbers and template type codes of templates with version greater than five., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the version numbers and template type codes of templates with version greater than five., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select Templates.Version_Number, Templates.Template_Type_Code",
        "real_label": "select Templates.Version_Number, Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Version_Number, Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Version_Number.c2, Templates.Version_Number",
            "select Templates.Template_ID, Templates.Template_Type_Code",
            "select Documents.Template_ID, Templates.Template_Type_Code",
            "select Templates.Version_Number, Templates.Template_Type_Code, Templates.Template_ID",
            "select t1.c 1, Templates.Template_Type_Code",
            "select Templates.Version_Number, Templates.Template_Type_Code, Templates.Template_Details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the version numbers and template type codes of templates with version greater than five., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the versions and template types of templates with version numbers higher than five., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (version t1.c1), SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the versions and template types of templates with version numbers higher than five., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select Templates.Version_Number, Templates.Template_Type_Code",
        "real_label": "select Templates.Version_Number, Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Version_Number",
            "select Templates.Template_Details, Templates.Template_Type_Code",
            "select version(Templates.Version_Number), Templates.Template_Type_Code",
            "select Templates.Date_Effective_To, Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Template_Type_Code",
            "select Templates.Date_Effective_From, Templates.Template_Type_Code",
            "select t1.c6, Templates.Template_Type_Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the versions and template types of templates with version numbers higher than five., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all templates where version number is greater than five and return the version number and the template type code., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all templates where version number is greater than five and return the version number and the template type code., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select Templates.Version_Number, Templates.Template_Type_Code",
        "real_label": "select Templates.Version_Number, Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Version_Number.c1, Templates.Template_Type_Code",
            "select Templates.Version_Number, Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Version_Number, Templates.Template_Type_Code, Templates.Template_ID",
            "select t1.c 1, Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Version_Number",
            "select Templates.Version_Number, Templates.Template_Type_Code, Templates.Template_Details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all templates where version number is greater than five and return the version number and the template type code., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the versions and template types of templates with a version number greater than five., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (version t1.c1), SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (version t1.c1), SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (version t1.c1), SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (version t1.c1), SELECT-FROM-WHERE (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the versions and template types of templates with a version number greater than five., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select Templates.Version_Number, Templates.Template_Type_Code",
        "real_label": "select Templates.Version_Number, Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Version_Number",
            "select Templates.Template_Details, Templates.Template_Type_Code",
            "select version(Templates.Version_Number), Templates.Template_Type_Code",
            "select Templates.Date_Effective_To, Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Template_Type_Code",
            "select Templates.Date_Effective_From, Templates.Template_Type_Code",
            "select Templates.Version_Number, Templates.Template_Type_Code."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the versions and template types of templates with a version number greater than five., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the version numbers and template type codes of templates that have a version number greater than five., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the version numbers and template type codes of templates that have a version number greater than five., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select Templates.Version_Number, Templates.Template_Type_Code",
        "real_label": "select Templates.Version_Number, Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Version_Number.c2, Templates.Version_Number",
            "select Templates.Template_ID, Templates.Template_Type_Code",
            "select Documents.Template_ID, Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Version_Number",
            "select t1.c 1, Templates.Template_Type_Code",
            "select Templates.Version_Number, Templates.Template_Type_Code,",
            "select version numbers, Templates.Template_Type_Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the version numbers and template type codes of templates that have a version number greater than five., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all versions and template type codes for any version number equal to or greater than five., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all versions and template type codes for any version number equal to or greater than five., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select Templates.Version_Number, Templates.Template_Type_Code",
        "real_label": "select Templates.Version_Number, Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Version_Number.c2, Templates.Version_Number",
            "select Templates.Template_ID, Templates.Template_Type_Code",
            "select t1.c 1, Templates.Template_Type_Code",
            "select t1.c versions, Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Version_Number",
            "select Documents.Template_ID, Templates.Template_Type_Code",
            "select Templates.Version_Number.c2, Templates.Version_Number.c1"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all versions and template type codes for any version number equal to or greater than five., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the codes of template types that have fewer than three templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-PROGRAM-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-PROGRAM-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the codes of template types that have fewer than three templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Template_Type_Code (or Templates.Date_Effective_From)",
            "select Templates.Template_Type_Code,",
            "select Templates.Template_Type_Code (http://Templates.Template_Type_Code)",
            "select Templates.Template_Type_Code, Templates.Version_Number",
            "select Templates.Template_Type_Code, Templates.Template_Details",
            "select Templates.Template_Type_Code, Templates.Date_Effective_To"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the codes of template types that have fewer than three templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the codes of template types that have fewer than three templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-PROGRAM-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-PROGRAM-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the codes of template types that have fewer than three templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Template_Type_Code (or Templates.Date_Effective_From)",
            "select Templates.Template_Type_Code, Templates.Version_Number",
            "select Templates.Template_Type_Code (3 Templates.Template_ID)",
            "select Templates.Template_Type_Code (http://Templates.Template_Type_Code)",
            "select Templates.Template_Type_Code,",
            "select Templates.Template_Type_Code, Templates.Template_Details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the codes of template types that have fewer than three templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all paragraph ids and texts for the document with the name 'Welcome to New York.', database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Welcome to NY), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all paragraph ids and texts for the document with the name 'Welcome to New York.', database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Welcome to NY), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c0, t3.c2",
        "label": "select t3.c0, t3.c2",
        "score": true,
        "real_pred": "select Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text",
        "real_label": "select Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text",
        "topk_preds": [
            "select Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text",
            "select Documents.Document_ID, Paragraphs.Paragraph_Text",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Templates.Template_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Paragraph_ID-, Paragraphs.Paragraph_Text",
            "select Paragraphs.Paragraph_Text, Paragraphs.Paragraph_ID",
            "select Paragraphs.Paragraph_ID, Documents.Document_Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all paragraph ids and texts for the document with the name 'Welcome to New York.', database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Welcome to NY), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "",
            "",
            "Ref_Template_Types Documents Paragraphs",
            "",
            "",
            "Templates Documents Paragraphs"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the id and text of each paragraph in the document titled \"Welcome to New York.\", database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Welcome to NY), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the id and text of each paragraph in the document titled \"Welcome to New York.\", database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Welcome to NY), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c0, t3.c2",
        "label": "select t3.c0, t3.c2",
        "score": true,
        "real_pred": "select Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text",
        "real_label": "select Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text",
        "topk_preds": [
            "select Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text",
            "select Documents.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Paragraphs.Paragraph_Text, Paragraphs.Paragraph_ID",
            "select Templates.Template_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text.",
            "select Paragraphs.Paragraph_ID, Documents.Document_Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the id and text of each paragraph in the document titled \"Welcome to New York.\", database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Welcome to NY), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which paragraphs (ids or texts) in the document named Welcome To New York?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Welcome to NY), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (Select t3.c0, t3.c2",
            "SELECT-FROM-WHERE (paragraph_ids / t3.c2)",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (Ids & t3.c2)",
            "SELECT-FROM-WHERE (paragraph_ids / t3.c2"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which paragraphs (ids or texts) in the document named Welcome To New York?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Welcome to NY), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c0, t3.c2",
        "label": "select t3.c0, t3.c2",
        "score": true,
        "real_pred": "select Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text",
        "real_label": "select Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text",
        "topk_preds": [
            "select Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text",
            "select Documents.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Paragraph_Text, Paragraphs.Paragraph_ID",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Templates.Template_ID, Paragraphs.Paragraph_Text",
            "select distinct Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Paragraph_ID-, Paragraphs.Paragraph_Text"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which paragraphs (ids or texts) in the document named Welcome To New York?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Welcome to NY), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "Ref_Template_Types Documents Paragraphs",
            "Templates Documents Paragraphs",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The ids and texts of paragraphs in the document titled \"Welcome to New York\"., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Welcome to NY), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The ids and texts of paragraphs in the document titled \"Welcome to New York\"., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Welcome to NY), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c0, t3.c2",
        "label": "select t3.c0, t3.c2",
        "score": true,
        "real_pred": "select Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text",
        "real_label": "select Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text",
        "topk_preds": [
            "select Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text",
            "select Documents.Document_ID, Paragraphs.Paragraph_Text",
            "select param_Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Templates.Template_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Paragraph_Text, Paragraphs.Paragraph_ID",
            "select t4.c0, Paragraphs.Paragraph_Text"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The ids and texts of paragraphs in the document titled \"Welcome to New York\"., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Welcome to NY), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the ids and texts of paragraphs in the document titled Welcome to New York., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Welcome to NY), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the ids and texts of paragraphs in the document titled Welcome to New York., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Welcome to NY), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c0, t3.c2",
        "label": "select t3.c0, t3.c2",
        "score": true,
        "real_pred": "select Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text",
        "real_label": "select Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text",
        "topk_preds": [
            "select Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text",
            "select Documents.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Documents.Document_ID, Documents.Document_Name",
            "select param_Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Paragraph_Text, Paragraphs.Paragraph_ID",
            "select Templates.Template_ID, Paragraphs.Paragraph_Text",
            "select t4.c0, Paragraphs.Paragraph_Text"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the ids and texts of paragraphs in the document titled Welcome to New York., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Welcome to NY), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the paragraphs of the customer review documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Customer reviews), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the paragraphs of the customer review documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Customer reviews), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c2",
        "label": "select t3.c2",
        "score": true,
        "real_pred": "select Paragraphs.Paragraph_Text",
        "real_label": "select Paragraphs.Paragraph_Text",
        "topk_preds": [
            "select Paragraphs.Paragraph_Text",
            "select Paragraphs.Paragraph_Text, Paragraphs.Other_Details",
            "select Paragraphs.Paragraph_Text, Documents.Document_Description",
            "select Paragraphs.Paragraph_Text, Paragraphs.Document_ID",
            "select Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Paragraph_Text, Paragraphs.Paragraph_ID",
            "select Paragraphs.Paragraph_Text, t3.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the paragraphs of the customer review documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Customer reviews), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "",
            "",
            "Ref_Template_Types Documents Paragraphs",
            "",
            "Templates Documents Paragraphs",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the text in the paragraphs for the document named customer review?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Customer reviews), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the text in the paragraphs for the document named customer review?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Customer reviews), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c2",
        "label": "select t3.c2",
        "score": true,
        "real_pred": "select Paragraphs.Paragraph_Text",
        "real_label": "select Paragraphs.Paragraph_Text",
        "topk_preds": [
            "select Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Paragraph_Text, Documents.Document_Description",
            "select Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Paragraph_Text, Paragraphs.Other_Details",
            "select Paragraphs.Paragraph_Text, Paragraphs.Document_ID",
            "select Paragraphs.Paragraph_Text, t3.c4",
            "select Paragraphs.Paragraph_Text, Documents.Other_Details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the text in the paragraphs for the document named customer review?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Customer reviews), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "Ref_Template_Types Documents Paragraphs",
            "",
            "Templates Documents Paragraphs",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Ids of documents that contain two or more paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GATHERING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GATHER-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Ids of documents that contain two or more paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Paragraphs.Document_ID",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Documents.Document_ID",
            "select Paragraphs.Document_ID, Documents.Document_Name",
            "select Paragraphs.Document_ID (paragraph_Paragraphs.Paragraph_ID)",
            "select Paragraphs.Document_ID (paragraph_Paragraphs.Document_ID)",
            "select Paragraphs.Document_ID, Documents.Document_ID",
            "select Paragraphs.Document_ID (Paragraphs.Paragraph_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Ids of documents that contain two or more paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "Documents Paragraphs",
            "Templates Paragraphs",
            "",
            "",
            "Templates Documents Paragraphs",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: show the ids of documents that have two or more paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GATHERING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: show the ids of documents that have two or more paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Paragraphs.Document_ID",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID (paragraph_Paragraphs.Paragraph_ID)",
            "select Documents.Document_ID",
            "select Paragraphs.Document_ID (Paragraphs.Paragraph_ID)",
            "select Paragraphs.Document_ID",
            "select Paragraphs.Document_ID, Documents.Document_Name",
            "select Paragraphs.Document_ID (paragraph_Paragraphs.Document_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: show the ids of documents that have two or more paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "Documents Paragraphs",
            "Templates Paragraphs",
            "",
            "Templates Documents Paragraphs",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Identify the document ids that have two or more paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Identify the document ids that have two or more paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Paragraphs.Document_ID",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID (Paragraphs.Paragraph_ID)",
            "select Paragraphs.Document_ID, Paragraphs.Other_Details",
            "select Paragraphs.Document_ID,",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_ID",
            "select Paragraphs.Document_ID del Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID, t3.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Identify the document ids that have two or more paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "Documents Paragraphs",
            "Templates Paragraphs",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List ids of documents that have two or multiples paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING/UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List ids of documents that have two or multiples paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Paragraphs.Document_ID",
            "select Documents.Document_ID",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID, Documents.Document_Name",
            "select Paragraphs.Document_ID, Documents.Document_ID",
            "select Paragraphs.Paragraph_ID",
            "select Paragraphs.Document_ID",
            "select Paragraphs.Document_ID (paragraph_Paragraphs.Document_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List ids of documents that have two or multiples paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "Documents Paragraphs",
            "Templates Paragraphs",
            "Templates Documents Paragraphs",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the ID of the documents that have two or more paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAGLE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the ID of the documents that have two or more paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Paragraphs.Document_ID",
            "select Documents.Document_ID",
            "select Paragraphs.Paragraph_ID",
            "select Paragraphs.Document_ID",
            "select t4.c1",
            "select Templates.Template_ID",
            "select t5.c1",
            "select Paragraphs.Document_ID,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the ID of the documents that have two or more paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "Documents Paragraphs",
            "Templates Paragraphs",
            "Templates Documents Paragraphs",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Identify the documents where there are two or fewer paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Identify the documents where there are two or fewer paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c2",
        "label": "select t3.c1",
        "score": false,
        "real_pred": "select Documents.Document_Name",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Documents.Document_Name",
            "select Documents.Document_Name, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Documents.Document_Name, Documents.Document_Description, Documents.Other_Details",
            "select Documents.Document_Name, Documents.Document_Description, Documents.Other_Details",
            "select Documents.Document_Name, Paragraphs.Document_ID",
            "select Documents.Document_Name ou Documents.Document_Description",
            "select Documents.Document_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Identify the documents where there are two or fewer paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t3",
        "score": false,
        "real_pred": "Documents Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "Templates Documents Paragraphs",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: show the names of teachers whose hometown is a place other than Little Lever., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: show the names of teachers whose hometown is a place other than Little Lever., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, teacher.Hometown, teacher.Teacher_ID",
            "select teacher.Name, teacher.Hometown, teacher.Age",
            "select teacher.Name, teacher.Hometown, t1.c4",
            "select teacher.Name, teacher.Age",
            "select teacher.Name - teacher.Hometown",
            "select teacher.Name (syntax teacher.Age)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: show the names of teachers whose hometown is a place other than Little Lever., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all names of instructors that fall within age range 32-33., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all names of instructors that fall within age range 32-33., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, teacher.Teacher_ID",
            "select teacher.Name - teacher.Age",
            "select teacher.Name, teacher.Age,",
            "select teacher.Name, t1.c6",
            "select teacher.Name & teacher.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all names of instructors that fall within age range 32-33., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "teacher course_arrange",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of teachers who are aged between 32-33., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of teachers who are aged between 32-33., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, teacher.Teacher_ID",
            "select teacher.Name, t1.c6",
            "select teacher.Name - teacher.Age",
            "select teacher.Name, teacher.Age,",
            "select teacher.Name, t1.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of teachers who are aged between 32-33., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The names of persons who teach mathematics., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The names of persons who teach mathematics., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select distinct teacher.Name",
            "select unique teacher.Name",
            "select specific teacher.Name",
            "select special teacher.Name",
            "select distinctive teacher.Name",
            "select mathematical teacher.Name",
            "select math.c1"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The names of persons who teach mathematics., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t0 t1 t2",
        "score": false,
        "real_pred": "teacher",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "teacher",
            "teacher course_arrange",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name some teachers of mathematics., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name some teachers of mathematics., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select distinct teacher.Name",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, teacher.Hometown",
            "select distinct teacher.Name, teacher.Age",
            "select teacher.Name, teacher.Teacher_ID",
            "select distinct teacher.Name, teacher.Hometown",
            "select sub-clause teacher.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name some teachers of mathematics., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t0 t1 t2",
        "score": false,
        "real_pred": "teacher",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "teacher",
            "teacher course_arrange",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The average age of the visitors whose membership level is four or lower., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The average age of the visitors whose membership level is four or lower., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select avg(t1.c3)",
        "label": "select avg(t1.c3)",
        "score": true,
        "real_pred": "select avg(visitor.Age)",
        "real_label": "select avg(visitor.Age)",
        "topk_preds": [
            "select avg(visitor.Age)",
            "select an avg(visitor.Age)",
            "select  avg(visitor.Age)",
            "select the avg(visitor.Age)",
            "select Avg(visitor.Age)",
            "select avg(t1.c4)",
            "select avg(t1.c)",
            "select avg(visitor.Age)."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The average age of the visitors whose membership level is four or lower., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the average age of the visitors whose membership level is not higher than four., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the average age of the visitors whose membership level is not higher than four., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select avg(t1.c3)",
        "label": "select avg(t1.c3)",
        "score": true,
        "real_pred": "select avg(visitor.Age)",
        "real_label": "select avg(visitor.Age)",
        "topk_preds": [
            "select avg(visitor.Age)",
            "select an avg(visitor.Age)",
            "select  avg(visitor.Age)",
            "select the avg(visitor.Age)",
            "select avg(t1.c4)",
            "select avg(t1.c)",
            "select avg(visitor.Level_of_membership)",
            "select Avg(visitor.Age)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the average age of the visitors whose membership level is not higher than four., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the first names and birth date for players born in the US., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the first names and birth date for players born in the US., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c4",
        "label": "select t0.c1, t0.c4",
        "score": true,
        "real_pred": "select players.first_name, players.birth_date",
        "real_label": "select players.first_name, players.birth_date",
        "topk_preds": [
            "select players.first_name, players.birth_date",
            "select players.first_name, players.last_name, players.birth_date",
            "select players.first_name, players.last_name",
            "select distinct players.first_name, players.birth_date",
            "select players.first_name, players.hand, players.birth_date",
            "select players.first_name, players.hand",
            "select players.first_name, players.last_name and players.birth_date",
            "select players.first_name, players.last_name, players.hand"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the first names and birth date for players born in the US., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The names and birth dates of American players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The names and birth dates of American players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2, t0.c4",
        "label": "select t0.c1, t0.c4",
        "score": false,
        "real_pred": "select players.first_name, players.last_name, players.birth_date",
        "real_label": "select players.first_name, players.birth_date",
        "topk_preds": [
            "select players.first_name, players.last_name, players.birth_date",
            "select distinct players.first_name, players.last_name, players.birth_date",
            "select players.first_name, players.last_name, players.hand, players.birth_date",
            "select players.first_name.c1, players.last_name, players.birth_date",
            "select American players.first_name, players.last_name, players.birth_date",
            "select players.first_name, players.last_name, players.birth_date, players.country_code",
            "select players.first_name, players.last_name, players.birth_date, players.player_id",
            "select american_players.first_name, players.last_name, players.birth_date"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The names and birth dates of American players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the first name and birth date of players from the United States of America., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the first name and birth date of players from the United States of America., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c4",
        "label": "select t0.c1, t0.c4",
        "score": true,
        "real_pred": "select players.first_name, players.birth_date",
        "real_label": "select players.first_name, players.birth_date",
        "topk_preds": [
            "select players.first_name, players.birth_date",
            "select distinct players.first_name, players.birth_date",
            "select players.first_name, players.last_name, players.birth_date",
            "select players.first_name, players.last_name",
            "select players.first_name, players.birth_date, players.player_id",
            "select players.first_name, players.hand, players.birth_date",
            "select players.first_name, players.birth_date, players.country_code",
            "select players.first_name, players.hand"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the first name and birth date of players from the United States of America., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the name of tournament that has more than ten matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the name of tournament that has more than ten matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c20",
        "label": "select t1.c20",
        "score": true,
        "real_pred": "select matches.tourney_name",
        "real_label": "select matches.tourney_name",
        "topk_preds": [
            "select matches.tourney_name",
            "select matches.tourney_name, matches.tourney_date",
            "select matches.tourney_name, matches.winner_hand",
            "select matches.tourney_name, matches.winner_age",
            "select matches.tourney_name, matches.winner_entry",
            "select matches.tourney_name, matches.minutes",
            "select matches.tourney_name, matches.tourney_name",
            "select matches.tourney_name (matches.tourney_date)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the name of tournament that has more than ten matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the tournament name that has more than ten matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the tournament name that has more than ten matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c20",
        "label": "select t1.c20",
        "score": true,
        "real_pred": "select matches.tourney_name",
        "real_label": "select matches.tourney_name",
        "topk_preds": [
            "select matches.tourney_name",
            "select matches.tourney_name, matches.winner_hand",
            "select matches.tourney_name, matches.tourney_date",
            "select matches.tourney_name, matches.winner_age",
            "select matches.tourney_name, matches.minutes",
            "select matches.tourney_name, matches.winner_entry",
            "select matches.tourney_name, matches.tourney_name",
            "select matches.tourney_name, matches.loser_entry"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the tournament name that has more than ten matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the tournament whose number of matches is greater than ten., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the tournament whose number of matches is greater than ten., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c20",
        "label": "select t1.c20",
        "score": true,
        "real_pred": "select matches.tourney_name",
        "real_label": "select matches.tourney_name",
        "topk_preds": [
            "select matches.tourney_name",
            "select matches.tourney_name, matches.match_num",
            "select matches.tourney_name, matches.minutes",
            "select matches.tourney_name (https://matches.match_num",
            "select matches.tourney_name (matches.match_num)",
            "select matches.tourney_name,",
            "select matches.tourney_name (http://matches.match_num",
            "select matches.tourney_name, matches.tourney_date"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the tournament whose number of matches is greater than ten., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "matches rankings",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of Tournaments that have more tha ten matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of Tournaments that have more tha ten matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c20",
        "label": "select t1.c20",
        "score": true,
        "real_pred": "select matches.tourney_name",
        "real_label": "select matches.tourney_name",
        "topk_preds": [
            "select matches.tourney_name",
            "select matches.best_of, matches.tourney_name",
            "select matches.tourney_name, matches.winner_hand",
            "select matches.tourney_name, matches.tourney_date",
            "select matches.tourney_name, matches.winner_age",
            "select matches.best_of, matches.loser_age",
            "select matches.tourney_name, matches.minutes",
            "select matches.tourney_name, matches.tourney_level"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of Tournaments that have more tha ten matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the name of the tournaments that have more than ten matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the name of the tournaments that have more than ten matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c20",
        "label": "select t1.c20",
        "score": true,
        "real_pred": "select matches.tourney_name",
        "real_label": "select matches.tourney_name",
        "topk_preds": [
            "select matches.tourney_name",
            "select matches.tourney_name, matches.tourney_date",
            "select matches.tourney_name, matches.winner_hand",
            "select matches.tourney_name, matches.winner_age",
            "select matches.tourney_name, matches.winner_entry",
            "select matches.tourney_name (matches.tourney_date)",
            "select matches.tourney_name, matches.tourney_name",
            "select matches.tourney_name, matches.minutes"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the name of the tournaments that have more than ten matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of the tournaments that have more than ten matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of the tournaments that have more than ten matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c20",
        "label": "select t1.c20",
        "score": true,
        "real_pred": "select matches.tourney_name",
        "real_label": "select matches.tourney_name",
        "topk_preds": [
            "select matches.tourney_name",
            "select matches.tourney_name, matches.tourney_date",
            "select matches.tourney_name, matches.winner_hand",
            "select matches.tourney_name, matches.winner_age",
            "select matches.tourney_name, matches.winner_entry",
            "select matches.tourney_name, matches.minutes",
            "select matches.tourney_name, matches.tourney_level",
            "select matches.tourney_name (matches.tourney_date)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of the tournaments that have more than ten matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The first name or last name of all players who are left handed in the order of birthday., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Last), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-WHERE-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-WHERE-ORDER BY.",
            "SELECT-FROM-WHERE-ORDER BY t0.c1, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-ORDER BY t0.c1 / t0.c2",
            "SELECT-FROM-WHERE-ORDER BY "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The first name or last name of all players who are left handed in the order of birthday., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Last), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select players.first_name, players.last_name",
        "real_label": "select players.first_name, players.last_name",
        "topk_preds": [
            "select players.first_name, players.last_name",
            "select players.first_name, players.last_name, players.birth_date",
            "select players.first_name ou players.last_name",
            "select players.first_name, players.last_name, players.birth_date",
            "select distinct players.first_name, players.last_name",
            "select players.first_name.c1, players.last_name",
            "select players.first_name, players.last_name in players.birth_date",
            "select players.first_name, players.last_name dependant on players.birth_date"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The first name or last name of all players who are left handed in the order of birthday., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Last), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the list of the first and last name of all players who are left handed in the order of birth date., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Date, Last), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-WHERE-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-ORDER BY.",
            "SELECT-FROM-WHERE-ORDER BY ",
            "SELECT-FROM-WITH-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the list of the first and last name of all players who are left handed in the order of birth date., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Date, Last), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select players.first_name, players.last_name",
        "real_label": "select players.first_name, players.last_name",
        "topk_preds": [
            "select players.first_name, players.last_name",
            "select players.first_name, players.last_name, players.birth_date",
            "select players.first_name, players.last_name (Date, Last)",
            "select players.first_name, players.last_name, players.hand",
            "select players.first_name, players.last_name (DATE, LAST)",
            "select players.first_name, players.last_name in players.birth_date",
            "select players.first_name, players.last_name (Date, Last",
            "select players.first_name, players.last_name (\"Date, Last\")"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the list of the first and last name of all players who are left handed in the order of birth date., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Date, Last), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the first and last name of all players (Left-Handed) in their birth order., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Last), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-WHERE-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-WHERE-ORDER BY.",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-ORDER BY ",
            "SELECT-FROM-WS-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the first and last name of all players (Left-Handed) in their birth order., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Last), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select players.first_name, players.last_name",
        "real_label": "select players.first_name, players.last_name",
        "topk_preds": [
            "select players.first_name, players.last_name",
            "select players.first_name, players.last_name, players.birth_date",
            "select players.first_name, players.last_name in players.birth_date",
            "select players.first_name, players.last_name, players.hand",
            "select players.first_name, players.last_name, players.birth_date",
            "select players.first_name, players.last_name dans players.birth_date",
            "select players.first_name, players.last_name, players.hand",
            "select players.first_name, players.last_name, players.birth_date"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the first and last name of all players (Left-Handed) in their birth order., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Last), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the name of the code of the country with more than fifty players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the name of the code of the country with more than fifty players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c5",
        "label": "select t0.c5",
        "score": true,
        "real_pred": "select players.country_code",
        "real_label": "select players.country_code",
        "topk_preds": [
            "select players.country_code",
            "select players.country_code, t0.c6",
            "select players.country_code (symbol players.country_code)",
            "select players.country_code (symbol t0.c6)",
            "select players.country_code,",
            "select players.country_code, players.birth_date",
            "select players.country_code (select t0.c6)",
            "select players.country_code, players.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the name of the code of the country with more than fifty players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Display the name and ranking of the three youngest winners in across all games., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Display the name and ranking of the three youngest winners in across all games., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c27, t1.c28",
        "label": "select distinct t1.c27, t1.c28",
        "score": false,
        "real_pred": "select matches.winner_name, matches.winner_rank",
        "real_label": "select distinct matches.winner_name, matches.winner_rank",
        "topk_preds": [
            "select matches.winner_name, matches.winner_rank",
            "select matches.loser_ioc, matches.winner_rank",
            "select matches.loser_age, matches.winner_rank",
            "select matches.winner_ioc, matches.winner_rank",
            "select matches.winner_name, rankings.ranking",
            "select matches.winner_rank, matches.winner_name",
            "select matches.winner_name, matches.loser_age",
            "select t1.c 27, matches.winner_rank"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Display the name and ranking of the three youngest winners in across all games., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "matches rankings",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names and ranks of the three youngest winners across all matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names and ranks of the three youngest winners across all matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c27, t1.c28",
        "label": "select distinct t1.c27, t1.c28",
        "score": false,
        "real_pred": "select matches.winner_name, matches.winner_rank",
        "real_label": "select distinct matches.winner_name, matches.winner_rank",
        "topk_preds": [
            "select matches.winner_name, matches.winner_rank",
            "select matches.loser_ioc, matches.winner_rank",
            "select matches.loser_age, matches.winner_rank",
            "select matches.winner_rank, matches.winner_name",
            "select matches.winner_ioc, matches.winner_rank",
            "select t1.c 27, matches.winner_rank",
            "select matches.loser_ioc7, matches.winner_rank",
            "select rankings.player_id7, matches.winner_rank"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names and ranks of the three youngest winners across all matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the name and rank of the three youngest winners in all matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the name and rank of the three youngest winners in all matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c27, t1.c28",
        "label": "select distinct t1.c27, t1.c28",
        "score": false,
        "real_pred": "select matches.winner_name, matches.winner_rank",
        "real_label": "select distinct matches.winner_name, matches.winner_rank",
        "topk_preds": [
            "select matches.winner_name, matches.winner_rank",
            "select matches.loser_ioc, matches.winner_rank",
            "select matches.loser_age, matches.winner_rank",
            "select matches.winner_ioc, matches.winner_rank",
            "select matches.winner_rank, matches.winner_name",
            "select t1.c 27, matches.winner_rank",
            "select matches.loser_ioc7, matches.winner_rank",
            "select matches.winner_name, matches.loser_age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the name and rank of the three youngest winners in all matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the name and rank of the three youngest winners in each match., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the name and rank of the three youngest winners in each match., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c27, t1.c28",
        "label": "select distinct t1.c27, t1.c28",
        "score": false,
        "real_pred": "select matches.winner_name, matches.winner_rank",
        "real_label": "select distinct matches.winner_name, matches.winner_rank",
        "topk_preds": [
            "select matches.winner_name, matches.winner_rank",
            "select matches.winner_name, matches.winner_rank, matches.match_num",
            "select matches.winner_name, matches.winner_rank, matches.minutes",
            "select matches.winner_name, matches.winner_rank, matches.loser_id",
            "select matches.winner_name, matches.winner_rank, min(matches.loser_age)",
            "select matches.winner_name, matches.winner_rank per matches.match_num",
            "select matches.loser_ioc, matches.winner_rank",
            "select matches.winner_name, matches.winner_rank, matches.loser_entry"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the name and rank of the three youngest winners in each match., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of left-handed WTA Championship winners., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of left-handed WTA Championship winners., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select count(*)",
        "label": "select count(distinct t1.c27)",
        "score": false,
        "real_pred": "select count(*)",
        "real_label": "select count(distinct matches.winner_name)",
        "topk_preds": [
            "select count(*)",
            "select count(*), matches.winner_hand",
            "select count(*), matches.winner_entry",
            "select count(*), matches.tourney_name",
            "select count(distinct matches.loser_age)",
            "select count(*), matches.winner_age",
            "select count(*), players.hand",
            "select count(distinct matches.winner_hand)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of left-handed WTA Championship winners., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t1",
        "score": false,
        "real_pred": "players matches",
        "real_label": "matches",
        "topk_preds": [
            "players matches",
            "players matches rankings",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Shows the ids and names of battles that lead to more than ten people dead in total., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY over-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Shows the ids and names of battles that lead to more than ten people dead in total., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select t0.c0, t0.c1",
        "label": "select t0.c0, t0.c1",
        "score": true,
        "real_pred": "select battle.id, battle.name",
        "real_label": "select battle.id, battle.name",
        "topk_preds": [
            "select battle.id, battle.name",
            "select battle.name, battle.id",
            "select battle.date, battle.name",
            "select death.id, battle.name",
            "select t0.c, battle.name",
            "select ship.lost_in_battle, battle.name",
            "select t0-c0, battle.name",
            "select t.c0, battle.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Shows the ids and names of battles that lead to more than ten people dead in total., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t1 t2",
        "score": false,
        "real_pred": "battle death",
        "real_label": "battle ship death",
        "topk_preds": [
            "battle death",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: This course describes the mathematics., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c1:",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: This course describes the mathematics., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id,",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Courses.course_description",
        "real_label": "select Courses.course_description",
        "topk_preds": [
            "select Courses.course_description",
            "select Courses.course_name, Courses.course_description",
            "select Courses.course_name",
            "select Courses.course_id, Courses.course_description",
            "select Courses.course_description, Courses.course_name",
            "select Courses.course_name-, Courses.course_description",
            "select Courses.course_description, Courses.other_details",
            "select Courses.course_id, Courses.course_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: This course describes the mathematics., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c1: degree",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Courses",
        "real_label": "Courses",
        "topk_preds": [
            "Courses",
            "Courses Student_Enrolment_Courses",
            "Courses Transcript_Contents",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Display all the classifications for all mathematical classes., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id,",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Display all the classifications for all mathematical classes., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "select distinct t9.c2",
        "label": "select t1.c2",
        "score": false,
        "real_pred": "select distinct Transcripts.other_details",
        "real_label": "select Courses.course_description",
        "topk_preds": [
            "select distinct Transcripts.other_details",
            "select distinct t10.c2",
            "select distinct Student_Enrolment_Courses.student_enrolment_id",
            "select distinct Student_Enrolment_Courses.course_id, Student_Enrolment_Courses.student_enrolment_id",
            "select distinct Student_Enrolment_Courses.course_id",
            "select distinct t11.c2",
            "select distinct Transcripts.transcript_date, Transcripts.other_details",
            "select Student_Enrolment_Courses.course_id, Student_Enrolment_Courses.student_enrolment_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Display all the classifications for all mathematical classes., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, ",
        "prediction": "t8",
        "label": "t1",
        "score": false,
        "real_pred": "Student_Enrolment_Courses",
        "real_label": "Courses",
        "topk_preds": [
            "Student_Enrolment_Courses",
            "Transcript_Contents",
            "Transcripts",
            "Courses Student_Enrolment_Courses",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the ZIP for PortChelsea., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id,",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the ZIP for PortChelsea., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "select t0.c5",
        "label": "select t0.c5",
        "score": true,
        "real_pred": "select Addresses.zip_postcode",
        "real_label": "select Addresses.zip_postcode",
        "topk_preds": [
            "select Addresses.zip_postcode",
            "select Addresses.zip_postcode, Addresses.city",
            "select Addresses.zip_postcode, Addresses.state_province_county",
            "select Addresses.zip_postcode, Addresses.country",
            "select Addresses.zip_postcode.c5",
            "select Addresses.zip_postcode (or Addresses.state_province_county)",
            "select Addresses.zip_postcode, Addresses.other_address_details",
            "select Addresses.zip_postcode - Addresses.city"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the ZIP for PortChelsea., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, ",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Addresses",
        "real_label": "Addresses",
        "topk_preds": [
            "Addresses",
            "",
            "",
            "Addresses Transcripts",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names and ids of courses with at most two sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING In-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING IMPORT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names and ids of courses with at most two sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0",
        "prediction": "select t1.c1, t4.c1",
        "label": "select t1.c1, t1.c0",
        "score": false,
        "real_pred": "select Courses.course_name, Sections.course_id",
        "real_label": "select Courses.course_name, Courses.course_id",
        "topk_preds": [
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Sections.section_id",
            "select Courses.course_name, Courses.course_id",
            "select Courses.course_name, Departments.department_id",
            "select Sections.course_id, Sections.section_id",
            "select Courses.course_name, Sections.section_name",
            "select Courses.course_name, Sections.other_details",
            "select Courses.course_name, Degree_Programs.degree_program_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names and ids of courses with at most two sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "t1 t4",
        "label": "t1 t4",
        "score": true,
        "real_pred": "Courses Sections",
        "real_label": "Courses Sections",
        "topk_preds": [
            "Courses Sections",
            "",
            "",
            "",
            "Courses Departments Sections",
            "",
            "",
            "Courses Degree_Programs Sections"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names and ID of courses with at most two sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING In-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING In-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names and ID of courses with at most two sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "select t1.c1, t4.c1",
        "label": "select t1.c1, t1.c0",
        "score": false,
        "real_pred": "select Courses.course_name, Sections.course_id",
        "real_label": "select Courses.course_name, Courses.course_id",
        "topk_preds": [
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Sections.section_id",
            "select Courses.course_name, Courses.course_id",
            "select Courses.course_name, Departments.department_id",
            "select Sections.course_id, Sections.section_id",
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Degree_Programs.degree_program_id",
            "select Courses.course_name, Sections.course_id,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names and ID of courses with at most two sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_i",
        "prediction": "t1 t4",
        "label": "t1 t4",
        "score": true,
        "real_pred": "Courses Sections",
        "real_label": "Courses Sections",
        "topk_preds": [
            "Courses Sections",
            "",
            "",
            "",
            "Courses Departments Sections",
            "",
            "Courses Degree_Programs Sections",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of courses with no more than two sections and return their IDs, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-IN-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of courses with no more than two sections and return their IDs, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0",
        "prediction": "select t1.c1, t4.c1",
        "label": "select t1.c1, t1.c0",
        "score": false,
        "real_pred": "select Courses.course_name, Sections.course_id",
        "real_label": "select Courses.course_name, Courses.course_id",
        "topk_preds": [
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Sections.section_id",
            "select Courses.course_name, Departments.department_id",
            "select Courses.course_name, Courses.course_id",
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Degree_Programs.degree_program_id",
            "select Sections.course_id, Courses.course_name",
            "select Courses.course_name, Sections.course_id,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of courses with no more than two sections and return their IDs, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "t1 t4",
        "label": "t1 t4",
        "score": true,
        "real_pred": "Courses Sections",
        "real_label": "Courses Sections",
        "topk_preds": [
            "Courses Sections",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the name and id of courses in which there are two or less sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the name and id of courses in which there are two or less sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(",
        "prediction": "select t1.c1, t4.c1",
        "label": "select t1.c1, t1.c0",
        "score": false,
        "real_pred": "select Courses.course_name, Sections.course_id",
        "real_label": "select Courses.course_name, Courses.course_id",
        "topk_preds": [
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Sections.section_id",
            "select Courses.course_name, Courses.course_id",
            "select Courses.course_name, Departments.department_id",
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Degree_Programs.degree_program_id",
            "select Sections.course_id, Courses.course_description",
            "select Courses.course_name, Sections.course_id,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the name and id of courses in which there are two or less sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "t1 t4",
        "label": "t1 t4",
        "score": true,
        "real_pred": "Courses Sections",
        "real_label": "Courses Sections",
        "topk_preds": [
            "Courses Sections",
            "",
            "",
            "",
            "",
            "",
            "Courses Departments Sections",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names and ID for the courses with at most two sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names and ID for the courses with at most two sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "select t1.c1, t4.c1",
        "label": "select t1.c1, t1.c0",
        "score": false,
        "real_pred": "select Courses.course_name, Sections.course_id",
        "real_label": "select Courses.course_name, Courses.course_id",
        "topk_preds": [
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Sections.section_id",
            "select Courses.course_name, Courses.course_id",
            "select Courses.course_name, Departments.department_id",
            "select Courses.course_name, Sections.course_id",
            "select Sections.course_id, Courses.course_description",
            "select Courses.course_name, Degree_Programs.degree_program_id",
            "select Courses.course_name, Sections.course_id,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names and ID for the courses with at most two sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "t1 t4",
        "label": "t1 t4",
        "score": true,
        "real_pred": "Courses Sections",
        "real_label": "Courses Sections",
        "topk_preds": [
            "Courses Sections",
            "",
            "",
            "Courses Departments Sections",
            "",
            "",
            "",
            "Courses Degree_Programs Sections"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of each course with less than two sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_i",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of each course with less than two sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "select t1.c1",
        "label": "select t1.c1, t1.c0",
        "score": false,
        "real_pred": "select Courses.course_name",
        "real_label": "select Courses.course_name, Courses.course_id",
        "topk_preds": [
            "select Courses.course_name",
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Sections.course_id, Sections.section_name",
            "select Courses.course_name, Sections.section_name",
            "select Courses.course_name, Sections.course_id - Sections.section_name",
            "select Courses.course_name, Sections.course_id, Sections.section_description",
            "select Courses.course_name, Sections.section_id",
            "select Courses.course_name, Sections.course_id, Courses.course_description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of each course with less than two sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id",
        "prediction": "t1 t4",
        "label": "t1 t4",
        "score": true,
        "real_pred": "Courses Sections",
        "real_label": "Courses Sections",
        "topk_preds": [
            "Courses Sections",
            "",
            "",
            "Courses Departments Sections",
            "",
            "",
            "",
            "Courses Degree_Programs Sections"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Names and IDs of all courses with less than two sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Names and IDs of all courses with less than two sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "select t1.c1, t4.c1",
        "label": "select t1.c1, t1.c0",
        "score": false,
        "real_pred": "select Courses.course_name, Sections.course_id",
        "real_label": "select Courses.course_name, Courses.course_id",
        "topk_preds": [
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Sections.section_id",
            "select Courses.course_name, Courses.course_id",
            "select Courses.course_name, Departments.department_id",
            "select Sections.course_id, Sections.section_id",
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Degree_Programs.degree_program_id",
            "select Courses.course_name, Sections.section_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Names and IDs of all courses with less than two sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "t1 t4",
        "label": "t1 t4",
        "score": true,
        "real_pred": "Courses Sections",
        "real_label": "Courses Sections",
        "topk_preds": [
            "Courses Sections",
            "",
            "Courses Departments Sections",
            "",
            "",
            "",
            "Courses Degree_Programs Sections",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of every course where there is fewer than two section., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of every course where there is fewer than two section., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "select t1.c1",
        "label": "select t1.c1, t1.c0",
        "score": false,
        "real_pred": "select Courses.course_name",
        "real_label": "select Courses.course_name, Courses.course_id",
        "topk_preds": [
            "select Courses.course_name",
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Sections.section_name",
            "select Courses.course_name, Sections.course_id, Sections.section_name",
            "select Courses.course_name, Sections.course_id, Sections.section_description",
            "select Courses.course_name, Sections.course_id - Sections.section_name",
            "select Courses.course_name, Sections.section_id",
            "select Courses.course_name, Sections.section_description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of every course where there is fewer than two section., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "t1 t4",
        "label": "t1 t4",
        "score": true,
        "real_pred": "Courses Sections",
        "real_label": "Courses Sections",
        "topk_preds": [
            "Courses Sections",
            "Courses Departments Sections",
            "Courses Degree_Programs Sections",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names and IDs of all courses with less then two sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names and IDs of all courses with less then two sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "select t1.c1, t4.c1",
        "label": "select t1.c1, t1.c0",
        "score": false,
        "real_pred": "select Courses.course_name, Sections.course_id",
        "real_label": "select Courses.course_name, Courses.course_id",
        "topk_preds": [
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Sections.section_id",
            "select Courses.course_name, Courses.course_id",
            "select Courses.course_name, Departments.department_id",
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Degree_Programs.degree_program_id",
            "select Sections.course_id, Courses.course_description",
            "select Courses.course_name, Sections.course_id,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names and IDs of all courses with less then two sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "t1 t4",
        "label": "t1 t4",
        "score": true,
        "real_pred": "Courses Sections",
        "real_label": "Courses Sections",
        "topk_preds": [
            "Courses Sections",
            "",
            "Courses Departments Sections",
            "",
            "",
            "",
            "",
            "Courses Degree_Programs Sections"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all students with two degrees in one semester and list their names, first name, middle name and last name and the id., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7:",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all students with two degrees in one semester and list their names, first name, middle name and last name and the id., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details).",
        "prediction": "select t6.c3, t6.c4, t6.c5, t6.c0",
        "label": "select t6.c3, t6.c4, t6.c5, t6.c0",
        "score": true,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
        "real_label": "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.student_id, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name and Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
            "select Students.current_address_id, Students.middle_name, Students.last_name, Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name., Students.student_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all students with two degrees in one semester and list their names, first name, middle name and last name and the id., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Students Student_Enrolment",
        "real_label": "Students Student_Enrolment",
        "topk_preds": [
            "Students Student_Enrolment",
            "Semesters Students Student_Enrolment",
            "Degree_Programs Students Student_Enrolment",
            "Sections Students Student_Enrolment",
            "Departments Degree_Programs Students Student_Enrolment",
            "Departments Students Student_Enrolment",
            "Courses Students Student_Enrolment",
            "Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which students were enrolled in two degrees courses in the same semester (first name, middle name, last name and ID)., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_en",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-COURSE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-T7-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which students were enrolled in two degrees courses in the same semester (first name, middle name, last name and ID)., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7",
        "prediction": "select t6.c3, t6.c4, t6.c5, t6.c0",
        "label": "select t6.c3, t6.c4, t6.c5, t6.c0",
        "score": true,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
        "real_label": "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name and Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
            "select Students.first_name, Students.middle_name., Students.last_name, Students.student_id",
            "select Students.student_id, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name, Student_Enrolment.student_enrolment_id",
            "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which students were enrolled in two degrees courses in the same semester (first name, middle name, last name and ID)., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrol",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Students Student_Enrolment",
        "real_label": "Students Student_Enrolment",
        "topk_preds": [
            "Students Student_Enrolment",
            "Degree_Programs Students Student_Enrolment",
            "Semesters Students Student_Enrolment",
            "Departments Degree_Programs Students Student_Enrolment",
            "Courses Students Student_Enrolment",
            "Sections Students Student_Enrolment",
            "Departments Students Student_Enrolment",
            "Addresses Students Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me students enrolled in two degree programs during one semester and list their first, middle and last names and the IDs., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_",
        "prediction": "SELECT-FROM-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-MULTIPLE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me students enrolled in two degree programs during one semester and list their first, middle and last names and the IDs., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t",
        "prediction": "select t6.c3, t6.c4, t6.c5, t6.c0",
        "label": "select t6.c3, t6.c4, t6.c5, t6.c0",
        "score": true,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
        "real_label": "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name and Students.student_id",
            "select Students.student_id, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name., Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name plus Students.student_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me students enrolled in two degree programs during one semester and list their first, middle and last names and the IDs., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_en",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Students Student_Enrolment",
        "real_label": "Students Student_Enrolment",
        "topk_preds": [
            "Students Student_Enrolment",
            "Degree_Programs Students Student_Enrolment",
            "Semesters Students Student_Enrolment",
            "Departments Degree_Programs Students Student_Enrolment",
            "Sections Students Student_Enrolment",
            "Courses Students Student_Enrolment",
            "Departments Students Student_Enrolment",
            "Addresses Students Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The list the first name, middle name, last name and ID of students enrolled in two degrees in one semester., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrol",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The list the first name, middle name, last name and ID of students enrolled in two degrees in one semester., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7:",
        "prediction": "select t6.c3, t6.c4, t6.c5, t6.c0",
        "label": "select t6.c3, t6.c4, t6.c5, t6.c0",
        "score": true,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
        "real_label": "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select distinct Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
            "select Students.student_id, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name., Students.last_name, Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name and Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The list the first name, middle name, last name and ID of students enrolled in two degrees in one semester., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Students Student_Enrolment",
        "real_label": "Students Student_Enrolment",
        "topk_preds": [
            "Students Student_Enrolment",
            "Degree_Programs Students Student_Enrolment",
            "Semesters Students Student_Enrolment",
            "Departments Degree_Programs Students Student_Enrolment",
            "Sections Students Student_Enrolment",
            "Courses Students Student_Enrolment",
            "Departments Students Student_Enrolment",
            "Addresses Students Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names (first, middle, last), along with IDs (id) of all students enrolled in two degrees in one semester., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t",
        "prediction": "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names (first, middle, last), along with IDs (id) of all students enrolled in two degrees in one semester., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_detail",
        "prediction": "select t6.c3, t6.c4, t6.c5, t6.c0",
        "label": "select t6.c3, t6.c4, t6.c5, t6.c0",
        "score": true,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
        "real_label": "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name., Students.middle_name, Students.last_name, Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name + Students.student_id",
            "select Students.current_address_id, Students.middle_name, Students.last_name, Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name as well as Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name plus Students.student_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names (first, middle, last), along with IDs (id) of all students enrolled in two degrees in one semester., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Students Student_Enrolment",
        "real_label": "Students Student_Enrolment",
        "topk_preds": [
            "Students Student_Enrolment",
            "Degree_Programs Students Student_Enrolment",
            "Students Student_Enrolment_Courses",
            "Semesters Students Student_Enrolment",
            "Departments Degree_Programs Students Student_Enrolment",
            "Sections Students Student_Enrolment",
            "Degree_Programs Students Student_Enrolment_Courses",
            "Departments Degree_Programs Students Student_Enrolment_Courses"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all students who enrolled for two degree programs in one semester, their first, middle and last name, along with their IDs., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7:",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all students who enrolled for two degree programs in one semester, their first, middle and last name, along with their IDs., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details).",
        "prediction": "select t6.c3, t6.c4, t6.c5, t6.c0",
        "label": "select t6.c3, t6.c4, t6.c5, t6.c0",
        "score": true,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
        "real_label": "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name plus Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name and Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name ainsi, Students.student_id",
            "select Students.student_id, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name along with Students.student_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all students who enrolled for two degree programs in one semester, their first, middle and last name, along with their IDs., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Students Student_Enrolment",
        "real_label": "Students Student_Enrolment",
        "topk_preds": [
            "Students Student_Enrolment",
            "Degree_Programs Students Student_Enrolment",
            "Semesters Students Student_Enrolment",
            "Departments Degree_Programs Students Student_Enrolment",
            "Sections Students Student_Enrolment",
            "Transcripts Students Student_Enrolment",
            "Departments Students Student_Enrolment",
            "Students Student_Enrolment Student_Enrolment_Courses"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the first, middle, and last name, along with the ID of all students who enrolled in two degree programs in one semester., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7:",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-CHALLENGE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the first, middle, and last name, along with the ID of all students who enrolled in two degree programs in one semester., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details).",
        "prediction": "select t6.c3, t6.c4, t6.c5, t6.c0",
        "label": "select t6.c3, t6.c4, t6.c5, t6.c0",
        "score": true,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
        "real_label": "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name ainsi, Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name as well as Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name plus Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name and Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name + Students.student_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the first, middle, and last name, along with the ID of all students who enrolled in two degree programs in one semester., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Students Student_Enrolment",
        "real_label": "Students Student_Enrolment",
        "topk_preds": [
            "Students Student_Enrolment",
            "Degree_Programs Students Student_Enrolment",
            "Semesters Students Student_Enrolment",
            "Departments Degree_Programs Students Student_Enrolment",
            "Sections Students Student_Enrolment",
            "Courses Students Student_Enrolment",
            "Students Student_Enrolment_Courses",
            "Degree_Programs Students Student_Enrolment Student_Enrolment_Courses"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Identify all first, middle, and last names along with the IDs of all students that enrolled in two degree programs in one semester., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7",
        "prediction": "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-CHALLENGE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Identify all first, middle, and last names along with the IDs of all students that enrolled in two degree programs in one semester., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details",
        "prediction": "select t6.c3, t6.c4, t6.c5, t6.c0",
        "label": "select t6.c3, t6.c4, t6.c5, t6.c0",
        "score": true,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
        "real_label": "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name as well as Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name along with Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name plus Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name and Students.student_id",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name ainsi Students.student_id",
            "select distinct Students.first_name, Students.middle_name, Students.last_name, Students.student_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Identify all first, middle, and last names along with the IDs of all students that enrolled in two degree programs in one semester., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7:",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Students Student_Enrolment",
        "real_label": "Students Student_Enrolment",
        "topk_preds": [
            "Students Student_Enrolment",
            "Degree_Programs Students Student_Enrolment",
            "Semesters Students Student_Enrolment",
            "Departments Degree_Programs Students Student_Enrolment",
            "Students Student_Enrolment_Courses",
            "Sections Students Student_Enrolment",
            "Degree_Programs Students Student_Enrolment_Courses",
            "Courses Students Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the date and ID of the transcript with two or more course results., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAGLE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAMMA-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the date and ID of the transcript with two or more course results., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "select t10.c5, t10.c0",
        "label": "select t9.c1, t10.c1",
        "score": false,
        "real_pred": "select t10.c5, Transcript_Contents.student_course_id",
        "real_label": "select Transcripts.transcript_date, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t8.c5, Student_Enrolment_Courses.student_course_id",
            "select t12.c5, t12.c0",
            "select t9.c5, Transcripts.transcript_id",
            "select t14.c5, t14.c0",
            "select t11.c3, t11.c4",
            "select t10.c5, t10.c6",
            "select t14.c3, t14.c0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the date and ID of the transcript with two or more course results., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "t8",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Student_Enrolment_Courses",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Student_Enrolment_Courses",
            "Transcripts",
            "Transcript_Contents",
            "",
            "Transcripts Transcript_Contents",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the dates and identification numbers of transcripts with at least two grades., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the dates and identification numbers of transcripts with at least two grades., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "select t8.c5, t8.c0",
        "label": "select t9.c1, t10.c1",
        "score": false,
        "real_pred": "select t8.c5, Student_Enrolment_Courses.student_course_id",
        "real_label": "select Transcripts.transcript_date, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t8.c5, Student_Enrolment_Courses.student_course_id",
            "select t9.c5, Transcripts.transcript_id",
            "select t8.c5, t8.c6",
            "select t12.c5, t12.c0",
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t14.c5, t14.c0",
            "select t14.c3, t14.c4",
            "select t8.c5, Student_Enrolment_Courses.course_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the dates and identification numbers of transcripts with at least two grades., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "t9",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Transcripts",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Transcripts",
            "Student_Enrolment_Courses",
            "Transcript_Contents",
            "",
            "Transcripts Transcript_Contents",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the date and ID of the transcript with minimum two course results., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the date and ID of the transcript with minimum two course results., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "select t8.c5, t8.c0",
        "label": "select t9.c1, t10.c1",
        "score": false,
        "real_pred": "select t8.c5, Student_Enrolment_Courses.student_course_id",
        "real_label": "select Transcripts.transcript_date, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t8.c5, Student_Enrolment_Courses.student_course_id",
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t9.c5, Transcripts.transcript_id",
            "select t12.c5, t12.c0",
            "select t10.c5, t10.c6",
            "select t14.c3, t14.c0",
            "select t14.c5, t14.c0",
            "select t11.c3, t11.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the date and ID of the transcript with minimum two course results., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "t8",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Student_Enrolment_Courses",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Student_Enrolment_Courses",
            "Transcripts",
            "Transcript_Contents",
            "",
            "",
            "",
            "Student_Enrolment_Courses Transcripts",
            "Transcripts Transcript_Contents"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the date and ID of the transcript which has at least two course results., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAGEMENT-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the date and ID of the transcript which has at least two course results., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0",
        "prediction": "select t12.c5, t12.c0",
        "label": "select t9.c1, t10.c1",
        "score": false,
        "real_pred": "select t12.c5, t12.c0",
        "real_label": "select Transcripts.transcript_date, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t12.c5, t12.c0",
            "select t9.c5, Transcripts.transcript_id",
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t14.c5, t14.c0",
            "select t14.c3, t14.c0",
            "select t11.c3, t11.c4",
            "select t8.c5, Student_Enrolment_Courses.student_course_id",
            "select t14.c3, t14.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the date and ID of the transcript which has at least two course results., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "t8",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Student_Enrolment_Courses",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Student_Enrolment_Courses",
            "Transcripts",
            "Transcript_Contents",
            "",
            "Semesters Student_Enrolment_Courses",
            "",
            "Semesters Student_Enrolment",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the date and ID of the transcript with at least two courses listed., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING In-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING, SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the date and ID of the transcript with at least two courses listed., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "select t10.c5, t10.c0",
        "label": "select t9.c1, t10.c1",
        "score": false,
        "real_pred": "select t10.c5, Transcript_Contents.student_course_id",
        "real_label": "select Transcripts.transcript_date, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t8.c5, Student_Enrolment_Courses.student_course_id",
            "select t12.c5, t12.c0",
            "select t14.c5, t14.c0",
            "select t10.c5, t10.c6",
            "select t11.c3, t11.c4",
            "select t9.c5, Transcripts.transcript_id",
            "select t14.c3, t14.c0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the date and ID of the transcript with at least two courses listed., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "t1 t8",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Courses Student_Enrolment_Courses",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Courses Student_Enrolment_Courses",
            "Courses Transcripts",
            "Student_Enrolment_Courses",
            "Courses Student_Enrolment",
            "Semesters Student_Enrolment_Courses",
            "Transcripts",
            "",
            "Transcript_Contents"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the date and ID of transcript having at least two courses., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING I.C5, SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING INPUT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING I.C3, SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the date and ID of transcript having at least two courses., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "select t10.c5, t10.c0",
        "label": "select t9.c1, t10.c1",
        "score": false,
        "real_pred": "select t10.c5, Transcript_Contents.student_course_id",
        "real_label": "select Transcripts.transcript_date, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t14.c5, t14.c0",
            "select t14.c3, t14.c0",
            "select t8.c5, Student_Enrolment_Courses.student_course_id",
            "select t14.c3, t14.c4",
            "select t11.c3, t11.c4",
            "select t12.c5, t12.c0",
            "select t9.c5, Transcripts.transcript_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the date and ID of transcript having at least two courses., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_i",
        "prediction": "t10",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Transcript_Contents",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Transcript_Contents",
            "Transcripts",
            "Student_Enrolment_Courses",
            "Courses Student_Enrolment_Courses",
            "",
            "",
            "",
            "Courses Transcripts"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the first first name of student(s) with permanent Haitian address or who's mobile has number 09700166582, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the first first name of student(s) with permanent Haitian address or who's mobile has number 09700166582, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t",
        "prediction": "select t6.c3",
        "label": "select t6.c3",
        "score": true,
        "real_pred": "select Students.first_name",
        "real_label": "select Students.first_name",
        "topk_preds": [
            "select Students.first_name",
            "select Students.first_name, Students.last_name",
            "select Students.student_id, Students.first_name",
            "select Students.first_name, Students.middle_name",
            "select Students.first_name, Students.cell_mobile_number",
            "select Students.current_address_id, Students.first_name",
            "select Students.first_name - Students.last_name",
            "select Students.student_id, Students.permanent_address_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the first first name of student(s) with permanent Haitian address or who's mobile has number 09700166582, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_en",
        "prediction": "t0 t6",
        "label": "t0 t6",
        "score": true,
        "real_pred": "Addresses Students",
        "real_label": "Addresses Students",
        "topk_preds": [
            "Addresses Students",
            "Addresses Students Student_Enrolment",
            "Addresses Students Student_Enrolment_Courses",
            "Addresses Courses Students",
            "Addresses Semesters Students",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The content of the radio program Sky., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The content of the radio program Sky., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c4",
        "label": "select t0.c4",
        "score": true,
        "real_pred": "select TV_Channel.Content",
        "real_label": "select TV_Channel.Content",
        "topk_preds": [
            "select TV_Channel.Content",
            "select TV_Channel.Country",
            "select TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.Language",
            "select tTV_Channel.Content",
            "select TV_Channel.Hight_definition_TV",
            "select TV_Channel.Content)",
            "select TV_Channel.series_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The content of the radio program Sky., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "TV_Channel TV_series",
            "TV_Channel Cartoon",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The content of the series radio Sky., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The content of the series radio Sky., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c4",
        "label": "select t0.c4",
        "score": true,
        "real_pred": "select TV_Channel.Content",
        "real_label": "select TV_Channel.Content",
        "topk_preds": [
            "select TV_Channel.Content",
            "select TV_Channel.Content, TV_Channel.series_name",
            "select TV_Channel.Content, TV_Channel.Country",
            "select TV_Channel.Content, TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.Content, TV_series.Episode",
            "select TV_Channel.Content, TV_Channel.Language",
            "select TV_Channel.Content, TV_series.Air_Date",
            "select TV_Channel.Content, TV_Channel.Pay_per_view_PPV"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The content of the series radio Sky., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "TV_Channel TV_series",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: list the top three highest rated TV shows, their episode number, and their rating., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT, t1.c1, t1.c3",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: list the top three highest rated TV shows, their episode number, and their rating., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t1.c0, t1.c1, t1.c3",
        "label": "select t1.c1, t1.c3",
        "score": false,
        "real_pred": "select TV_series.id, TV_series.Episode, TV_series.Rating",
        "real_label": "select TV_series.Episode, TV_series.Rating",
        "topk_preds": [
            "select TV_series.id, TV_series.Episode, TV_series.Rating",
            "select TV_series.Episode, TV_series.Rating",
            "select TV_series.Episode, TV_series.Episode, TV_series.Rating",
            "select TV_series.id-, TV_series.Episode, TV_series.Rating",
            "select TV_series.id, TV_series.Episode, TV_series.Rating",
            "select t1.c, TV_series.Episode, TV_series.Rating",
            "select TV_series.id, TV_series.Episode, TV_series.Rating.",
            "select TV_series.id, TV_series.Episode, and TV_series.Rating"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: list the top three highest rated TV shows, their episode number, and their rating., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the Top three highest rated TV series and list their episode and rating., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the Top three highest rated TV series and list their episode and rating., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t1.c1, t1.c3",
        "label": "select t1.c1, t1.c3",
        "score": true,
        "real_pred": "select TV_series.Episode, TV_series.Rating",
        "real_label": "select TV_series.Episode, TV_series.Rating",
        "topk_preds": [
            "select TV_series.Episode, TV_series.Rating",
            "select TV_series.Episode, TV_series.Rating, TV_series.Air_Date",
            "select t1, TV_series.Episode, TV_series.Rating",
            "select TV_series.Episode, TV_series.Air_Date, TV_series.Rating",
            "select TV_series.Episode.c1, TV_series.Rating",
            "select TV_series.Episode, TV_series.Rating, TV_series.Share",
            "select TV_series.Episode, TV_series.Rating, TV_series.Viewers_m",
            "select TV_series.Episode, TV_series.Rating"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the Top three highest rated TV series and list their episode and rating., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the top three TV shows' ratings and list their episodes., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the top three TV shows' ratings and list their episodes., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t1.c3, t1.c1",
        "label": "select t1.c1, t1.c3",
        "score": false,
        "real_pred": "select TV_series.Rating, TV_series.Episode",
        "real_label": "select TV_series.Episode, TV_series.Rating",
        "topk_preds": [
            "select TV_series.Rating, TV_series.Episode",
            "select TV_series.Episode, TV_series.Rating",
            "select TV_series.id, TV_series.Rating, TV_series.Episode",
            "select TV_series.Air_Date, TV_series.Rating",
            "select TV_series.Rating, TV_series.Episode, TV_series.Air_Date",
            "select TV_series.id, TV_series.Episode, TV_series.Rating",
            "select TV_series.Rating.c1, TV_series.Air_Date",
            "select TV_series.id, TV_series.Episode"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the top three TV shows' ratings and list their episodes., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Top Three Highest Rated TV Series. Episode and rating., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, t1.c1, t1.c3",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Top Three Highest Rated TV Series. Episode and rating., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t1.c1, t1.c3",
        "label": "select t1.c1, t1.c3",
        "score": true,
        "real_pred": "select TV_series.Episode, TV_series.Rating",
        "real_label": "select TV_series.Episode, TV_series.Rating",
        "topk_preds": [
            "select TV_series.Episode, TV_series.Rating",
            "select TV_series.Episode, TV_series.Rating, TV_series.Air_Date",
            "select TV_series.Episode.c1, TV_series.Rating",
            "select TV_series.Episode, TV_series.Rating, TV_series.Share",
            "select TV_series.Episode, TV_series.Rating, TV_series.Viewers_m",
            "select TV_series.Episode, TV_series.Air_Date",
            "select TV_series.Episode, TV_series.Rating - TV_series.Air_Date",
            "select TV_series.Episode, t01.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Top Three Highest Rated TV Series. Episode and rating., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the Top three television programs and their episode ratings., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the Top three television programs and their episode ratings., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t1.c0, t1.c3",
        "label": "select t1.c1, t1.c3",
        "score": false,
        "real_pred": "select TV_series.id, TV_series.Rating",
        "real_label": "select TV_series.Episode, TV_series.Rating",
        "topk_preds": [
            "select TV_series.id, TV_series.Rating",
            "select TV_series.Episode, TV_series.Rating",
            "select TV_series.id, TV_series.Episode",
            "select TV_series.Rating, TV_series.Air_Date",
            "select TV_series.Air_Date, TV_series.Rating",
            "select TV_series.id, TV_series.Air_Date",
            "select TV_series.18_49_Rating_Share, TV_series.Rating",
            "select TV_series.Viewers_m, TV_series.Rating"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the Top three television programs and their episode ratings., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the three highest rated episodes in the TV series table and what were their ratings?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-THREE-UNION-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the three highest rated episodes in the TV series table and what were their ratings?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t1.c1, t1.c3",
        "label": "select t1.c1, t1.c3",
        "score": true,
        "real_pred": "select TV_series.Episode, TV_series.Rating",
        "real_label": "select TV_series.Episode, TV_series.Rating",
        "topk_preds": [
            "select TV_series.Episode, TV_series.Rating",
            "select top-TV_series.Episode, TV_series.Rating",
            "select TV_series.id, TV_series.Rating",
            "select TV_series.Episode, TV_series.Air_Date",
            "select TV_series.Episode, sum(TV_series.Rating)",
            "select the TV_series.Episode, TV_series.Rating",
            "select Cartoon.Title, TV_series.Rating",
            "select TV_series.Air_Date, TV_series.Rating"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the three highest rated episodes in the TV series table and what were their ratings?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the three highest rated episodes in the TV series table and what were their ratings., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SCHEMPT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SCHEMPT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the three highest rated episodes in the TV series table and what were their ratings., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t1.c1, t1.c3",
        "label": "select t1.c1, t1.c3",
        "score": true,
        "real_pred": "select TV_series.Episode, TV_series.Rating",
        "real_label": "select TV_series.Episode, TV_series.Rating",
        "topk_preds": [
            "select TV_series.Episode, TV_series.Rating",
            "select TV_series.Episode, sum(TV_series.Rating)",
            "select TV_series.id, TV_series.Rating",
            "select TV_series.Episode, max(TV_series.Rating)",
            "select TV_series.Episode, TV_series.Air_Date",
            "select TV_series.Episode, TV_series.Rating",
            "select TV_series.Episode, TV_series.Rating.",
            "select Cartoon.Title, TV_series.Rating"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the three highest rated episodes in the TV series table and what were their ratings., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the ids of all tv channels that have more than two TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING In-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the ids of all tv channels that have more than two TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select TV_Channel.id",
        "real_label": "select TV_Channel.id",
        "topk_preds": [
            "select TV_Channel.id",
            "select TV_Channel.id, TV_Channel.Hight_definition_TV",
            "select TV_Channel.id, TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.id, TV_Channel.Pay_per_view_PPV",
            "select tv0.c0",
            "select TV_Channel.id, TV_Channel.series_name",
            "select TV_Channel.id, TV_Channel.Country",
            "select TV_Channel.id, TV_Channel.Language"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the ids of all tv channels that have more than two TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "TV_Channel TV_series",
            "TV_Channel Cartoon",
            "",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Display the ids of all tv channels that have more than two TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Display the ids of all tv channels that have more than two TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select TV_Channel.id",
        "real_label": "select TV_Channel.id",
        "topk_preds": [
            "select TV_Channel.id",
            "select TV_Channel.id, TV_Channel.Hight_definition_TV",
            "select TV_Channel.id, TV_Channel.Pixel_aspect_ratio_PAR",
            "select tv0.c0",
            "select TV_Channel.id, TV_Channel.Pay_per_view_PPV",
            "select TV_Channel.id, TV_Channel.series_name",
            "select TV_Channel.id, TV_Channel.Country",
            "select TV_Channel.id, TV_Channel.Language"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Display the ids of all tv channels that have more than two TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "TV_Channel TV_series",
            "TV_Channel Cartoon",
            "",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the IDs of all TV channels that have more than two TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING In-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the IDs of all TV channels that have more than two TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select TV_Channel.id",
        "real_label": "select TV_Channel.id",
        "topk_preds": [
            "select TV_Channel.id",
            "select TV_Channel.id, TV_Channel.Hight_definition_TV",
            "select TV_Channel.id, TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.id, TV_Channel.Pay_per_view_PPV",
            "select TV_Channel.id, TV_Channel.series_name",
            "select TV_Channel.id, TV_Channel.Country",
            "select TV_Channel.id, TV_Channel.Language",
            "select TV_Channel.id, t0.c9"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the IDs of all TV channels that have more than two TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "TV_Channel TV_series",
            "TV_Channel Cartoon",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the IDs of all TVs channels which have more than two TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING In-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the IDs of all TVs channels which have more than two TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select TV_Channel.id",
        "real_label": "select TV_Channel.id",
        "topk_preds": [
            "select TV_Channel.id",
            "select tv0.c0",
            "select tv.c0",
            "select tTV_Channel.id",
            "select tvs.c0",
            "select Cartoon.id",
            "select tv_c0",
            "select TV_Channel.series_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the IDs of all TVs channels which have more than two TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "TV_Channel TV_series",
            "TV_Channel Cartoon",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Identify the IDs of all television channels having more than two TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Identify the IDs of all television channels having more than two TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select TV_Channel.id",
        "real_label": "select TV_Channel.id",
        "topk_preds": [
            "select TV_Channel.id",
            "select TV_Channel.id, TV_Channel.Hight_definition_TV",
            "select TV_Channel.id, TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.id, TV_Channel.Pay_per_view_PPV",
            "select TV_Channel.id, TV_Channel.series_name",
            "select TV_Channel.id, TV_Channel.Country",
            "select TV_Channel.id, TV_Channel.Language",
            "select TV_Channel.id, t0.c9"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Identify the IDs of all television channels having more than two TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "TV_Channel TV_series",
            "TV_Channel Cartoon",
            "",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Maximum number of final tables made among poker players with less than 200K earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Maximum number of final tables made among poker players with less than 200K earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select max(t0.c2)",
        "label": "select max(t0.c2)",
        "score": true,
        "real_pred": "select max(poker_player.Final_Table_Made)",
        "real_label": "select max(poker_player.Final_Table_Made)",
        "topk_preds": [
            "select max(poker_player.Final_Table_Made)",
            "select max(poker_player.Final_Table_Made), poker_player.Earnings",
            "select max(poker_player.Final_Table_Made) (poker_player.Poker_Player_ID)",
            "select max(poker_player.Final_Table_Made), poker_player.Best_Finish",
            "select max(poker_player.Final_Table_Made) de poker_player.Poker_Player_ID",
            "select max(poker_player.Final_Table_Made), t0.c7",
            "select max(poker_player.Final_Table_Made) [poker_player.Poker_Player_ID]",
            "select max(poker_player.Final_Table_Made), poker_player.Money_Rank"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Maximum number of final tables made among poker players with less than 200K earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The maximum number of final tables made among poker players with earnings less than 200K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE -GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE - GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE max(t0.c2)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The maximum number of final tables made among poker players with earnings less than 200K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select max(t0.c2)",
        "label": "select max(t0.c2)",
        "score": true,
        "real_pred": "select max(poker_player.Final_Table_Made)",
        "real_label": "select max(poker_player.Final_Table_Made)",
        "topk_preds": [
            "select max(poker_player.Final_Table_Made)",
            "select max(poker_player.Final_Table_Made), poker_player.Earnings",
            "select max(poker_player.Final_Table_Made) (poker_player.Poker_Player_ID)",
            "select max(poker_player.Final_Table_Made), poker_player.Best_Finish",
            "select max(poker_player.Final_Table_Made) de poker_player.Poker_Player_ID",
            "select max(poker_player.Final_Table_Made), t0.c7",
            "select max(poker_player.Final_Table_Made), poker_player.Earnings.",
            "select max(poker_player.Final_Table_Made) [poker_player.Poker_Player_ID]"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The maximum number of final tables made among poker players with earnings less than 200K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Determine the maximum number of Final Tables made among poker players with Earnings under 200K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE -GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE - GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE.GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE max(t0.c2)",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Determine the maximum number of Final Tables made among poker players with Earnings under 200K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select max(t0.c2)",
        "label": "select max(t0.c2)",
        "score": true,
        "real_pred": "select max(poker_player.Final_Table_Made)",
        "real_label": "select max(poker_player.Final_Table_Made)",
        "topk_preds": [
            "select max(poker_player.Final_Table_Made)",
            "select max(poker_player.Final_Table_Made), poker_player.Earnings",
            "select max(poker_player.Final_Table_Made) dependant on poker_player.Earnings",
            "select max(poker_player.Final_Table_Made) dependant on poker_player.Poker_Player_ID",
            "select max(poker_player.Final_Table_Made), poker_player.Best_Finish",
            "select max(poker_player.Final_Table_Made), poker_player.Poker_Player_ID",
            "select max(poker_player.Final_Table_Made), poker_player.People_ID",
            "select max(poker_player.Final_Table_Made), t0.c7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Determine the maximum number of Final Tables made among poker players with Earnings under 200K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the maximum final tables made across all poker players who have earned less than 200K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (max(t0.c2)",
            "SELECT-FROM-WHERE (MAX(t0.c2)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the maximum final tables made across all poker players who have earned less than 200K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select max(t0.c2)",
        "label": "select max(t0.c2)",
        "score": true,
        "real_pred": "select max(poker_player.Final_Table_Made)",
        "real_label": "select max(poker_player.Final_Table_Made)",
        "topk_preds": [
            "select max(poker_player.Final_Table_Made)",
            "select max(poker_player.Final_Table_Made), poker_player.Earnings",
            "select max(poker_player.Final_Table_Made), poker_player.Best_Finish",
            "select max(poker_player.Final_Table_Made) de poker_player.Poker_Player_ID",
            "select max(poker_player.Final_Table_Made) (poker_player.Earnings)",
            "select max(t0.c6)",
            "select max(poker_player.Final_Table_Made), poker_player.Money_Rank",
            "select max(poker_player.Final_Table_Made) [poker_player.Poker_Player_ID]"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the maximum final tables made across all poker players who have earned less than 200K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the highest final table made for all poker players that have earnings under 200K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the highest final table made for all poker players that have earnings under 200K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select max(t0.c2)",
        "label": "select max(t0.c2)",
        "score": true,
        "real_pred": "select max(poker_player.Final_Table_Made)",
        "real_label": "select max(poker_player.Final_Table_Made)",
        "topk_preds": [
            "select max(poker_player.Final_Table_Made)",
            "select poker_player.Final_Table_Made",
            "select max(poker_player.Final_Table_Made), poker_player.Best_Finish",
            "select poker_player.Poker_Player_ID, poker_player.Final_Table_Made",
            "select max(poker_player.Final_Table_Made), max(poker_player.Best_Finish)",
            "select max(poker_player.Best_Finish)",
            "select poker_player.Poker_Player_ID, max(poker_player.Final_Table_Made)",
            "select max(t0.c6)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the highest final table made for all poker players that have earnings under 200K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The name of the poker players whose earnings are more than 300K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The name of the poker players whose earnings are more than 300K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, poker_player.People_ID",
            "select people.Name, poker_player.Poker_Player_ID",
            "select people.Name, poker_player.Best_Finish",
            "select people.Name, people.Nationality",
            "select people.Name, t1.c5",
            "select people.Name, poker_player.Earnings"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The name of the poker players whose earnings are more than 300K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name of poker player with more than 300K in their accounts., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-RELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-RELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name of poker player with more than 300K in their accounts., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, poker_player.People_ID",
            "select people.Name, people.Nationality",
            "select people.Name, poker_player.Poker_Player_ID",
            "select people.Name, poker_player.Best_Finish",
            "select people.Name, people.Height",
            "select people.Name, poker_player.Earnings"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name of poker player with more than 300K in their accounts., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of poker players whose earnings exceeds $300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of poker players whose earnings exceeds $300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, poker_player.People_ID",
            "select people.Name, poker_player.Poker_Player_ID",
            "select people.Name, people.Nationality",
            "select people.Name, t1.c5",
            "select people.Name, poker_player.Best_Finish",
            "select people.Name, poker_player.Earnings"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of poker players whose earnings exceeds $300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Names of poker players whose earnings are higher than 300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-RELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Names of poker players whose earnings are higher than 300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, poker_player.Poker_Player_ID",
            "select people.Name, poker_player.People_ID",
            "select people.Name, t1.c5",
            "select people.Name, poker_player.Best_Finish",
            "select people.Name, poker_player.Earnings",
            "select people.Name, people.Nationality"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Names of poker players whose earnings are higher than 300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name of Poker players whose earnings are over 300K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-RELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-FROM-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name of Poker players whose earnings are over 300K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, poker_player.People_ID",
            "select people.Name, poker_player.Poker_Player_ID",
            "select people.Name, poker_player.Best_Finish",
            "select people.Name, poker_player.Earnings",
            "select people.Name, people.Nationality",
            "select people.Name, t1.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name of Poker players whose earnings are over 300K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are the poker players whose earnings is more than 300k dollars?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are the poker players whose earnings is more than 300k dollars?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c1",
        "label": "select t1.c2",
        "score": false,
        "real_pred": "select poker_player.People_ID",
        "real_label": "select people.Name",
        "topk_preds": [
            "select poker_player.People_ID",
            "select poker_player.People_ID, poker_player.Poker_Player_ID",
            "select poker_player.People_ID, poker_player.Final_Table_Made",
            "select poker_player.Poker_Player_ID",
            "select poker_player.Poker_Player_ID, poker_player.People_ID",
            "select poker_player.People_ID, poker_player.Best_Finish",
            "select poker_player.People_ID, poker_player.Earnings",
            "select poker_player.People_ID, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are the poker players whose earnings is more than 300k dollars?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0 t1",
        "score": false,
        "real_pred": "poker_player",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give the names of poker players that have made more than $300K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give the names of poker players that have made more than $300K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, poker_player.People_ID",
            "select people.Name, people.Nationality",
            "select people.Name, poker_player.Poker_Player_ID",
            "select people.Name, people.People_ID",
            "select people.Name, people.Height",
            "select people.Nationality, people.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give the names of poker players that have made more than $300K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give names of poker players who have exceeded $300,000 earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give names of poker players who have exceeded $300,000 earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, poker_player.People_ID",
            "select people.Name, people.Nationality",
            "select people.Name, people.People_ID",
            "select people.Name, t1.c5",
            "select people.Name, people.Height",
            "select people.Name, poker_player.Poker_Player_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give names of poker players who have exceeded $300,000 earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: give the names of the poker players who have revenues above 300K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: give the names of the poker players who have revenues above 300K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, poker_player.People_ID",
            "select people.Name, poker_player.Poker_Player_ID",
            "select people.Name, t1.c5",
            "select people.Name, people.Nationality",
            "select people.Name, poker_player.Best_Finish",
            "select people.Nationality, people.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: give the names of the poker players who have revenues above 300K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give the names of poker players whose earnings exceed $300K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give the names of poker players whose earnings exceed $300K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, poker_player.People_ID",
            "select people.Name, poker_player.Poker_Player_ID",
            "select people.Name, people.Nationality",
            "select people.Name, t1.c5",
            "select people.Nationality, people.Name",
            "select people.Name, people.Height"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give the names of poker players whose earnings exceed $300K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give the names of the poker players who have earned more than $300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give the names of the poker players who have earned more than $300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, poker_player.People_ID",
            "select people.Name, poker_player.Poker_Player_ID",
            "select people.Name, people.People_ID",
            "select people.Name, people.Nationality",
            "select people.Name, poker_player.Best_Finish",
            "select people.Name, t1.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give the names of the poker players who have earned more than $300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give the names of poker players who have earned more than $300K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give the names of poker players who have earned more than $300K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, poker_player.People_ID",
            "select people.Name, people.Nationality",
            "select people.Name, poker_player.Poker_Player_ID",
            "select people.Nationality, people.Name",
            "select people.Name, people.People_ID",
            "select people.Name, t1.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give the names of poker players who have earned more than $300K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: give the names of poker players who have earned more than 30 K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: give the names of poker players who have earned more than 30 K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, poker_player.People_ID",
            "select people.Name, poker_player.Poker_Player_ID",
            "select people.Name, poker_player.Best_Finish",
            "select people.Name, people.Nationality",
            "select people.Name, poker_player.Earnings",
            "select people.Name, t1.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: give the names of poker players who have earned more than 30 K., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Calculate the average earning for poker players who are taller than 200cm., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (Avg(t0.c5)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE -GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Calculate the average earning for poker players who are taller than 200cm., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select avg(t0.c5)",
        "label": "select avg(t0.c5)",
        "score": true,
        "real_pred": "select avg(poker_player.Earnings)",
        "real_label": "select avg(poker_player.Earnings)",
        "topk_preds": [
            "select avg(poker_player.Earnings)",
            "select an avg(poker_player.Earnings)",
            "select the avg(poker_player.Earnings)",
            "select  avg(poker_player.Earnings)",
            "select avg(t0.c6)",
            "select Avg(poker_player.Earnings)",
            "select avg(poker_player.Earnings),",
            "select \u0430vg(poker_player.Earnings)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Calculate the average earning for poker players who are taller than 200cm., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show names of people who do not have Russian nationality., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show names of people who do not have Russian nationality., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Nationality",
            "select people.Name, people.Birth_Date",
            "select people.Name, people.Height",
            "select people.Name, t1.c6",
            "select people.Name, t1.c5",
            "select people.Name, t1.c7",
            "select people.Name, people.Nationality3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show names of people who do not have Russian nationality., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the people who do not have Russian citizenship and return their names., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the people who do not have Russian citizenship and return their names., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Nationality",
            "select people.Name, people.People_ID",
            "select people.People_ID, people.Name",
            "select people.Nationality, people.Name",
            "select people.Name,",
            "select people.Name, people.Birth_Date",
            "select people.Name, t1.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the people who do not have Russian citizenship and return their names., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of the persons who are NOT Russian citizens., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHICH-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of the persons who are NOT Russian citizens., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Nationality",
            "select people.Name, people.Birth_Date",
            "select people.Nationality, people.Name",
            "select people.Name, people.Height",
            "select people.Name (except people.Birth_Date)",
            "select people.Name (not people.Birth_Date)",
            "select people.Name (or people.Birth_Date)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of the persons who are NOT Russian citizens., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "poker_player people",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: All the people not considered Russians (name them)., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: All the people not considered Russians (name them)., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.People_ID",
            "select people.People_ID, people.Name",
            "select people.Name, people.Nationality",
            "select people.Nationality, people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, people.Height",
            "select people.Name, t1.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: All the people not considered Russians (name them)., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of people who are not Russian., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of people who are not Russian., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Nationality",
            "select people.Name, people.Birth_Date",
            "select people.Name, people.Height",
            "select people.Name, t1.c5",
            "select people.Name, t1.c6",
            "select people.Name, t1.c7",
            "select people.Name (or people.Birth_Date)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of people who are not Russian., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the last date when a vote was created from California., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE -ORDER BY-LIMIT",
            "SELECT-FROM-WHERE.ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the last date when a vote was created from California., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select max(t2.c4)",
        "label": "select max(t2.c4)",
        "score": true,
        "real_pred": "select max(VOTES.created)",
        "real_label": "select max(VOTES.created)",
        "topk_preds": [
            "select max(VOTES.created)",
            "select VOTES.created",
            "select max(VOTES.created), AREA_CODE_STATE.state",
            "select max(VOTES.created), VOTES.state",
            "select max(VOTES.created), VOTES.phone_number",
            "select max(VOTES.created), t2.c6",
            "select max(VOTES.created), t2.c5",
            "select max(VOTES.created), VOTES.contestant_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the last date when a vote was created from California., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "VOTES",
            "AREA_CODE_STATE VOTES",
            "CONTESTANTS VOTES",
            "AREA_CODE_STATE CONTESTANTS VOTES",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the latest date created of votes in the state of California., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE -ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (maximum t2.c4)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the latest date created of votes in the state of California., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select max(t2.c4)",
        "label": "select max(t2.c4)",
        "score": true,
        "real_pred": "select max(VOTES.created)",
        "real_label": "select max(VOTES.created)",
        "topk_preds": [
            "select max(VOTES.created)",
            "select max(VOTES.created), AREA_CODE_STATE.state",
            "select max(VOTES.created), VOTES.state",
            "select max(VOTES.created), VOTES.phone_number",
            "select max(VOTES.created), t2.c5",
            "select max(VOTES.created), t2.c6",
            "select max(VOTES.created), VOTES.contestant_number",
            "select max(VOTES.created), VOTES.vote_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the latest date created of votes in the state of California., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "VOTES",
            "AREA_CODE_STATE VOTES",
            "AREA_CODE_STATE CONTESTANTS VOTES",
            "",
            "CONTESTANTS VOTES",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the last date created for votes from the state California., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE.ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the last date created for votes from the state California., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select max(t2.c4)",
        "label": "select max(t2.c4)",
        "score": true,
        "real_pred": "select max(VOTES.created)",
        "real_label": "select max(VOTES.created)",
        "topk_preds": [
            "select max(VOTES.created)",
            "select VOTES.created",
            "select min(VOTES.created)",
            "select the max(VOTES.created)",
            "select VOTES.created)",
            "select max(t2.c5)",
            "select max(VOTES.contestant_number)",
            "select max(VOTES.created),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the last date created for votes from the state California., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "VOTES",
            "AREA_CODE_STATE VOTES",
            "AREA_CODE_STATE CONTESTANTS VOTES",
            "CONTESTANTS VOTES",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the last date of votes from California., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE -ORDER BY-LIMIT",
            "SELECT-FROM-WHERE.ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the last date of votes from California., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select max(t2.c4)",
        "label": "select max(t2.c4)",
        "score": true,
        "real_pred": "select max(VOTES.created)",
        "real_label": "select max(VOTES.created)",
        "topk_preds": [
            "select max(VOTES.created)",
            "select VOTES.created",
            "select t2.c5",
            "select VOTES.vote_id, max(VOTES.created)",
            "select max(VOTES.created), VOTES.state",
            "select VOTES.vote_id, VOTES.created",
            "select max(t2.c5)",
            "select t2.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the last date of votes from California., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "VOTES",
            "AREA_CODE_STATE VOTES",
            "",
            "AREA_CODE_STATE CONTESTANTS VOTES",
            "CONTESTANTS VOTES",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What was the last date that votes were created in the state of California?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What was the last date that votes were created in the state of California?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select max(t2.c4)",
        "label": "select max(t2.c4)",
        "score": true,
        "real_pred": "select max(VOTES.created)",
        "real_label": "select max(VOTES.created)",
        "topk_preds": [
            "select max(VOTES.created)",
            "select VOTES.created",
            "select max(VOTES.created), AREA_CODE_STATE.state",
            "select min(VOTES.created)",
            "select max(VOTES.created), VOTES.state",
            "select max(VOTES.created), VOTES.phone_number",
            "select max(VOTES.created), t2.c5",
            "select max(VOTES.created), t2.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What was the last date that votes were created in the state of California?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "VOTES",
            "AREA_CODE_STATE VOTES",
            "AREA_CODE_STATE CONTESTANTS VOTES",
            "CONTESTANTS VOTES",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Determine when last votes were posted for the State of California., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE -ORDER BY-LIMIT",
            "SELECT-FROM-WHERE.ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Determine when last votes were posted for the State of California., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select t2.c5",
        "label": "select max(t2.c4)",
        "score": false,
        "real_pred": "select t2.c5",
        "real_label": "select max(VOTES.created)",
        "topk_preds": [
            "select t2.c5",
            "select max(VOTES.created)",
            "select VOTES.created",
            "select VOTES.vote_id, max(VOTES.created)",
            "select t2.c6",
            "select VOTES.vote_id, max(t2.c5)",
            "select VOTES.vote_id",
            "select VOTES.vote_id, max(t2.c6)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Determine when last votes were posted for the State of California., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t0 t2",
        "label": "t2",
        "score": false,
        "real_pred": "AREA_CODE_STATE VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "AREA_CODE_STATE VOTES",
            "VOTES",
            "CONTESTANTS VOTES",
            "AREA_CODE_STATE CONTESTANTS VOTES",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the last date for the creation of the votes in the State of California?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT",
            "SELECT-FROM-WHERE.ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the last date for the creation of the votes in the State of California?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select max(t2.c4)",
        "label": "select max(t2.c4)",
        "score": true,
        "real_pred": "select max(VOTES.created)",
        "real_label": "select max(VOTES.created)",
        "topk_preds": [
            "select max(VOTES.created)",
            "select VOTES.created",
            "select min(VOTES.created)",
            "select the max(VOTES.created)",
            "select LAST(VOTES.created)",
            "select max(t2.c5)",
            "select VOTES.created)",
            "select max(VOTES.contestant_number)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the last date for the creation of the votes in the State of California?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "VOTES",
            "AREA_CODE_STATE VOTES",
            "AREA_CODE_STATE CONTESTANTS VOTES",
            "",
            "CONTESTANTS VOTES",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The total number of voters for New York (or California)., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The total number of voters for New York (or California)., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), AREA_CODE_STATE.state",
            "select VOTES.state, count(*)",
            "select count(*), AREA_CODE_STATE.state, VOTES.state",
            "select sum(VOTES.vote_id)",
            "select count(*), AREA_CODE_STATE.state, t0.c2",
            "select sum(VOTES.vote_id), AREA_CODE_STATE.state",
            "select count(*), AREA_CODE_STATE.state, AREA_CODE_STATE.state"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The total number of voters for New York (or California)., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t0 t2",
        "label": "t2",
        "score": false,
        "real_pred": "AREA_CODE_STATE VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "AREA_CODE_STATE VOTES",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of votes in either NY or California., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state (NY)). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state (NY), c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE.GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of votes in either NY or California., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state (NY)). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state (NY), c3: contestant_number, c4: created).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), VOTES.state",
            "select count(*), AREA_CODE_STATE.state",
            "select count(*) in VOTES.state",
            "select VOTES.state, count(*)",
            "select count(*) In VOTES.state",
            "select sum(VOTES.vote_id)",
            "select count(*), VOTES.phone_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of votes in either NY or California., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state (NY)). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state (NY), c3: contestant_number, c4: created).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "VOTES",
            "AREA_CODE_STATE VOTES",
            "AREA_CODE_STATE CONTESTANTS VOTES",
            "CONTESTANTS VOTES",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of vote from state New York (or California)., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE.GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of vote from state New York (or California)., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), AREA_CODE_STATE.state",
            "select VOTES.state, count(*)",
            "select count(*), VOTES.state",
            "select count(*0.c0)",
            "select count(*)AREA_CODE_STATE.state",
            "select VOTES.vote_id, count(*)",
            "select count(0.c0)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of vote from state New York (or California)., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t0 t2",
        "label": "t2",
        "score": false,
        "real_pred": "AREA_CODE_STATE VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "AREA_CODE_STATE VOTES",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of vote count in New York or California?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE.GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of vote count in New York or California?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select VOTES.state, count(*)",
            "select count(*), AREA_CODE_STATE.state",
            "select sum(VOTES.vote_id)",
            "select count(*), AREA_CODE_STATE.area_code, AREA_CODE_STATE.state",
            "select count(*), AREA_CODE_STATE.state, VOTES.state",
            "select VOTES.state, count(*), AREA_CODE_STATE.area_code",
            "select sum(VOTES.vote_id), AREA_CODE_STATE.state"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of vote count in New York or California?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t0 t2",
        "label": "t2",
        "score": false,
        "real_pred": "AREA_CODE_STATE VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "AREA_CODE_STATE VOTES",
            "",
            "CONTESTANTS VOTES",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of countries having a Republican Government., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE(count(*)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of countries having a Republican Government., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), country.Code",
            "select count(*), country.Name",
            "select count(*), country.GovernmentForm",
            "select count(*) dependant on country.GovernmentForm",
            "select count(*), country.Capital",
            "select count(*), country.LocalName",
            "select count(*) dependant on country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of countries having a Republican Government., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Brazilian Population & Life Expectancy, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Brazilian Population & Life Expectancy, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c6, t2.c7",
        "label": "select t2.c6, t2.c7",
        "score": true,
        "real_pred": "select country.Population, country.LifeExpectancy",
        "real_label": "select country.Population, country.LifeExpectancy",
        "topk_preds": [
            "select country.Population, country.LifeExpectancy",
            "select country.Name, country.Population, country.LifeExpectancy",
            "select country.Code, country.Population, country.LifeExpectancy",
            "select country.Code, country.Name, country.Population, country.LifeExpectancy",
            "select country.Name, country.Population",
            "select country.Name, country.Population & country.LifeExpectancy",
            "select country.IndepYear, country.Population, country.LifeExpectancy",
            "select country.Code, country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Brazilian Population & Life Expectancy, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show how many years a human being lives on average in the Central African region., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district (Central), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region (Central Africa), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show how many years a human being lives on average in the Central African region., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district (Central), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region (Central Africa), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c7)",
        "label": "select avg(t2.c7)",
        "score": true,
        "real_pred": "select avg(country.LifeExpectancy)",
        "real_label": "select avg(country.LifeExpectancy)",
        "topk_preds": [
            "select avg(country.LifeExpectancy)",
            "select an avg(country.LifeExpectancy)",
            "select Avg(country.LifeExpectancy)",
            "select  avg(country.LifeExpectancy)",
            "select avg(country.Population)",
            "select avg(country.IndepYear)",
            "select avg(country.GNP)",
            "select avg(country.LifeExpectancy)."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show how many years a human being lives on average in the Central African region., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district (Central), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region (Central Africa), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "sqlite_sequence country",
            "city country",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me how long the average life expectancy is for Central Africans., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district (Central), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region (Central Africa), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (Avg(t2.c7)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me how long the average life expectancy is for Central Africans., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district (Central), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region (Central Africa), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c7)",
        "label": "select avg(t2.c7)",
        "score": true,
        "real_pred": "select avg(country.LifeExpectancy)",
        "real_label": "select avg(country.LifeExpectancy)",
        "topk_preds": [
            "select avg(country.LifeExpectancy)",
            "select an avg(country.LifeExpectancy)",
            "select  avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy).",
            "select Avg(country.LifeExpectancy)",
            "select the avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy",
            "select avg(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me how long the average life expectancy is for Central Africans., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district (Central), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region (Central Africa), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "sqlite_sequence country",
            "city country",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the name of Asian country whose life expectancy is the lowest., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE.ORDER BY-LIMIT",
            "SELECT-FROM-WHEREORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE or-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE ORDER BY-LIMIT",
            "SELECT-FROM-WHERE\u2013ORDER BY-LIMIT",
            "SELECT-FROM-WHERE -ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the name of Asian country whose life expectancy is the lowest., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Name, country.Region",
            "select country.Name, country.LifeExpectancy",
            "select country.Name (country.LifeExpectancy)",
            "select country.Name, country.IndepYear",
            "select country.Name, country.SurfaceArea"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the name of Asian country whose life expectancy is the lowest., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the name of Asian countries that has a short average life expectancy., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AGGRESS-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GEOGRAPHY-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the name of Asian countries that has a short average life expectancy., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Name, country.Region",
            "select country.Name, country.LifeExpectancy",
            "select country.Name, country.SurfaceArea",
            "select country.Name, country.IndepYear",
            "select country.Name, country.GNP"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the name of Asian countries that has a short average life expectancy., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the country that has the shortest life expectation in the Asian region., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the country that has the shortest life expectation in the Asian region., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Region",
            "select country.Name, country.Continent",
            "select country.Name, country.LifeExpectancy",
            "select country.Name, country.Population",
            "select country.Name, country.Capital",
            "select country.Name, country.Code",
            "select country.Name (country.LifeExpectancy)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the country that has the shortest life expectation in the Asian region., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give the name of the Asian country with the lowest life expectancy., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE or-ORDER BY-LIMIT",
            "SELECT-FROM-WHEREORDER BY-LIMIT",
            "SELECT-FROM-WHERE ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY -LIMIT",
            "SELECT-FROM-WHERE orORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give the name of the Asian country with the lowest life expectancy., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Name, country.Region",
            "select country.Name, country.LifeExpectancy",
            "select country.Name (country.LifeExpectancy)",
            "select country.Name, country.IndepYear",
            "select country.Name, country.SurfaceArea"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give the name of the Asian country with the lowest life expectancy., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all Asians' population and maximum GNP., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all Asians' population and maximum GNP., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c6, max(t2.c8)",
        "label": "select sum(t2.c6), max(t2.c8)",
        "score": false,
        "real_pred": "select country.Population, max(country.GNP)",
        "real_label": "select sum(country.Population), max(country.GNP)",
        "topk_preds": [
            "select country.Population, max(country.GNP)",
            "select country.Code, country.Population, max(country.GNP)",
            "select country.Name, max(country.GNP)",
            "select country.Code, max(country.GNP)",
            "select max(country.GNP), country.Population",
            "select country.IndepYear, max(country.GNP)",
            "select country.SurfaceArea, max(country.GNP)",
            "select country.Population, max(country.GNP), country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all Asians' population and maximum GNP., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Average life span for African countries that are republics., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Spain), c2: continent (Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (Avg(t2.c7)",
            "SELECT-FROM-WHERE (avg(t2.c7)",
            "SELECT-FROM-WHERE\u2013GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Average life span for African countries that are republics., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Spain), c2: continent (Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c7)",
        "label": "select avg(t2.c7)",
        "score": true,
        "real_pred": "select avg(country.LifeExpectancy)",
        "real_label": "select avg(country.LifeExpectancy)",
        "topk_preds": [
            "select avg(country.LifeExpectancy)",
            "select an avg(country.LifeExpectancy)",
            "select  avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy).",
            "select Avg(country.LifeExpectancy)",
            "select the avg(country.LifeExpectancy)",
            "select avg(country.Population)",
            "select avg(country.LifeExpectancy"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Average life span for African countries that are republics., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Spain), c2: continent (Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the average life expectancy for African countries that are republics., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (Avg(t2.c7)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the average life expectancy for African countries that are republics., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c7)",
        "label": "select avg(t2.c7)",
        "score": true,
        "real_pred": "select avg(country.LifeExpectancy)",
        "real_label": "select avg(country.LifeExpectancy)",
        "topk_preds": [
            "select avg(country.LifeExpectancy)",
            "select an avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), country.GovernmentForm",
            "select avg(country.LifeExpectancy), country.Population",
            "select  avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), country.LocalName",
            "select avg(country.LifeExpectancy), country.Name",
            "select avg(country.LifeExpectancy), country.GNPOld"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the average life expectancy for African countries that are republics., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the average life expectancy for African countries that are republics., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (Avg(t2.c7)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the average life expectancy for African countries that are republics., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c7)",
        "label": "select avg(t2.c7)",
        "score": true,
        "real_pred": "select avg(country.LifeExpectancy)",
        "real_label": "select avg(country.LifeExpectancy)",
        "topk_preds": [
            "select avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), country.GovernmentForm",
            "select an avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), country.Population",
            "select  avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), country.LocalName",
            "select avg(country.LifeExpectancy), country.GNPOld",
            "select avg(country.LifeExpectancy), country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the average life expectancy for African countries that are republics., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the average lifespan of all African Republics., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (avg(t2.c7)",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (Avg(t2.c7)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the average lifespan of all African Republics., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c7)",
        "label": "select avg(t2.c7)",
        "score": true,
        "real_pred": "select avg(country.LifeExpectancy)",
        "real_label": "select avg(country.LifeExpectancy)",
        "topk_preds": [
            "select avg(country.LifeExpectancy)",
            "select an avg(country.LifeExpectancy)",
            "select  avg(country.LifeExpectancy)",
            "select Avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy).",
            "select avg(country.LifeExpectancy",
            "select the avg(country.LifeExpectancy)",
            "select avg(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the average lifespan of all African Republics., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find out the area of the continent Asia and the European continent., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE\u2013UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find out the area of the continent Asia and the European continent., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c4",
        "label": "select sum(t2.c4)",
        "score": false,
        "real_pred": "select country.SurfaceArea",
        "real_label": "select sum(country.SurfaceArea)",
        "topk_preds": [
            "select country.SurfaceArea",
            "select sum(country.SurfaceArea)",
            "select country.SurfaceArea, country.IndepYear",
            "select country.SurfaceArea, country.Population",
            "select country.SurfaceArea, country.Region",
            "select avg(country.SurfaceArea)",
            "select sum(country.SurfaceArea), country.Continent",
            "select country.SurfaceArea, country.LifeExpectancy"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find out the area of the continent Asia and the European continent., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show Total surfaces areas covered by the Asian or European countries, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show Total surfaces areas covered by the Asian or European countries, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t2.c4)",
        "label": "select sum(t2.c4)",
        "score": true,
        "real_pred": "select sum(country.SurfaceArea)",
        "real_label": "select sum(country.SurfaceArea)",
        "topk_preds": [
            "select sum(country.SurfaceArea)",
            "select sum(country.SurfaceArea), country.Continent",
            "select sum(country.SurfaceArea), country.Name",
            "select sum(country.SurfaceArea), country.Continent",
            "select sum(country.SurfaceArea) delimited by country.Name",
            "select sum(country.SurfaceArea), country.Population",
            "select sum(country.SurfaceArea) dependant on country.Continent",
            "select sum(country.SurfaceArea), country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show Total surfaces areas covered by the Asian or European countries, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: give the total surface area covered by Asian countries or European ones., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: give the total surface area covered by Asian countries or European ones., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t2.c4)",
        "label": "select sum(t2.c4)",
        "score": true,
        "real_pred": "select sum(country.SurfaceArea)",
        "real_label": "select sum(country.SurfaceArea)",
        "topk_preds": [
            "select sum(country.SurfaceArea)",
            "select sum(country.SurfaceArea), country.Continent",
            "select sum(country.SurfaceArea) dependant on whether country.Name, country.Continent",
            "select sum(country.SurfaceArea) dependant on whether country.SurfaceArea is country.Name",
            "select sum(country.SurfaceArea) dependant on whether country.SurfaceArea is derived from country.Name",
            "select sum(country.SurfaceArea) dependant on whether country.SurfaceArea is in country.Continent",
            "select sum(country.SurfaceArea) dependant on whether country.SurfaceArea belongs to country.Name",
            "select sum(country.SurfaceArea) dependant on whether country.SurfaceArea is country.IndepYear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: give the total surface area covered by Asian countries or European ones., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the average GNP and total population of all nations whose government is territories under the United States., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (United States), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (United States), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-AVERAGE(t2.c8), sum(t2.c6)",
            "SELECT-FROM-WHERE - AVG(t2.c8), sum(t2.c6)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AVG(t2.c8), sum(t2.c6)",
            "SELECT-FROM-WHERE-AGGREGATE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the average GNP and total population of all nations whose government is territories under the United States., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (United States), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (United States), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c8), sum(t2.c6)",
        "label": "select avg(t2.c8), sum(t2.c6)",
        "score": true,
        "real_pred": "select avg(country.GNP), sum(country.Population)",
        "real_label": "select avg(country.GNP), sum(country.Population)",
        "topk_preds": [
            "select avg(country.GNP), sum(country.Population)",
            "select avg(country.GNP), avg(country.Population)",
            "select avg(country.Population), avg(country.GNP)",
            "select avg(country.LifeExpectancy), sum(country.Population)",
            "select sum(country.Population), avg(country.GNP)",
            "select avg(country.IndepYear), sum(country.Population)",
            "select avg(country.GNP, sum(country.Population)",
            "select avg(country.SurfaceArea), sum(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the average GNP and total population of all nations whose government is territories under the United States., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (United States), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (United States), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the average GNP and total population in all nations whose government is United States' territory., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (United States), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (United States), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE - AVG(t2.c8), sum(t2.c6)",
            "SELECT-FROM-WHERE-AVG(t2.c8), sum(t2.c6)",
            "SELECT-FROM-WHERE-AVERAGE(t2.c8), sum(t2.c6)",
            "SELECT-FROM-WHERE, AVG(t2.c8), sum(t2.c6)",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the average GNP and total population in all nations whose government is United States' territory., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (United States), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (United States), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c8), sum(t2.c6)",
        "label": "select avg(t2.c8), sum(t2.c6)",
        "score": true,
        "real_pred": "select avg(country.GNP), sum(country.Population)",
        "real_label": "select avg(country.GNP), sum(country.Population)",
        "topk_preds": [
            "select avg(country.GNP), sum(country.Population)",
            "select avg(country.GNP), avg(country.Population)",
            "select avg(country.Population), avg(country.GNP)",
            "select avg(country.IndepYear), avg(country.GNP)",
            "select avg(country.LifeExpectancy), avg(country.Population)",
            "select avg(country.GNP), total(country.Population)",
            "select avg(country.GNP), min(country.Population)",
            "select avg(country.GNP), country.Population"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the average GNP and total population in all nations whose government is United States' territory., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (United States), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (United States), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: give me the mean GDP and population for countries considered to be part of the US., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2 (US)). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (GROUP BY-HAVING",
            "SELECT-FROM-WHERE (GROUP BY-HAVING)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: give me the mean GDP and population for countries considered to be part of the US., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2 (US)). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c8), avg(t2.c6)",
        "label": "select avg(t2.c8), sum(t2.c6)",
        "score": false,
        "real_pred": "select avg(country.GNP), avg(country.Population)",
        "real_label": "select avg(country.GNP), sum(country.Population)",
        "topk_preds": [
            "select avg(country.GNP), avg(country.Population)",
            "select avg(country.SurfaceArea), avg(country.Population)",
            "select avg(country.Population), avg(country.GNP)",
            "select avg(country.IndepYear), avg(country.Population)",
            "select avg(country.LifeExpectancy), avg(country.Population)",
            "select avg(country.GNPOld), avg(country.Population)",
            "select an avg(country.GNP), avg(country.Population)",
            "select avg(country.GNP, avg(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: give me the mean GDP and population for countries considered to be part of the US., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2 (US)). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Calculate the average GDP and the total population for those nations who consider themselves part of the United States' Territory., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (United States), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (United States), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE, AVG(t2.c8), sum(t2.c6)",
            "SELECT-FROM-WHERE - AVG(t2.c8), sum(t2.c6)",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Calculate the average GDP and the total population for those nations who consider themselves part of the United States' Territory., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (United States), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (United States), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c8), sum(t2.c6)",
        "label": "select avg(t2.c8), sum(t2.c6)",
        "score": true,
        "real_pred": "select avg(country.GNP), sum(country.Population)",
        "real_label": "select avg(country.GNP), sum(country.Population)",
        "topk_preds": [
            "select avg(country.GNP), sum(country.Population)",
            "select avg(country.SurfaceArea), sum(country.Population)",
            "select avg(country.Population), sum(country.Population)",
            "select avg(country.IndepYear), sum(country.Population)",
            "select avg(country.LifeExpectancy), sum(country.Population)",
            "select avg(country.GNPOld), sum(country.Population)",
            "select sum(country.Population), avg(country.GNP)",
            "select avg(country.GNP), avg(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Calculate the average GDP and the total population for those nations who consider themselves part of the United States' Territory., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (United States), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (United States), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give the average Gross National Product (GNP) and total population of countries that are considered U.S. territory., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-INCLUS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AVERAGE(t2.c8), sum(t2.c6)",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give the average Gross National Product (GNP) and total population of countries that are considered U.S. territory., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c8), sum(t2.c6)",
        "label": "select avg(t2.c8), sum(t2.c6)",
        "score": true,
        "real_pred": "select avg(country.GNP), sum(country.Population)",
        "real_label": "select avg(country.GNP), sum(country.Population)",
        "topk_preds": [
            "select avg(country.GNP), sum(country.Population)",
            "select avg(country.GNP), avg(country.Population)",
            "select avg(country.Population), avg(country.GNP)",
            "select sum(country.GNP), avg(country.GNP)",
            "select sum(country.Population), avg(country.GNP)",
            "select avg(country.LifeExpectancy), sum(country.Population)",
            "select avg(country.IndepYear), sum(country.Population)",
            "select avg(country.GNP, sum(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give the average Gross National Product (GNP) and total population of countries that are considered U.S. territory., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "city country",
            "sqlite_sequence country",
            "country countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Estimate the average income and total population for countries in which they are classified as U.S.Territory:., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Estimate the average income and total population for countries in which they are classified as U.S.Territory:., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c4), sum(t2.c6)",
        "label": "select avg(t2.c8), sum(t2.c6)",
        "score": false,
        "real_pred": "select avg(country.SurfaceArea), sum(country.Population)",
        "real_label": "select avg(country.GNP), sum(country.Population)",
        "topk_preds": [
            "select avg(country.SurfaceArea), sum(country.Population)",
            "select avg(country.Population), sum(country.Population)",
            "select avg(country.IndepYear), sum(country.Population)",
            "select avg(country.GNP), sum(country.Population)",
            "select avg(country.LifeExpectancy), sum(country.Population)",
            "select avg(country.SurfaceArea), avg(country.Population)",
            "select avg(country.Region), sum(country.Population)",
            "select avg(country.GNPOld), sum(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Estimate the average income and total population for countries in which they are classified as U.S.Territory:., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "sqlite_sequence country",
            "country countrylanguage",
            "city country",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Determine the mean gross national product (GNP) and total population of the countries listed as US territories., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2 (US)). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Determine the mean gross national product (GNP) and total population of the countries listed as US territories., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2 (US)). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c8), sum(t2.c6)",
        "label": "select avg(t2.c8), sum(t2.c6)",
        "score": true,
        "real_pred": "select avg(country.GNP), sum(country.Population)",
        "real_label": "select avg(country.GNP), sum(country.Population)",
        "topk_preds": [
            "select avg(country.GNP), sum(country.Population)",
            "select avg(country.GNP), avg(country.Population)",
            "select avg(country.Population), avg(country.GNP)",
            "select avg(country.LifeExpectancy), sum(country.Population)",
            "select an avg(country.GNP), sum(country.Population)",
            "select avg(country.IndepYear), sum(country.Population)",
            "select sum(country.GNP), avg(country.GNP)",
            "select avg(country.GNP), sum(country.Population)."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Determine the mean gross national product (GNP) and total population of the countries listed as US territories., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2 (US)). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of types of government on African countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (count(distinct t2.c11)",
            "SELECT-FROM-WHERE (count(distinct t2.c1)",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE(count(distinct t2.c11)",
            "SELECT-FROM-WHERE (count(distinct t2.c11",
            "SELECT-FROM-WHERE(count(distinct t2.c1)",
            "SELECT-FROM-WHERE-COUNT(distinct t2.c11)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of types of government on African countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(distinct t2.c11)",
        "label": "select count(distinct t2.c11)",
        "score": true,
        "real_pred": "select count(distinct country.GovernmentForm)",
        "real_label": "select count(distinct country.GovernmentForm)",
        "topk_preds": [
            "select count(distinct country.GovernmentForm)",
            "select count(distinct country.Name)",
            "select count(distinct country.GovernmentForm",
            "select count(distinct country.LocalName)",
            "select count(distinct country.IndepYear)",
            "select count(distinct country.GNPOld)",
            "select count(distinct country.LifeExpectancy)",
            "select count(distinct t2.c)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of types of government on African countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the number of African governments types., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (count(distinct t2.c11)",
            "SELECT-FROM-WHERE-NUM(t2.c11",
            "SELECT-FROM-WHERE-NUM(t2.c11)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE (count(distinct t2.c11",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the number of African governments types., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(distinct t2.c11)",
        "score": false,
        "real_pred": "select count(*)",
        "real_label": "select count(distinct country.GovernmentForm)",
        "topk_preds": [
            "select count(*)",
            "select count(distinct country.GovernmentForm)",
            "select count(distinct country.Name)",
            "select count(distinct country.GovernmentForm",
            "select count(distinct country.IndepYear)",
            "select count(distinct country.LocalName)",
            "select count(distinct country.GNPOld)",
            "select count(country.GovernmentForm)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the number of African governments types., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Total numbers of language spoken on Aruban islands., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Aruba), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (Aruba), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE/GROUP BY",
            "SELECT-FROM-WHERE (t3.c1)",
            "SELECT-FROM-WHERE (count(t3.c1)",
            "SELECT-FROM-WHERE (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Total numbers of language spoken on Aruban islands., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Aruba), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (Aruba), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(t3.c1)",
        "score": false,
        "real_pred": "select count(*)",
        "real_label": "select count(countrylanguage.Language)",
        "topk_preds": [
            "select count(*)",
            "select count(distinct countrylanguage.Language)",
            "select count(countrylanguage.Language)",
            "select count(speechcount(distinct countrylanguage.Language)",
            "select count(count(distinct countrylanguage.Language)",
            "select sum(countrylanguage.Language)",
            "select count(speechcount(*)",
            "select count(speechcount(countrylanguage.Language)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Total numbers of language spoken on Aruban islands., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Aruba), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (Aruba), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For how many official languages does Afghan speak., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (count(distinct t3.c2)",
            "SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For how many official languages does Afghan speak., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(distinct t3.c2)",
        "label": "select count(*)",
        "score": false,
        "real_pred": "select count(distinct countrylanguage.IsOfficial)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(distinct countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.Language)",
            "select count(countrylanguage.IsOfficial)",
            "select count(count(distinct countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.CountryCode)",
            "select count(count(distinct countrylanguage.Language)",
            "select count(distinct countrylanguage.IsOfficial).",
            "select count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For how many official languages does Afghan speak., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t2 t3",
        "score": false,
        "real_pred": "countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "country countrylanguage",
            "sqlite_sequence countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which languages is the spoken only one country in republican government?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which languages is the spoken only one country in republican government?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, country.LocalName",
            "select countrylanguage.Language, country.Capital",
            "select countrylanguage.Language, country.GovernmentForm",
            "select countrylanguage.Language, country.Code",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.Language, country.HeadOfState",
            "select countrylanguage.Language, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which languages is the spoken only one country in republican government?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the languages that are only used by one country with a republican form of government., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ON-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ON-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-CHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the languages that are only used by one country with a republican form of government., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, country.GovernmentForm",
            "select countrylanguage.Language, country.LocalName",
            "select countrylanguage.Language, country.Capital",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.Language, country.Code",
            "select countrylanguage.Language, country.HeadOfState",
            "select countrylanguage.Language, country.Code2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the languages that are only used by one country with a republican form of government., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The languages that are only used by a single country with a republican government., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-CLIENT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The languages that are only used by a single country with a republican government., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, country.LocalName",
            "select countrylanguage.Language, country.GovernmentForm",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.Language, country.Capital",
            "select countrylanguage.Language, country.Code",
            "select distinct countrylanguage.Language",
            "select countrylanguage.Language, country.HeadOfState"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The languages that are only used by a single country with a republican government., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "city country countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all the countries whose surface areas are larger than that of any European country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all the countries whose surface areas are larger than that of any European country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.SurfaceArea",
            "select country.Name, country.Continent",
            "select country.Name, country.Region",
            "select country.Name, country.Population",
            "select country.Code, country.Name",
            "select country.Name, country.IndepYear",
            "select country.Name, country.Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all the countries whose surface areas are larger than that of any European country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many countries have a greater surface area than European countries?., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-NUMBER",
            "SELECT-FROM-WHERE count(*)",
            "SELECT-FROM-WHERE-GROUP BY HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many countries have a greater surface area than European countries?., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select t2.c1",
        "score": false,
        "real_pred": "select count(*)",
        "real_label": "select country.Name",
        "topk_preds": [
            "select count(*)",
            "select count(*), country.Name",
            "select count(*), country.Name, country.SurfaceArea",
            "select count(*), country.Code",
            "select count(*), country.Code, country.Name",
            "select count(*), country.Name, country.Region",
            "select count(*) the SELECT-FROM-WHERE",
            "select count(*), country.Name - country.SurfaceArea"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many countries have a greater surface area than European countries?., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which nations have an land area bigger than that of any European nation?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-INSERT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which nations have an land area bigger than that of any European nation?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.SurfaceArea",
            "select country.Name, country.Region",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Name, country.Code",
            "select country.Name, country.IndepYear",
            "select distinct country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which nations have an land area bigger than that of any European nation?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the countries which have bigger area tham that of any European country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the countries which have bigger area tham that of any European country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Region",
            "select country.Name, country.SurfaceArea",
            "select country.Name, country.Code",
            "select country.Name, country.Population",
            "select country.Code, country.Name",
            "select country.Name, country.IndepYear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the countries which have bigger area tham that of any European country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which countries have an area larger than that of any European country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which countries have an area larger than that of any European country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Region",
            "select country.Name, country.SurfaceArea",
            "select country.Name, country.Continent",
            "select country.Code, country.Name",
            "select country.Name, country.Population",
            "select country.Name, country.Code",
            "select country.Name, country.IndepYear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which countries have an area larger than that of any European country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the countries whose landmass is larger than that of any European nation., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the countries whose landmass is larger than that of any European nation., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.SurfaceArea",
            "select country.Name, country.Continent",
            "select country.Name, country.Region",
            "select country.Name, country.Code",
            "select country.Name, country.Population",
            "select country.Name, country.IndepYear",
            "select country.Code, country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the countries whose landmass is larger than that of any European nation., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the countries which are larger than the biggest European country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the countries which are larger than the biggest European country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Code",
            "select country.Name, country.Region",
            "select country.Name, country.SurfaceArea",
            "select country.Name, country.Population",
            "select country.Name, country.Capital",
            "select country.Code, country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the countries which are larger than the biggest European country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the countries whose area exceeds that of any European country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the countries whose area exceeds that of any European country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.SurfaceArea",
            "select country.Name, country.Continent",
            "select country.Name, country.Region",
            "select country.Name, country.Code",
            "select country.Name, country.Population",
            "select country.Name, country.IndepYear",
            "select country.Code, country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the countries whose area exceeds that of any European country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the name of the country greater than the European countries in size., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the name of the country greater than the European countries in size., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Region",
            "select country.Name, country.Continent",
            "select country.Name, country.Capital",
            "select country.Name, country.SurfaceArea",
            "select country.Name, country.Code",
            "select country.Name, country.Population",
            "select country.Name, country.LocalName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the name of the country greater than the European countries in size., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "city country",
            "",
            "sqlite_sequence country",
            "country countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the countries from which an area is larger than all that of all European nations?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the countries from which an area is larger than all that of all European nations?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Region",
            "select country.Name, country.Continent",
            "select country.Name, country.SurfaceArea",
            "select country.Name, country.Capital",
            "select country.Name, country.Population",
            "select distinct country.Name",
            "select country.Code, country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the countries from which an area is larger than all that of all European nations?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the list of African countries with less population than any Asian country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-COMPARE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the list of African countries with less population than any Asian country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Code, country.Name",
            "select country.Name, country.Continent, country.Population",
            "select country.Name, country.Continent, min(country.Population)",
            "select country.Name, country.Population",
            "select country.Code, country.Name, country.Continent",
            "select country.Name, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the list of African countries with less population than any Asian country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the African nations whose populations total less than the populations of all Asian nations., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the African nations whose populations total less than the populations of all Asian nations., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Continent, sum(country.Population)",
            "select country.Name, country.Population",
            "select country.Code, country.Name",
            "select country.Name, country.Continent, country.Population",
            "select country.Name, country.Continent, min(country.Population)",
            "select country.Name, country.Continent, max(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the African nations whose populations total less than the populations of all Asian nations., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the African countries whose populations are less than any Asian country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the African countries whose populations are less than any Asian country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Code, country.Name",
            "select country.Name, country.Continent, country.Population",
            "select country.Name, country.Continent, min(country.Population)",
            "select country.Name, country.Population",
            "select distinct country.Name",
            "select country.Code, country.Name, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the African countries whose populations are less than any Asian country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the African countries that have a population less than any Asian country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the African countries that have a population less than any Asian country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Code, country.Name",
            "select distinct country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Region",
            "select country.Name (country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the African countries that have a population less than any Asian country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the name of African countries that have lesser population than any Asian country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the name of African countries that have lesser population than any Asian country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Name, country.Region",
            "select country.Name (country.Code)",
            "select country.Name (country.Population)",
            "select country.Name, country.IndepYear",
            "select country.Name, country.Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the name of African countries that have lesser population than any Asian country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the list of African countries with smaller populations than that of any Asian country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the list of African countries with smaller populations than that of any Asian country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Code, country.Name",
            "select country.Name, country.Continent, country.Population",
            "select country.Name, country.Continent, min(country.Population)",
            "select country.Code, country.Name, country.Continent",
            "select distinct country.Name",
            "select country.Name, country.Population"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the list of African countries with smaller populations than that of any Asian country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all Asian countries whose populations are larger than all African ones., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all Asian countries whose populations are larger than all African ones., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Code, country.Name",
            "select distinct country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Name",
            "select country.Name, country.Region"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all Asian countries whose populations are larger than all African ones., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the list of Asian countries whose populations are larger than those of any African countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the list of Asian countries whose populations are larger than those of any African countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Code, country.Name",
            "select country.Name, country.Continent, max(country.Population)",
            "select country.Name, country.Continent, country.Population",
            "select distinct country.Name",
            "select country.Name, country.Population",
            "select country.Name, country.Continent, min(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the list of Asian countries whose populations are larger than those of any African countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the different countries from Asia that have a larger population than any African country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the different countries from Asia that have a larger population than any African country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select distinct t2.c1",
        "label": "select t2.c1",
        "score": false,
        "real_pred": "select distinct country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select distinct country.Name",
            "select country.Name",
            "select distinct country.Name, country.Continent",
            "select country.Name, country.Continent",
            "select distinct country.Name, country.Continent, country.Population",
            "select distinct country.Name delimited, country.Continent",
            "select distinct country.Name, country.Population",
            "select distinct country.Name, country.Continent, country.Region"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the different countries from Asia that have a larger population than any African country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: In terms of population show me which Asian country is larger than any African country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-T2.C1",
            "SELECT-FROM-WHERE-C1"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: In terms of population show me which Asian country is larger than any African country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Code, country.Name",
            "select country.Name, country.Region",
            "select country.Name, country.IndepYear",
            "select country.Name, country.Code",
            "select country.Name, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: In terms of population show me which Asian country is larger than any African country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the Asian countries whose populations are larger than that of any African country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the Asian countries whose populations are larger than that of any African country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select distinct country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Region",
            "select country.Name, country.IndepYear",
            "select country.Name de country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the Asian countries whose populations are larger than that of any African country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of the Asian countries whose populations are larger than those of any African country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of the Asian countries whose populations are larger than those of any African country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Name, country.Region",
            "select country.Name, country.IndepYear",
            "select country.Name (country.Population)",
            "select country.Name, country.SurfaceArea",
            "select country.Name, country.LifeExpectancy"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of the Asian countries whose populations are larger than those of any African country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find out which Asian countries have more than any African country's population size., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find out which Asian countries have more than any African country's population size., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Code, country.Name",
            "select country.Name, country.Region",
            "select distinct country.Name",
            "select country.Name de country.Continent",
            "select country.Name, country.IndepYear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find out which Asian countries have more than any African country's population size., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of Asian nations that surpass African nations in population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C1",
            "SELECT-FROM-WHERE-T2.C1"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of Asian nations that surpass African nations in population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Name, country.Region",
            "select country.Name, country.IndepYear",
            "select country.Name, country.Code",
            "select country.Name, country.SurfaceArea",
            "select country.Name, country.LifeExpectancy"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of Asian nations that surpass African nations in population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            "city country"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me cities in European countries where English is not an official language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE.EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2014EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me cities in European countries where English is not an official language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select distinct t0.c1",
        "score": false,
        "real_pred": "select city.Name",
        "real_label": "select distinct city.Name",
        "topk_preds": [
            "select city.Name",
            "select city.Name, country.Continent",
            "select city.ID, city.Name",
            "select city.Name, country.Name",
            "select city.Name, country.Code",
            "select city.Name, country.Code2",
            "select city.ID, country.Name",
            "select distinct city.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me cities in European countries where English is not an official language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t0 t2 t3",
        "label": "t0 t2 t3",
        "score": true,
        "real_pred": "city country countrylanguage",
        "real_label": "city country countrylanguage",
        "topk_preds": [
            "city country countrylanguage",
            "",
            "",
            "city sqlite_sequence country countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show different names of Asian cities with Chinese as an official language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Chinese), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show different names of Asian cities with Chinese as an official language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Chinese), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select distinct t0.c1",
        "label": "select distinct t0.c1",
        "score": true,
        "real_pred": "select distinct city.Name",
        "real_label": "select distinct city.Name",
        "topk_preds": [
            "select distinct city.Name",
            "select distinct city.Name, country.Capital",
            "select distinct city.Name, countrylanguage.IsOfficial",
            "select city.Name",
            "select different city.Name",
            "select distinct city.Name, countrylanguage.Language",
            "select distinct city.Name, countrylanguage.CountryCode",
            "select distinct city.Name, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show different names of Asian cities with Chinese as an official language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Chinese), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t0 t2 t3",
        "label": "t0 t2 t3",
        "score": true,
        "real_pred": "city country countrylanguage",
        "real_label": "city country countrylanguage",
        "topk_preds": [
            "city country countrylanguage",
            "",
            "",
            "city sqlite_sequence country countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show names of countries who speak two or more languages and their number., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDINANCE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-COMPLEXITY-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVINGs-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show names of countries who speak two or more languages and their number., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, count(*)",
        "label": "select count(t3.c1), t2.c1",
        "score": false,
        "real_pred": "select country.Name, count(*)",
        "real_label": "select count(countrylanguage.Language), country.Name",
        "topk_preds": [
            "select country.Name, count(*)",
            "select country.Name, count(distinct countrylanguage.Language)",
            "select country.Name, count(distinct countrylanguage.CountryCode)",
            "select country.Name, count(distinct country.Code)",
            "select country.Name, count(distinct country.Name)",
            "select country.Name, count(count(distinct countrylanguage.Language)",
            "select country.Name, count(distinct country.Continent)",
            "select country.Name, count(countrylanguage.Language)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show names of countries who speak two or more languages and their number., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "",
            "sqlite_sequence countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of countries that can speak two or more languages and how many languages they can speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-GIFT-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of countries that can speak two or more languages and how many languages they can speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, count(distinct t3.c1)",
        "label": "select count(t3.c1), t2.c1",
        "score": false,
        "real_pred": "select country.Name, count(distinct countrylanguage.Language)",
        "real_label": "select count(countrylanguage.Language), country.Name",
        "topk_preds": [
            "select country.Name, count(distinct countrylanguage.Language)",
            "select country.Name, count(distinct country.Name)",
            "select country.Name, count(countrylanguage.Language)",
            "select country.Name, count(*)",
            "select count(distinct country.Name), country.Name",
            "select country.Name, count(count(distinct countrylanguage.Language)",
            "select country.Name, count(distinct countrylanguage.IsOfficial)",
            "select country.Name, count(distinct countrylanguage.Language )"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of countries that can speak two or more languages and how many languages they can speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "",
            "",
            "city country countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of countries that speak two or more languages, as well as how many languages they speak., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of countries that speak two or more languages, as well as how many languages they speak., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, count(distinct t3.c1)",
        "label": "select count(t3.c1), t2.c1",
        "score": false,
        "real_pred": "select country.Name, count(distinct countrylanguage.Language)",
        "real_label": "select count(countrylanguage.Language), country.Name",
        "topk_preds": [
            "select country.Name, count(distinct countrylanguage.Language)",
            "select country.Name, count(distinct country.Name)",
            "select country.Name, count(*)",
            "select country.Name, count(countrylanguage.Language)",
            "select country.Name, count(count(distinct countrylanguage.Language)",
            "select country.Name, count(distinct countrylanguage.IsOfficial)",
            "select country.Name, count(distinct countrylanguage.Language )",
            "select country.Name, count(distinct countrylanguage.Language)."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of countries that speak two or more languages, as well as how many languages they speak., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the countries that speak two or more languages and how many language they speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM for-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the countries that speak two or more languages and how many language they speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, count(distinct t3.c1)",
        "label": "select count(t3.c1), t2.c1",
        "score": false,
        "real_pred": "select country.Name, count(distinct countrylanguage.Language)",
        "real_label": "select count(countrylanguage.Language), country.Name",
        "topk_preds": [
            "select country.Name, count(distinct countrylanguage.Language)",
            "select country.Name, count(*)",
            "select country.Name, count(distinct country.Name)",
            "select country.Name, count(countrylanguage.Language)",
            "select count(distinct country.Name), country.Name",
            "select country.Name, count(distinct countrylanguage.IsOfficial)",
            "select country.Name, count(distinct countrylanguage.Language).",
            "select country.Name, count(distinct countrylanguage.Language"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the countries that speak two or more languages and how many language they speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "",
            "",
            "",
            "",
            "city country countrylanguage",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names and the areas of the countries that have the top five largest areas., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT.",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names and the areas of the countries that have the top five largest areas., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, t2.c4",
        "label": "select t2.c1, t2.c4",
        "score": true,
        "real_pred": "select country.Name, country.SurfaceArea",
        "real_label": "select country.Name, country.SurfaceArea",
        "topk_preds": [
            "select country.Name, country.SurfaceArea",
            "select country.Name, country.Region",
            "select country.Name, country.SurfaceArea\"",
            "select country.Name, country.SurfaceArea)",
            "select country.Name, country.SurfaceArea.",
            "select country.Name, country.SurfaceArea,",
            "select country.Name, country.Continent",
            "select country.Name, country.Population"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names and the areas of the countries that have the top five largest areas., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all names and areas of countries with the list of five largest in terms of area., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all names and areas of countries with the list of five largest in terms of area., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, t2.c4",
        "label": "select t2.c1, t2.c4",
        "score": true,
        "real_pred": "select country.Name, country.SurfaceArea",
        "real_label": "select country.Name, country.SurfaceArea",
        "topk_preds": [
            "select country.Name, country.SurfaceArea",
            "select country.Name, country.SurfaceArea, country.Capital",
            "select country.Name, country.SurfaceArea, country.IndepYear",
            "select country.Name, country.SurfaceArea, country.Region",
            "select country.Name, country.SurfaceArea, country.Name5",
            "select country.Name, country.SurfaceArea, country.Code",
            "select country.Name, country.SurfaceArea)",
            "select country.Name, country.SurfaceArea,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all names and areas of countries with the list of five largest in terms of area., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the names and sizes of the five largest countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the names and sizes of the five largest countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, t2.c4",
        "label": "select t2.c1, t2.c4",
        "score": true,
        "real_pred": "select country.Name, country.SurfaceArea",
        "real_label": "select country.Name, country.SurfaceArea",
        "topk_preds": [
            "select country.Name, country.SurfaceArea",
            "select country.Name, country.SurfaceArea, country.Population",
            "select country.Name, country.SurfaceArea, country.IndepYear",
            "select country.Name, country.SurfaceArea,",
            "select country.Name, country.SurfaceArea\"",
            "select country.Name, country.SurfaceArea)",
            "select country.Name, country.Region",
            "select country.Name, country.SurfaceArea."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the names and sizes of the five largest countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the name of countries that have the top three populations., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-THREE-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT.",
            "SELECT-FROM-ORDER BY-LIMIT-THREE-INTERSECT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the name of countries that have the top three populations., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.Code",
            "select country.Name, country.Population",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.LocalName",
            "select country.Name, country.Code2",
            "select country.Name, country.Region"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the name of countries that have the top three populations., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List three countries with the largest populations., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List three countries with the largest populations., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Code",
            "select country.Name, country.Population",
            "select country.Name, country.Capital",
            "select country.Name, country.HeadOfState",
            "select country.Code, country.Name",
            "select country.Name, country.Region",
            "select country.Name, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List three countries with the largest populations., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name the top three most populous countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT.",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name the top three most populous countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Code",
            "select country.Name, country.Population",
            "select country.Name, country.Region",
            "select country.Name, country.Continent",
            "select country.Name, country.Code2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name the top three most populous countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of countries whose populations are the top three in the world., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of countries whose populations are the top three in the world., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.Population",
            "select country.Name, country.LocalName",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Code",
            "select country.Name, country.Region",
            "select country.Name, country.Code2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of countries whose populations are the top three in the world., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the countries with the top three largest populations., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT.",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY - LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the countries with the top three largest populations., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.Code",
            "select country.Name, country.LocalName",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Population",
            "select country.Name, country.Region",
            "select country.Name, country.Code2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the countries with the top three largest populations., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The top three most populous countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The top three most populous countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Population",
            "select country.Name, country.Code",
            "select country.Name, country.Region",
            "select country.Code, country.Name",
            "select country.Name, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The top three most populous countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of the three largest countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-THREE-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of the three largest countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.HeadOfState",
            "select country.Name (country.Code)",
            "select country.Name (country.Population)",
            "select country.Name, country.Population",
            "select country.Name (country.Capital)",
            "select country.Name, country.Code2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of the three largest countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find names of the three countries with the highest population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT.",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY - LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find names of the three countries with the highest population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.Code",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Population",
            "select country.Name, country.Region",
            "select country.Name, country.Code2",
            "select country.Name, country.LocalName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find names of the three countries with the highest population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the top three countries in order of population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SQL-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SECRET-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (GROUP BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SECRET-SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the top three countries in order of population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Population",
            "select country.Code, country.Name",
            "select country.Name, country.Code",
            "select country.Name (ORDER BY-LIMIT)",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Capital",
            "select country.Name, country.Region"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the top three countries in order of population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The top three countries in population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The top three countries in population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Population",
            "select country.Name, country.Code",
            "select country.Name, country.Capital",
            "select country.Code, country.Name",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Region",
            "select country.Name, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The top three countries in population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the three most populated countries and return their names., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the three most populated countries and return their names., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Code",
            "select country.Name, country.Capital",
            "select country.Name, country.Region",
            "select country.Name, country.Population",
            "select country.Name, country.LocalName",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the three most populated countries and return their names., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The names of the three most populated countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-THREE-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The names of the three most populated countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.LocalName",
            "select country.Name, country.Population",
            "select country.Name (country.Population)",
            "select country.Name, country.Code2",
            "select country.Name (country.Code)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The names of the three most populated countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the most populated three countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the most populated three countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.Population",
            "select country.Name, country.HeadOfState",
            "select country.Code, country.Name",
            "select country.Name, country.Code",
            "select country.Name, country.Region",
            "select country.Name, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the most populated three countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the names of the nations with the three lowest population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the names of the nations with the three lowest population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.LocalName",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Population",
            "select country.Name, country.Code2",
            "select country.Name, country.Code",
            "select country.Name, country.GNPOld"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the names of the nations with the three lowest population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Names of the nations with the three lowest population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Names of the nations with the three lowest population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.LocalName",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Population",
            "select country.Name, country.Code2",
            "select country.Name, country.Code",
            "select country.Name, country.GNPOld"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Names of the nations with the three lowest population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of the countries that have the three lowest population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of the countries that have the three lowest population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.Code",
            "select country.Name, country.Population",
            "select country.Name, country.LocalName",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Code2",
            "select country.Name, country.Region"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of the countries that have the three lowest population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the names of the three countries with the fewest citizens in them., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-THREE-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-THREE-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the names of the three countries with the fewest citizens in them., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.LocalName",
            "select country.Name, country.Population",
            "select country.Name (country.Population)",
            "select country.Name, country.Code2",
            "select country.Name, country.Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the names of the three countries with the fewest citizens in them., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many Asian countries are there?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-NUM(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE Zahl(*)",
            "SELECT-FROM-WHERE-COUNT(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many Asian countries are there?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), country.Name",
            "select count(*), country.Code",
            "select count(*) dependant on country.Name",
            "select count(*), country.Name",
            "select count(*), country.Capital",
            "select count(*), country.Code2",
            "select count(*), country.Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many Asian countries are there?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many different Asian countries there are?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-NUM(*)",
            "SELECT-FROM-WHERE-NUM(t2.c1)",
            "SELECT-FROM-WHERE-NUM(count(*)",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE(count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many different Asian countries there are?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(distinct country.Name)",
            "select count(count(distinct country.Name)",
            "select count(distinct country.Code)",
            "select count(country.Name)",
            "select count(count(*)",
            "select count(distinct country.Name",
            "select count(different country.Name)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many different Asian countries there are?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the list of countries located on European continent that have a population equal to 80000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the list of countries located on European continent that have a population equal to 80000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Code, country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Continent, country.Region",
            "select country.Name, country.Continent, country.Population",
            "select country.Code, country.Name, country.Continent",
            "select country.Name, country.Continent, min(country.Population)",
            "select country.Name, country.Continent, max(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the list of countries located on European continent that have a population equal to 80000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the total populations (and average areas) of countries in the continent of North America whose area is bigger than 3,000 km2., database: Database: world_1. t0: city(c0: id, c1: name (Americana), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (North America), c3: region (North America), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AGGRESS-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the total populations (and average areas) of countries in the continent of North America whose area is bigger than 3,000 km2., database: Database: world_1. t0: city(c0: id, c1: name (Americana), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (North America), c3: region (North America), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t2.c6), avg(t2.c6)",
        "label": "select sum(t2.c6), avg(t2.c4)",
        "score": false,
        "real_pred": "select sum(country.Population), avg(country.Population)",
        "real_label": "select sum(country.Population), avg(country.SurfaceArea)",
        "topk_preds": [
            "select sum(country.Population), avg(country.Population)",
            "select sum(country.Population), avg(country.SurfaceArea)",
            "select country.Population, avg(country.SurfaceArea)",
            "select total(country.Population), avg(country.Population)",
            "select count(*), avg(country.Population)",
            "select sum(country.Population), avg(country.IndepYear)",
            "select avg(country.Population), sum(country.Population)",
            "select sum(country.Population), avg(country.GNP)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the total populations (and average areas) of countries in the continent of North America whose area is bigger than 3,000 km2., database: Database: world_1. t0: city(c0: id, c1: name (Americana), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (North America), c3: region (North America), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Determine the total population and average surface area for countries in North America that have a surface area greater than 3,000., database: Database: world_1. t0: city(c0: id, c1: name (Americana), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (North America), c3: region (North America), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Determine the total population and average surface area for countries in North America that have a surface area greater than 3,000., database: Database: world_1. t0: city(c0: id, c1: name (Americana), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (North America), c3: region (North America), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t2.c6), avg(t2.c4)",
        "label": "select sum(t2.c6), avg(t2.c4)",
        "score": true,
        "real_pred": "select sum(country.Population), avg(country.SurfaceArea)",
        "real_label": "select sum(country.Population), avg(country.SurfaceArea)",
        "topk_preds": [
            "select sum(country.Population), avg(country.SurfaceArea)",
            "select avg(country.Population), sum(country.Population)",
            "select country.Population, avg(country.SurfaceArea)",
            "select total(country.Population), avg(country.SurfaceArea)",
            "select sum(country.Population), avg(country.Population)",
            "select sum(country.Population),  avg(country.SurfaceArea)",
            "select sum(country.Population), avg(country.GNP)",
            "select sum(country.Population), avg(country.SurfaceArea)."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Determine the total population and average surface area for countries in North America that have a surface area greater than 3,000., database: Database: world_1. t0: city(c0: id, c1: name (Americana), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (North America), c3: region (North America), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give the total population and average surface area corresponding to countries in the North America that have a surface area larger than 3K., database: Database: world_1. t0: city(c0: id, c1: name (Americana), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (North America), c3: region (North America), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give the total population and average surface area corresponding to countries in the North America that have a surface area larger than 3K., database: Database: world_1. t0: city(c0: id, c1: name (Americana), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (North America), c3: region (North America), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t2.c6), avg(t2.c4)",
        "label": "select sum(t2.c6), avg(t2.c4)",
        "score": true,
        "real_pred": "select sum(country.Population), avg(country.SurfaceArea)",
        "real_label": "select sum(country.Population), avg(country.SurfaceArea)",
        "topk_preds": [
            "select sum(country.Population), avg(country.SurfaceArea)",
            "select sum(country.Population), avg(country.Population)",
            "select avg(country.Population), sum(country.Population)",
            "select country.Population, avg(country.SurfaceArea)",
            "select sum(country.Population), avg(country.GNP)",
            "select total(country.Population), avg(country.SurfaceArea)",
            "select sum(country.Population), avg(country.IndepYear)",
            "select count(*), avg(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give the total population and average surface area corresponding to countries in the North America that have a surface area larger than 3K., database: Database: world_1. t0: city(c0: id, c1: name (Americana), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (North America), c3: region (North America), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all cities whose population is between 160,000 and 900,000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all cities whose population is between 160,000 and 900,000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select city.Name",
        "real_label": "select city.Name",
        "topk_preds": [
            "select city.Name",
            "select city.ID, city.Name",
            "select city.Name, city.ID",
            "select city.Name, city.District",
            "select city.Name, city.CountryCode",
            "select city.Name, city.Population",
            "select city.Name, t0.c6",
            "select city.Name, city.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all cities whose population is between 160,000 and 900,000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "city",
        "real_label": "city",
        "topk_preds": [
            "city",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the names of cities in the range 160,000 and 900,000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the names of cities in the range 160,000 and 900,000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select city.Name",
        "real_label": "select city.Name",
        "topk_preds": [
            "select city.Name",
            "select city.Name, city.District",
            "select city.ID, city.Name",
            "select city.Name, city.CountryCode",
            "select city.Name, city.Population",
            "select t0, city.Name",
            "select city.Name, t0.c6",
            "select city.Name, city.ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the names of cities in the range 160,000 and 900,000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "city",
        "real_label": "city",
        "topk_preds": [
            "city",
            "",
            "city country",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of cities which have a population of 160,000-900,000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-INSERT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of cities which have a population of 160,000-900,000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select city.Name",
        "real_label": "select city.Name",
        "topk_preds": [
            "select city.Name",
            "select city.Name, city.District",
            "select city.ID, city.Name",
            "select city.Name, city.District, city.Population",
            "select city.Name, city.CountryCode",
            "select t0, city.Name",
            "select city.Name (ref. city.CountryCode)",
            "select city.Name, city.Population"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of cities which have a population of 160,000-900,000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "city",
        "real_label": "city",
        "topk_preds": [
            "city",
            "",
            "",
            "",
            "city country",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Names of conductors whose nationalities are not US., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Names of conductors whose nationalities are not US., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name - conductor.Nationality",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name (not conductor.Age)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Names of conductors whose nationalities are not US., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "conductor performance"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of conductors who are non-US nationalities?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of conductors who are non-US nationalities?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name - conductor.Nationality",
            "select conductor.Name (or conductor.Nationality)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of conductors who are non-US nationalities?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name the Conductors from countries other than the United States., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name the Conductors from countries other than the United States., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Conductor_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name the Conductors from countries other than the United States., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which are the conductors whose nationalities are not from US?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which are the conductors whose nationalities are not from US?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select conductor.Conductor_ID",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Conductor_ID",
            "select conductor.Conductor_ID, conductor.Nationality",
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select distinct conductor.Name, conductor.Nationality",
            "select distinct conductor.Conductor_ID",
            "select conductor.Conductor_ID, conductor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which are the conductors whose nationalities are not from US?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the names of conductors whose nationalities are not from the United States (US)., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the names of conductors whose nationalities are not from the United States (US)., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name - conductor.Nationality",
            "select conductor.Name, conductor.Age",
            "select conductor.Name (or conductor.Nationality)",
            "select t0, conductor.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the names of conductors whose nationalities are not from the United States (US)., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give the names of conductors who do not have US nationality and return them., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give the names of conductors who do not have US nationality and return them., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Age",
            "select conductor.Name - conductor.Nationality",
            "select conductor.Name and conductor.Nationality",
            "select conductor.Name & conductor.Nationality",
            "select conductor.Name, conductor.Nationality,",
            "select conductor.Name "
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give the names of conductors who do not have US nationality and return them., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "conductor orchestra",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of conductors who do not have US nationality and return these names., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of conductors who do not have US nationality and return these names., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Age",
            "select conductor.Name - conductor.Nationality",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name, conductor.Nationality,",
            "select conductor.Name (not conductor.Age)",
            "select conductor.Name, conductor.Nationality-"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of conductors who do not have US nationality and return these names., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "conductor orchestra",
            "",
            "",
            "",
            "conductor performance",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the conductors who do not have US nationality and return these names., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the conductors who do not have US nationality and return these names., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Age",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name - conductor.Nationality",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name and conductor.Nationality"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the conductors who do not have US nationality and return these names., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the names of conductors that have not the US nationality and return these names., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the names of conductors that have not the US nationality and return these names., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Age",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name - conductor.Nationality",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name, conductor.Nationality,",
            "select conductor.Name, conductor.Nationality-"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the names of conductors that have not the US nationality and return these names., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "conductor orchestra",
            "",
            "conductor orchestra performance",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the names of conductors who do not have US nationality and return these names., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the names of conductors who do not have US nationality and return these names., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Age",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name - conductor.Nationality",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name (not conductor.Age)",
            "select conductor.Name, conductor.Nationality,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the names of conductors who do not have US nationality and return these names., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "conductor orchestra",
            "",
            "",
            "conductor performance",
            "",
            "",
            "conductor show"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return names of conductors who does not have US nationality., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return names of conductors who does not have US nationality., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Name, conductor.Nationality, conductor.Age",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Age, conductor.Nationality",
            "select conductor.Name (syntax conductor.Age)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return names of conductors who does not have US nationality., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "conductor orchestra",
            "",
            "",
            "conductor orchestra performance",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the list containing all students in grade ten., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the list containing all students in grade ten., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select distinct t0.c1",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select distinct Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select distinct Highschooler.name",
            "select distinct Highschooler.name, Highschooler.grade",
            "select distinct Highschooler.name, Highschooler.ID",
            "select distinct Highschooler.name, t0.c3",
            "select Highschooler.name, Highschooler.grade",
            "select distinct Highschooler.name, t0.c6",
            "select distinct Highschooler.name, Highschooler.ID2",
            "select Highschooler.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the list containing all students in grade ten., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of all high schoolers in grade ten., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of all high schoolers in grade ten., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select distinct Highschooler.name",
            "select Highschooler.name (distinct Highschooler.grade)",
            "select distinct Highschooler.name, Highschooler.grade",
            "select Highschooler.name (or Highschooler.grade)",
            "select Highschooler.name - Highschooler.grade",
            "select Highschooler.name, Highschooler.ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of all high schoolers in grade ten., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of students in the 9th or 10th grade., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of students in the 9th or 10th grade., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Highschooler.ID",
            "select count(*), Highschooler.grade",
            "select count(*), Highschooler.name",
            "select Highschooler.ID, count(*)",
            "select count(*) in Highschooler.ID",
            "select count(*) the Highschooler.ID",
            "select count(*), Highschooler.ID2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of students in the 9th or 10th grade., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Determine the number of high schoolers in ninth grade and tenth grade., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Determine the number of high schoolers in ninth grade and tenth grade., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Highschooler.grade",
            "select count(*), t0.c9, Highschooler.name0",
            "select Highschooler.grade, count(*)",
            "select Highschooler.ID, count(*)",
            "select count(*), t0.c9, Highschooler.name0",
            "select count(*), Highschooler.name, Highschooler.grade",
            "select count(*), Highschooler.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Determine the number of high schoolers in ninth grade and tenth grade., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all grades that have four or more students in them., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all grades that have four or more students in them., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select Highschooler.grade",
        "real_label": "select Highschooler.grade",
        "topk_preds": [
            "select Highschooler.grade",
            "select Highschooler.grade, count(*)",
            "select Highschooler.grade, max(Highschooler.ID)",
            "select Highschooler.grade, t0.c3",
            "select Highschooler.grade, max(Highschooler.grade)",
            "select Highschooler.grade, max(t0.c4)",
            "select Highschooler.grade, count(Highschooler.ID)",
            "select Highschooler.grade del.icio.us"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all grades that have four or more students in them., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "Highschooler Likes",
            "",
            "Highschooler Friend",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all grade levels that have four or more students in them., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all grade levels that have four or more students in them., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select Highschooler.grade",
        "real_label": "select Highschooler.grade",
        "topk_preds": [
            "select Highschooler.grade",
            "select Highschooler.grade the SELECT-FROM-GROUP BY-HAVING",
            "select Highschooler.grade, count(*)",
            "select Highschooler.grade, t0.c3",
            "select Highschooler.grade, max(Highschooler.ID)",
            "select Highschooler.grade, count(*), t0.c3",
            "select Highschooler.grade, max(t0.c4)",
            "select Highschooler.grade, max(Highschooler.grade)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all grade levels that have four or more students in them., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "Highschooler Likes",
            "Highschooler Friend",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all grades in which there are at least four students., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-PROGRAM-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ISO-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all grades in which there are at least four students., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select Highschooler.grade",
        "real_label": "select Highschooler.grade",
        "topk_preds": [
            "select Highschooler.grade",
            "select Highschooler.grade, count(*)",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.grade, t0.c3",
            "select Highschooler.grade, at least four Highschooler.ID",
            "select Highschooler.grade, max(Highschooler.ID)",
            "select Highschooler.grade, max(Highschooler.grade)",
            "select Highschooler.grade, max(t0.c4)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all grades in which there are at least four students., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "",
            "Highschooler Friend",
            "Highschooler Likes",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show how many grades have four high school students or more., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM GROUP BY-HAVING",
            "SELECT-FROM quadruple-GROUP BY-HAVING",
            "SELECT-FROM quadruplets-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show how many grades have four high school students or more., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select count(distinct t0.c2)",
        "label": "select t0.c2",
        "score": false,
        "real_pred": "select count(distinct Highschooler.grade)",
        "real_label": "select Highschooler.grade",
        "topk_preds": [
            "select count(distinct Highschooler.grade)",
            "select count(*)",
            "select count(*), Highschooler.grade",
            "select count(Highschooler.grade)",
            "select Highschooler.grade",
            "select counts(distinct Highschooler.grade)",
            "select distinct Highschooler.grade",
            "select count(distinct Highschooler.grade),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show how many grades have four high school students or more., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the grades containing four or more high school students., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ISO-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups by-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the grades containing four or more high school students., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select Highschooler.grade",
        "real_label": "select Highschooler.grade",
        "topk_preds": [
            "select Highschooler.grade",
            "select Highschooler.grade, t0.c3",
            "select Highschooler.grade, count(*)",
            "select Highschooler.grade, four-student-gROUP BY-HAVING",
            "select Highschooler.grade, max(Highschooler.grade)",
            "select Highschooler.grade, Highschooler.name",
            "select Highschooler.grade, max(Highschooler.ID)",
            "select Highschooler.grade, four-student-c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the grades containing four or more high school students., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the grades that have four or more high schoolers., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNITED-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the grades that have four or more high schoolers., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select Highschooler.grade",
        "real_label": "select Highschooler.grade",
        "topk_preds": [
            "select Highschooler.grade",
            "select Highschooler.grade, count(*)",
            "select Highschooler.grade, t0.c3",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.grade, count(*), t0.c3",
            "select Highschooler.grade, max(Highschooler.grade)",
            "select Highschooler.grade, count(*), Highschooler.name",
            "select Highschooler.grade, count(*), Highschooler.ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the grades that have four or more high schoolers., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the grades where there are four or more high schoolers., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the grades where there are four or more high schoolers., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select Highschooler.grade",
        "real_label": "select Highschooler.grade",
        "topk_preds": [
            "select Highschooler.grade",
            "select Highschooler.grade, t0.c3",
            "select Highschooler.grade, count(*)",
            "select Highschooler.grade, Highschooler.name",
            "select distinct Highschooler.grade",
            "select Highschooler.grade, max(Highschooler.grade)",
            "select Highschooler.grade, t0.c4",
            "select Highschooler.grade, network_1.c1"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the grades where there are four or more high schoolers., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of high school students that have at least three friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAUSS-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of high school students that have at least three friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name (Highschooler.ID)",
            "select Highschooler.name (or Highschooler.grade)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of high school students that have at least three friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of high school students who have at least three friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of high school students who have at least three friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name (or Highschooler.grade)",
            "select Highschooler.name (Highschooler.ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of high school students who have at least three friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "",
            "",
            "",
            "",
            "",
            "",
            "Highschooler Friend Likes"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of high schoolers who have three or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of high schoolers who have three or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name (Highschooler.ID)",
            "select Highschooler.name (or Highschooler.grade)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of high schoolers who have three or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Tell us about the names of students from high schools that have at least three friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Tell us about the names of students from high schools that have at least three friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Friend.student_id",
            "select distinct Highschooler.name",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Friend.student_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Tell us about the names of students from high schools that have at least three friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of highschoolers that have 3+ friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of highschoolers that have 3+ friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name (Highschooler.ID)",
            "select Highschooler.name, t1.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of highschoolers that have 3+ friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the names of the students that have at least two likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups by-GROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the names of the students that have at least two likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Likes.student_id",
            "select Highschooler.name, Highschooler.grade",
            "select Likes.student_id, Highschooler.name",
            "select Highschooler.name (Highschooler.ID)",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, t0.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the names of the students that have at least two likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all students who have liked twice or more., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all students who have liked twice or more., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t2.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select Likes.student_id",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Likes.student_id",
            "select Likes.student_id, Likes.liked_id",
            "select Likes.student_id, count(*)",
            "select Likes.student_id, Highschooler.name",
            "select Likes.student_id, Likes.student_id",
            "select Likes.student_id, max(Likes.liked_id)",
            "select Likes.student_id, t2.c2",
            "select Likes.student_id, Likes.liked_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all students who have liked twice or more., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Likes",
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show students who has had two or more likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show students who has had two or more likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Likes.student_id",
            "select Likes.student_id",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, t0.c3",
            "select Highschooler.ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show students who has had two or more likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "Likes",
            "Friend Likes",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the list of students who have two or more likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the list of students who have two or more likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Likes.student_id",
            "select Highschooler.name, t0.c3",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name, Highschooler.ID2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the list of students who have two or more likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "",
            "Friend Likes",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Names of students with at least two likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Names of students with at least two likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Likes.student_id",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, t0.c3",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name (Highschooler.ID)",
            "select Highschooler.name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Names of students with at least two likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the name of students who have over two students., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the name of students who have over two students., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID, max(Highschooler.name)",
            "select Highschooler.name, Highschooler.ID, Highschooler.name",
            "select Highschooler.name, Highschooler.ID, Highschooler.grade",
            "select Highschooler.name, max(Highschooler.ID)",
            "select Highschooler.name, Highschooler.ID, min(Highschooler.name)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the name of students who have over two students., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0 t2",
        "score": false,
        "real_pred": "Highschooler",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler",
            "Highschooler Friend",
            "Highschooler Likes",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of students who have two or more likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of students who have two or more likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Likes.student_id",
            "select Highschooler.name, Highschooler.grade",
            "select Likes.student_id, Highschooler.name",
            "select Highschooler.name (Highschooler.ID)",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, Likes.liked_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of students who have two or more likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of students who have at least two likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAUSS-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of students who have at least two likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Likes.student_id",
            "select Highschooler.name, Highschooler.grade",
            "select Likes.student_id, Highschooler.name",
            "select Highschooler.name (Highschooler.ID)",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, t0.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of students who have at least two likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the names of students who have more than two likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the names of students who have more than two likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Likes.student_id",
            "select Highschooler.name, Highschooler.grade",
            "select Likes.student_id, Highschooler.name",
            "select Highschooler.name (Highschooler.ID)",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name, Highschooler.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the names of students who have more than two likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of students who have a grade higher than five and have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAG-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUPS BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of students who have a grade higher than five and have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, t0.c5",
            "select Highschooler.name, t1.c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of students who have a grade higher than five and have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of students who have more than five grades and have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING AND-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING/INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING-",
            "SELECT-FROM-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of students who have more than five grades and have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name (Highschooler.grade), Friend.friend_id",
            "select Highschooler.name, Highschooler.grade, Friend.friend_id",
            "select Highschooler.name, Highschooler.grade, Friend.friend_id",
            "select Highschooler.name, Highschooler.grade, Highschooler.name",
            "select Highschooler.name, Highschooler.grade, Highschooler.name",
            "select Highschooler.name (Highschooler.grade), Highschooler.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of students who have more than five grades and have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of students who have at least two friends and have grades higher than five., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-T0-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-CROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GRADE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of students who have at least two friends and have grades higher than five., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, t0.c5",
            "select Highschooler.name, Highschooler.ID",
            "select distinct Highschooler.name",
            "select Highschooler.name (or Highschooler.grade)",
            "select Highschooler.name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of students who have at least two friends and have grades higher than five., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "Highschooler Likes",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all students who have GPA above 5 and have at least two friend, and display their names., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all students who have GPA above 5 and have at least two friend, and display their names., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name, t0.c5",
            "select Highschooler.name, t0.c6",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, Highschooler.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all students who have GPA above 5 and have at least two friend, and display their names., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the names of the students who have a grade better than five and have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-COLLABORATION-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-COLLABORAT-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the names of the students who have a grade better than five and have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name (Highschooler.ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the names of the students who have a grade better than five and have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the list of students who has a grade above five and have at least two friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GEO-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUPS BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the list of students who has a grade above five and have at least two friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name, t0.c6",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, Highschooler.grade,",
            "select Highschooler.name & Highschooler.grade"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the list of students who has a grade above five and have at least two friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all the student names whose grade is higher than 5 and have at least two friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-CONSISTENT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUPS BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all the student names whose grade is higher than 5 and have at least two friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.grade, Friend.friend_id",
            "select Highschooler.name, Highschooler.grade, Friend.friend_id",
            "select Highschooler.name, Highschooler.grade, min(Friend.friend_id)",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.grade.c0",
            "select Highschooler.name, Highschooler.grade"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all the student names whose grade is higher than 5 and have at least two friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of students who have received grades higher than 5 and have at least two friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUPS-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of students who have received grades higher than 5 and have at least two friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, t0.c5",
            "select Highschooler.name, t0.c6",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name - Highschooler.grade"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of students who have received grades higher than 5 and have at least two friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Names of highschoolers for whom there is a grade of more than five and they have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-CROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Names of highschoolers for whom there is a grade of more than five and they have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, t0.c5",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, Highschooler.grade,",
            "select Highschooler.name (Highschooler.grade)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Names of highschoolers for whom there is a grade of more than five and they have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The list of highschoolers who have a grade over five and have two or more friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUPS-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUPS BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The list of highschoolers who have a grade over five and have two or more friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name, t0.c6",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, t0.c3",
            "select Highschooler.name, t0.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The list of highschoolers who have a grade over five and have two or more friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of high schoolers whose grades are higher than 5 and they have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-CORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of high schoolers whose grades are higher than 5 and they have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, t0.c5",
            "select Highschooler.name, Highschooler.grade,",
            "select Highschooler.name (or Highschooler.grade)",
            "select Highschooler.name, Highschooler.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of high schoolers whose grades are higher than 5 and they have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the names of those highschool students who get higher grades than over 5 and have more than two mates., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GWHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-HAVE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the names of those highschool students who get higher grades than over 5 and have more than two mates., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, t0.c5",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, t0.c6",
            "select Highschooler.name, t0.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the names of those highschool students who get higher grades than over 5 and have more than two mates., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1",
        "score": false,
        "real_pred": "Highschooler Friend Likes",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend Likes",
            "Highschooler Friend",
            "",
            "",
            "",
            "",
            "",
            "Highschooler Likes"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the names of high schoolers that have a grade of over 5 with two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHEREGROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUPS BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the names of high schoolers that have a grade of over 5 with two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, t0.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the names of high schoolers that have a grade of over 5 with two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of high schoolers who have a grade of over 5 and have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUPS BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of high schoolers who have a grade of over 5 and have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, t0.c5",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of high schoolers who have a grade of over 5 and have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of Kyle's likes?, database: Database: network_1. t0: highschooler(c0: id, c1: name (Kyle), c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of Kyle's likes?, database: Database: network_1. t0: highschooler(c0: id, c1: name (Kyle), c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Highschooler.name",
            "select count(Kyle's Likes.liked_id)",
            "select count(Kyle's likes)",
            "select count(*), Highschooler.ID",
            "select count(Kyle's Likes.student_id)",
            "select count(Kyle's count(*)",
            "select count(Kyle's)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of Kyle's likes?, database: Database: network_1. t0: highschooler(c0: id, c1: name (Kyle), c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the professional living in the State of Indiana or has done more than two treatments? List their ID, Last Name and Cell Phone., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ATTACH-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-C0, t6.c7, t6.c10",
            "SELECT-FROM-WHERE-ATTACH-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the professional living in the State of Indiana or has done more than two treatments? List their ID, Last Name and Cell Phone., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_",
        "prediction": "select t6.c0, t6.c7, t6.c10",
        "label": "select t6.c0, t6.c7, t6.c10",
        "score": true,
        "real_pred": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
            "select Professionals.first_name, Professionals.last_name, Professionals.cell_number",
            "select Treatments.professional_id, Professionals.last_name, Professionals.cell_number",
            "select Professionals.role_code, Professionals.last_name, Professionals.cell_number",
            "select t8.c2, Professionals.last_name, Professionals.cell_number",
            "select Charges.charge_id, Professionals.last_name, Professionals.cell_number",
            "select Sizes.size_code, Professionals.last_name, Professionals.cell_number",
            "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the professional living in the State of Indiana or has done more than two treatments? List their ID, Last Name and Cell Phone., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Breeds Professionals Treatments",
            "Sizes Professionals Treatments",
            "Charges Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please show the IDs, last names and cell phone numbers for the professional living in Indiana who does treatment with more than two treatments: -., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAGMENT-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAGMENT-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUPE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please show the IDs, last names and cell phone numbers for the professional living in Indiana who does treatment with more than two treatments: -., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5:",
        "prediction": "select t7.c2, t6.c7, t6.c10",
        "label": "select t6.c0, t6.c7, t6.c10",
        "score": false,
        "real_pred": "select Treatments.professional_id, Professionals.last_name, Professionals.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "topk_preds": [
            "select Treatments.professional_id, Professionals.last_name, Professionals.cell_number",
            "select t8.c2, Professionals.last_name, Professionals.cell_number",
            "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
            "select Treatments.dog_id, Professionals.last_name, Professionals.cell_number",
            "select Treatments.professional_id, Professionals.last_name, Professionals.cell_number",
            "select Treatments.professional_id.c2, Professionals.last_name, Professionals.cell_number",
            "select Sizes.size_code, Professionals.last_name, Professionals.cell_number",
            "select Charges.charge_id, Professionals.last_name, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please show the IDs, last names and cell phone numbers for the professional living in Indiana who does treatment with more than two treatments: -., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "",
            "Treatment_Types Professionals Treatments",
            "Breeds Professionals Treatments",
            "Sizes Professionals Treatments",
            "Charges Professionals Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which professional lives in the state of Indiana or has treated more than two patients or had their treatments performed on them? List his or her identification number, last name and cellular telephone., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, ",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUPS-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING OR-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUPS-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which professional lives in the state of Indiana or has treated more than two patients or had their treatments performed on them? List his or her identification number, last name and cellular telephone., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of",
        "prediction": "select t6.c0, t6.c7, t6.c10",
        "label": "select t6.c0, t6.c7, t6.c10",
        "score": true,
        "real_pred": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
            "select Treatments.professional_id, Professionals.last_name, Professionals.cell_number",
            "select Professionals.first_name, Professionals.last_name, Professionals.cell_number",
            "select t8.c2, Professionals.last_name, Professionals.cell_number",
            "select Professionals.role_code, Professionals.last_name, Professionals.cell_number",
            "select Charges.charge_id, Professionals.last_name, Professionals.cell_number",
            "select t 6.c0, Professionals.last_name, Professionals.cell_number",
            "select Sizes.size_code, Professionals.last_name, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which professional lives in the state of Indiana or has treated more than two patients or had their treatments performed on them? List his or her identification number, last name and cellular telephone., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Sizes Professionals Treatments",
            "Charges Professionals Treatments",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find people with Indiana or performed procedures on two procedures. List their identification, last name and telephone number., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find people with Indiana or performed procedures on two procedures. List their identification, last name and telephone number., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c2, t6.c7, t6.c10",
        "label": "select t6.c0, t6.c7, t6.c10",
        "score": false,
        "real_pred": "select Professionals.first_name, Professionals.last_name, Professionals.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "topk_preds": [
            "select Professionals.first_name, Professionals.last_name, Professionals.cell_number",
            "select Professionals.first_name, Professionals.last_name, Professionals.home_phone",
            "select Treatments.professional_id, Professionals.last_name, Professionals.cell_number",
            "select t8.c2, Professionals.last_name, Professionals.cell_number",
            "select Professionals.professional_id, Professionals.first_name, Professionals.last_name",
            "select t8.c1, Professionals.last_name, Professionals.cell_number",
            "select t8.c1, Professionals.first_name, Professionals.last_name",
            "select t9.c0, Professionals.last_name, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find people with Indiana or performed procedures on two procedures. List their identification, last name and telephone number., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t4 t6 t7",
        "label": "t6 t7",
        "score": false,
        "real_pred": "Owners Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Owners Professionals Treatments",
            "Treatment_Types Owners Professionals Treatments",
            "Sizes Owners Professionals Treatments",
            "Dogs Professionals Treatments",
            "",
            "",
            "Sizes Professionals Treatments",
            "Charges Professionals Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the last name and cell phone of the different professionals who live in the state of Indiana did treatment on more than two treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the last name and cell phone of the different professionals who live in the state of Indiana did treatment on more than two treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_",
        "prediction": "select t6.c7, t6.c10",
        "label": "select t6.c0, t6.c7, t6.c10",
        "score": false,
        "real_pred": "select Professionals.last_name, Professionals.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "topk_preds": [
            "select Professionals.last_name, Professionals.cell_number",
            "select Professionals.last_name, t66.c10",
            "select Professionals.last_name, Professionals.home_phone",
            "select Professionals.last_name, t06.c10",
            "select Professionals.last_name, t6.6.c10",
            "select Professionals.last_name, t660.c10",
            "select t6).c7, Professionals.cell_number",
            "select Professionals.last_name, t 6.c10"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the last name and cell phone of the different professionals who live in the state of Indiana did treatment on more than two treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Sizes Professionals Treatments",
            "Breeds Professionals Treatments",
            "Charges Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all the dog names that have not been over $1000 for treating., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-REGULATORY-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-REGULATION-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all the dog names that have not been over $1000 for treating., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c5",
        "label": "select t5.c5",
        "score": true,
        "real_pred": "select Dogs.name",
        "real_label": "select Dogs.name",
        "topk_preds": [
            "select Dogs.name",
            "select Dogs.name, Treatments.cost_of_treatment",
            "select Dogs.name, Treatments.dog_id",
            "select Dogs.name, Treatments.treatment_type_code",
            "select Dogs.name, Treatments.professional_id",
            "select Dogs.dog_id, Dogs.name",
            "select Dogs.name, Treatments.date_of_treatment",
            "select Dogs.name, max(Treatments.cost_of_treatment)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all the dog names that have not been over $1000 for treating., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Charges Dogs Treatments",
            "Breeds Charges Dogs Treatments",
            "Breeds Charges Sizes Dogs Treatments",
            "Treatment_Types Dogs Treatments",
            "Owners Dogs Treatments",
            "Sizes Dogs Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: show the list of dogs whose treatments did not cost more than $1000 and give the names of these animals., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: show the list of dogs whose treatments did not cost more than $1000 and give the names of these animals., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c5, t7.c1",
        "label": "select t5.c5",
        "score": false,
        "real_pred": "select Dogs.name, Treatments.dog_id",
        "real_label": "select Dogs.name",
        "topk_preds": [
            "select Dogs.name, Treatments.dog_id",
            "select Dogs.name, Treatments.professional_id",
            "select Dogs.name",
            "select Dogs.name, Treatments.treatment_type_code",
            "select Dogs.name, Treatments.treatment_id",
            "select Dogs.name, Dogs.breed_code",
            "select Dogs.dog_id, Dogs.name",
            "select Dogs.name, Dogs.dog_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: show the list of dogs whose treatments did not cost more than $1000 and give the names of these animals., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of dogs that have not cost more than $1000 in treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of dogs that have not cost more than $1000 in treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c5",
        "label": "select t5.c5",
        "score": true,
        "real_pred": "select Dogs.name",
        "real_label": "select Dogs.name",
        "topk_preds": [
            "select Dogs.name",
            "select Dogs.name, Treatments.dog_id",
            "select Dogs.name, Treatments.dog_id, Treatments.professional_id",
            "select Dogs.name, Treatments.dog_id, Dogs.abandoned_yn",
            "select Dogs.name, Treatments.dog_id, Treatments.treatment_type_code",
            "select Dogs.name, Treatments.treatment_type_code, Treatments.date_of_treatment",
            "select Dogs.name, Treatments.professional_id",
            "select Dogs.name, Treatments.dog_id, Dogs.breed_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of dogs that have not cost more than $1000 in treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Charges Dogs Treatments",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the name of the dog for which the owner has not spent more than $1000 for treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-FROM-GROUP BY-HAVING",
            "SELECT-FROM-RESTRICTION-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the name of the dog for which the owner has not spent more than $1000 for treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c5",
        "label": "select t5.c5",
        "score": true,
        "real_pred": "select Dogs.name",
        "real_label": "select Dogs.name",
        "topk_preds": [
            "select Dogs.name",
            "select Dogs.name, Treatments.dog_id",
            "select Dogs.name, Dogs.owner_id",
            "select Dogs.name, Dogs.age",
            "select Dogs.name, Dogs.breed_code",
            "select Dogs.name, Dogs.dog_id",
            "select Dogs.name, Treatments.professional_id",
            "select Dogs.name, Dogs.date_of_birth"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the name of the dog for which the owner has not spent more than $1000 for treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Charges Dogs Treatments",
            "Owners Dogs Treatments",
            "Treatment_Types Dogs Treatments",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the name of the dogs whose owners have not spent more than $1000 on treating their pets., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the name of the dogs whose owners have not spent more than $1000 on treating their pets., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c5",
        "label": "select t5.c5",
        "score": true,
        "real_pred": "select Dogs.name",
        "real_label": "select Dogs.name",
        "topk_preds": [
            "select Dogs.name",
            "select Dogs.name, Treatments.dog_id",
            "select Dogs.name, Dogs.owner_id",
            "select Dogs.name, Owners.first_name, Owners.last_name",
            "select Dogs.dog_id, Dogs.name",
            "select Dogs.name, Treatments.dog_id, Dogs.abandoned_yn",
            "select Dogs.name, Treatments.dog_id, Dogs.breed_code",
            "select Dogs.breed_code, Dogs.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the name of the dogs whose owners have not spent more than $1000 on treating their pets., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Charges Dogs Treatments",
            "Owners Dogs Treatments",
            "Treatment_Types Dogs Treatments",
            "Breeds Dogs Treatments",
            "Sizes Dogs Treatments",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name the dogs for which the owner has not spent more than $1000 on treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name the dogs for which the owner has not spent more than $1000 on treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c5",
        "label": "select t5.c5",
        "score": true,
        "real_pred": "select Dogs.name",
        "real_label": "select Dogs.name",
        "topk_preds": [
            "select Dogs.name",
            "select Dogs.name, Dogs.owner_id",
            "select Dogs.dog_id, Dogs.name",
            "select Dogs.name, Treatments.dog_id",
            "select Dogs.name, Dogs.dog_id",
            "select Dogs.breed_code, Dogs.name",
            "select Dogs.name, Dogs.age",
            "select Dogs.name, Dogs.date_of_birth"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name the dogs for which the owner has not spent more than $1000 on treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Charges Dogs Treatments",
            "Owners Dogs Treatments",
            "Treatment_Types Dogs Treatments",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the names of the dogs whose owners have not spent more than $1000 on their care., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-FROM-GROUP BY-HAVING",
            "SELECT-FROM-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the names of the dogs whose owners have not spent more than $1000 on their care., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c5",
        "label": "select t5.c5",
        "score": true,
        "real_pred": "select Dogs.name",
        "real_label": "select Dogs.name",
        "topk_preds": [
            "select Dogs.name",
            "select Dogs.name, Dogs.owner_id",
            "select Dogs.name, Charges.charge_amount",
            "select Dogs.name, Treatments.dog_id",
            "select Dogs.name, Charges.charge_type",
            "select Dogs.name, Dogs.dog_id",
            "select Dogs.name, Treatments.professional_id",
            "select Dogs.name, Treatments.treatment_type_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the names of the dogs whose owners have not spent more than $1000 on their care., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t1 t5 t7",
        "label": "t5 t7",
        "score": false,
        "real_pred": "Charges Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Charges Dogs Treatments",
            "Charges Sizes Dogs Treatments",
            "Breeds Charges Dogs Treatments",
            "",
            "Charges Dogs Professionals Treatments",
            "",
            "Charges Dogs",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name of the dogs for which the owner has not spent more than $1000 for treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name of the dogs for which the owner has not spent more than $1000 for treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c5",
        "label": "select t5.c5",
        "score": true,
        "real_pred": "select Dogs.name",
        "real_label": "select Dogs.name",
        "topk_preds": [
            "select Dogs.name",
            "select Dogs.name, Dogs.breed_code",
            "select Dogs.name, Treatments.dog_id",
            "select Dogs.name, Dogs.owner_id",
            "select Dogs.name, Dogs.age",
            "select Dogs.name, Dogs.date_of_birth",
            "select Dogs.name, Dogs.dog_id",
            "select Dogs.name, Dogs.abandoned_yn"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name of the dogs for which the owner has not spent more than $1000 for treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Charges Dogs Treatments",
            "Owners Dogs Treatments",
            "Treatment_Types Dogs Treatments",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me owners of dogs from VA, their first names and dogs' names., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me owners of dogs from VA, their first names and dogs' names., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t4.c1, t4.c2, t5.c5",
        "label": "select t4.c1, t5.c5",
        "score": false,
        "real_pred": "select Owners.first_name, Owners.last_name, Dogs.name",
        "real_label": "select Owners.first_name, Dogs.name",
        "topk_preds": [
            "select Owners.first_name, Owners.last_name, Dogs.name",
            "select Owners.first_name, Owners.last_name, Owners.state",
            "select Owners.first_name, Owners.last_name",
            "select Owners.first_name, Owners.last_name, Dogs.name",
            "select Owners.first_name, Owners.last_name, Dogs.name",
            "select Owners.first_name, Owners.last_name & Dogs.name",
            "select Owners.first_name, Owners.last_name and Dogs.name",
            "select Owners.first_name, Owners.city, Dogs.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me owners of dogs from VA, their first names and dogs' names., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "Owners Dogs",
        "real_label": "Owners Dogs",
        "topk_preds": [
            "Owners Dogs",
            "Sizes Owners Dogs",
            "Treatment_Types Owners Dogs",
            "Charges Owners Dogs",
            "Breeds Owners Dogs",
            "Dogs Owners Dogs",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the first names of owners living in VA and the name of their dog., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the first names of owners living in VA and the name of their dog., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t4.c1, t4.c2",
        "label": "select t4.c1, t5.c5",
        "score": false,
        "real_pred": "select Owners.first_name, Owners.last_name",
        "real_label": "select Owners.first_name, Dogs.name",
        "topk_preds": [
            "select Owners.first_name, Owners.last_name",
            "select Owners.first_name, Dogs.name",
            "select Owners.first_name, Owners.state",
            "select Owners.first_name, Owners.last_name, Dogs.name",
            "select Owners.first_name, Owners.last_name, Owners.state",
            "select Owners.first_name, Dogs.name, Owners.zip_code",
            "select Owners.first_name, Owners.zip_code",
            "select Owners.first_name, Owners.last_name - Dogs.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the first names of owners living in VA and the name of their dog., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "Owners Dogs",
        "real_label": "Owners Dogs",
        "topk_preds": [
            "Owners Dogs",
            "Sizes Owners Dogs",
            "Treatment_Types Owners Dogs",
            "Breeds Owners Dogs",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all singers who are not French., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all singers who are not French., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select distinct t0.c1",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select distinct singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select distinct singer.Name",
            "select singer.Name",
            "select distinct singer.Name, singer.Citizenship",
            "select distinct singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Citizenship",
            "select distinct singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, singer.Birth_Year",
            "select distinct singer.Name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all singers who are not French., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the list of singers who are not French., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the list of singers who are not French., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select distinct singer.Name",
            "select distinct singer.Name, singer.Citizenship",
            "select singer.Name, singer.Citizenship",
            "select distinct singer.Name, singer.Birth_Year",
            "select singer.Singer_ID, singer.Name",
            "select distinct singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, singer.Birth_Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the list of singers who are not French., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the singer that are not French citizen., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the singer that are not French citizen., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Singer_ID",
            "select singer.Name, singer.Citizenship",
            "select distinct singer.Name",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Birth_Year",
            "select distinct singer.Name, singer.Citizenship",
            "select singer.Name, singer.Net_Worth_Millions"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the singer that are not French citizen., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: list the names of singers who are not French., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: list the names of singers who are not French., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select distinct singer.Name",
            "select singer.Name, singer.Citizenship",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Net_Worth_Millions",
            "select distinct singer.Name, singer.Citizenship",
            "select distinct singer.Name, singer.Birth_Year",
            "select singer.Name (or singer.Birth_Year)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: list the names of singers who are not French., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which singer do not have the French nationality., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which singer do not have the French nationality., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Singer_ID",
            "select distinct singer.Name",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Citizenship",
            "select singer.Name, singer.Birth_Year",
            "select distinct singer.Name, singer.Citizenship",
            "select distinct singer.Name, singer.Birth_Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which singer do not have the French nationality., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the singers whose citizenship is not French., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the singers whose citizenship is not French., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select singer.Singer_ID",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Singer_ID",
            "select singer.Name",
            "select distinct singer.Name",
            "select distinct singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Citizenship",
            "select distinct singer.Name, singer.Citizenship",
            "select singer.Name, singer.Net_Worth_Millions"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the singers whose citizenship is not French., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the list of the singer's birth years in either '48' or '49'., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the list of the singer's birth years in either '48' or '49'., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c2",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select singer.Birth_Year",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Birth_Year",
            "select distinct singer.Birth_Year",
            "select count(*)",
            "select singer.Singer_ID",
            "select all singer.Birth_Year",
            "select list(*)",
            "select the singer.Birth_Year",
            "select singer.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the list of the singer's birth years in either '48' or '49'., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show distinct name of singer that has song sales greater than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show distinct name of singer that has song sales greater than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select distinct t0.c1",
        "label": "select distinct t0.c1",
        "score": true,
        "real_pred": "select distinct singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select distinct singer.Name",
            "select singer.Name",
            "select distinct singer.Name, song.Singer_ID",
            "select singer.Name, song.Singer_ID",
            "select distinct singer.Name, singer.Birth_Year",
            "select distinct singer.Name, singer.Singer_ID",
            "select distinct singer.Name, song.Singer_ID",
            "select seperate singer.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show distinct name of singer that has song sales greater than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of singer who have had more than 300K in song sales., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of singer who have had more than 300K in song sales., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select distinct t0.c1",
        "score": false,
        "real_pred": "select singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select singer.Name, singer.Birth_Year",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name (singer.Singer_ID)",
            "select song.Singer_ID, singer.Name",
            "select singer.Name song.Singer_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of singer who have had more than 300K in song sales., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Distinct names of singers with song sales above 300k., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Distinct names of singers with song sales above 300k., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select distinct t0.c1",
        "label": "select distinct t0.c1",
        "score": true,
        "real_pred": "select distinct singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select distinct singer.Name",
            "select distinct singer.Name, song.Singer_ID",
            "select distinct singer.Name, singer.Birth_Year",
            "select singer.Name",
            "select distinct singer.Name song.Singer_ID",
            "select distinct singer.Name de song.Singer_ID",
            "select distinct singer.Name, singer.Net_Worth_Millions",
            "select distinct singer.Name (song.Singer_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Distinct names of singers with song sales above 300k., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show distinct names of the singers who have sold songs more than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-SEPARATE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show distinct names of the singers who have sold songs more than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select distinct t0.c1",
        "label": "select distinct t0.c1",
        "score": true,
        "real_pred": "select distinct singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select distinct singer.Name",
            "select distinct singer.Name, song.Singer_ID",
            "select distinct singer.Name, singer.Birth_Year",
            "select singer.Name",
            "select distinct singer.Name, singer.Net_Worth_Millions",
            "select distinct singer.Name, song.Singer_ID",
            "select distinct singer.Name (singer.Singer_ID)",
            "select distinct singer.Name song.Singer_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show distinct names of the singers who have sold songs more than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show distinct names of singers that sell more than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show distinct names of singers that sell more than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select distinct t0.c1",
        "label": "select distinct t0.c1",
        "score": true,
        "real_pred": "select distinct singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select distinct singer.Name",
            "select distinct singer.Name, song.Singer_ID",
            "select singer.Name",
            "select distinct singer.Name, singer.Birth_Year",
            "select distinct singer.Name, singer.Net_Worth_Millions",
            "select seperate singer.Name",
            "select distinct singer.Name, song.Sales",
            "select distinct singer.Name, song.Singer_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show distinct names of singers that sell more than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of the singers that have sold more than 300k., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of the singers that have sold more than 300k., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select distinct t0.c1",
        "score": false,
        "real_pred": "select singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select song.Singer_ID, singer.Name",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, song.Singer_ID",
            "select singer.Name, song.Sales",
            "select singer.Name, song.Title"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of the singers that have sold more than 300k., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of singers that have songs that have sold more than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of singers that have songs that have sold more than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select distinct t0.c1",
        "score": false,
        "real_pred": "select singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select singer.Name, singer.Birth_Year",
            "select song.Singer_ID",
            "select singer.Name, song.Singer_ID",
            "select singer.Name, singer.Singer_ID",
            "select song.Singer_ID, singer.Name",
            "select singer.Name, singer.Net_Worth_Millions"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of singers that have songs that have sold more than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show distinct names of singers whose songs have had sales more than 300k., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTINCT-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-DISTINCT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show distinct names of singers whose songs have had sales more than 300k., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select distinct t0.c1",
        "label": "select distinct t0.c1",
        "score": true,
        "real_pred": "select distinct singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select distinct singer.Name",
            "select distinct singer.Name, song.Singer_ID",
            "select distinct song.Singer_ID",
            "select distinct singer.Name, singer.Birth_Year",
            "select distinct singer.Name, song.Singer_ID",
            "select singer.Name",
            "select distinct singer.Name, singer.Net_Worth_Millions",
            "select distinct singer.Name, song.Singer_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show distinct names of singers whose songs have had sales more than 300k., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Names of the singers that have sold more than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Names of the singers that have sold more than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select distinct t0.c1",
        "score": false,
        "real_pred": "select singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select song.Singer_ID, singer.Name",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, song.Sales",
            "select singer.Name, song.Title",
            "select singer.Name, song.Song_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Names of the singers that have sold more than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the different names of the singers who have sold more than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the different names of the singers who have sold more than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select distinct t0.c1",
        "label": "select distinct t0.c1",
        "score": true,
        "real_pred": "select distinct singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select distinct singer.Name",
            "select distinct singer.Name, singer.Birth_Year",
            "select distinct singer.Name, song.Singer_ID",
            "select distinct singer.Name, singer.Net_Worth_Millions",
            "select count(distinct singer.Name)",
            "select distinct singer.Name, song.Singer_ID",
            "select distinct singer.Name, song.Sales",
            "select distinct singer.Name, song.Title"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the different names of the singers who have sold more than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Names of the singers who have sold more than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Names of the singers who have sold more than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select distinct t0.c1",
        "score": false,
        "real_pred": "select singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Net_Worth_Millions",
            "select song.Singer_ID, singer.Name",
            "select singer.Name, song.Sales",
            "select singer.Name, song.Title",
            "select singer.Name, song.Song_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Names of the singers who have sold more than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the different names of the singers who have a sales of more than 300k., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the different names of the singers who have a sales of more than 300k., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select distinct t0.c1",
        "label": "select distinct t0.c1",
        "score": true,
        "real_pred": "select distinct singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select distinct singer.Name",
            "select distinct singer.Name, song.Singer_ID",
            "select distinct singer.Name, singer.Birth_Year",
            "select count(distinct singer.Name)",
            "select distinct singer.Name, singer.Net_Worth_Millions",
            "select distinct singer.Name, song.Singer_ID",
            "select distinct singer.Name, song.Sales",
            "select distinct singer.Name, song.Title"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the different names of the singers who have a sales of more than 300k., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The different names of the singers who have sold more than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The different names of the singers who have sold more than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select distinct t0.c1",
        "label": "select distinct t0.c1",
        "score": true,
        "real_pred": "select distinct singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select distinct singer.Name",
            "select distinct singer.Name, song.Singer_ID",
            "select distinct singer.Name, singer.Birth_Year",
            "select count(distinct singer.Name)",
            "select distinct singer.Name, singer.Net_Worth_Millions",
            "select distinct singer.Name, song.Singer_ID",
            "select distinct singer.Name, song.Title",
            "select distinct singer.Name, song.Sales"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The different names of the singers who have sold more than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: A list for the names of the singers who have sold more than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: A list for the names of the singers who have sold more than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select distinct t0.c1",
        "score": false,
        "real_pred": "select singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select singer.Name, singer.Birth_Year",
            "select song.Singer_ID, singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, song.Sales",
            "select singer.Name, song.Title",
            "select singer.Name, song.Song_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: A list for the names of the singers who have sold more than 300K., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Names of the singers who have sold more than 300,000., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Names of the singers who have sold more than 300,000., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select distinct t0.c1",
        "score": false,
        "real_pred": "select singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, song.Sales",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, song.Title",
            "select singer.Name, song.Singer_ID",
            "select t0, singer.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Names of the singers who have sold more than 300,000., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The name of the feature type used to describe Air Conditioner., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code, c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code, c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The name of the feature type used to describe Air Conditioner., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code, c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code, c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Ref_Feature_Types.feature_type_name",
        "real_label": "select Ref_Feature_Types.feature_type_name",
        "topk_preds": [
            "select Ref_Feature_Types.feature_type_name",
            "select Ref_Feature_Types.feature_type_name, Other_Available_Features.feature_name",
            "select Ref_Feature_Types.feature_type_name, Other_Available_Features.feature_name, Other_Available_Features.feature_description",
            "select Ref_Feature_Types.feature_type_code, Ref_Feature_Types.feature_type_name",
            "select Ref_Feature_Types.feature_type_code_description",
            "select Ref_Feature_Types.feature_type_code",
            "select Ref_Feature_Types.feature_type_code, Other_Available_Features.feature_name",
            "select Ref_Feature_Types.feature_type_name, Other_Available_Features.feature_description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The name of the feature type used to describe Air Conditioner., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code, c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code, c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Ref_Feature_Types Other_Available_Features",
        "real_label": "Ref_Feature_Types Other_Available_Features",
        "topk_preds": [
            "Ref_Feature_Types Other_Available_Features",
            "Ref_Feature_Types Other_Available_Features Other_Property_Features",
            "Ref_Feature_Types Other_Available_Features Properties",
            "",
            "",
            "Ref_Feature_Types Other_Available_Features Properties Other_Property_Features",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the feature type name of air condition., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code, c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description (Air Conditioning.)). t3: properties(c0: property_id, c1: property_type_code, c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the feature type name of air condition., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code, c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description (Air Conditioning.)). t3: properties(c0: property_id, c1: property_type_code, c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Ref_Feature_Types.feature_type_name",
        "real_label": "select Ref_Feature_Types.feature_type_name",
        "topk_preds": [
            "select Ref_Feature_Types.feature_type_name",
            "select Ref_Feature_Types.feature_type_code, Ref_Feature_Types.feature_type_name",
            "select Ref_Feature_Types.feature_type_name, Other_Available_Features.feature_name",
            "select Ref_Feature_Types.feature_type_name, Other_Available_Features.feature_type_code",
            "select Ref_Feature_Types.feature_type_name (Ref_Feature_Types.feature_type_code)",
            "select Ref_Feature_Types.feature_type_name, Other_Available_Features.feature_description",
            "select Ref_Feature_Types.feature_type_name, Other_Available_Features.feature_id",
            "select Ref_Feature_Types.feature_type_name, Ref_Feature_Types.feature_type_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the feature type name of air condition., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code, c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description (Air Conditioning.)). t3: properties(c0: property_id, c1: property_type_code, c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Ref_Feature_Types Other_Available_Features",
        "real_label": "Ref_Feature_Types Other_Available_Features",
        "topk_preds": [
            "Ref_Feature_Types Other_Available_Features",
            "Ref_Feature_Types Ref_Property_Types Other_Available_Features",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What's the named feature type of Feature Air Conditioning., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code, c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description (Air Conditioning.)). t3: properties(c0: property_id, c1: property_type_code, c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What's the named feature type of Feature Air Conditioning., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code, c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description (Air Conditioning.)). t3: properties(c0: property_id, c1: property_type_code, c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Ref_Feature_Types.feature_type_name",
        "real_label": "select Ref_Feature_Types.feature_type_name",
        "topk_preds": [
            "select Ref_Feature_Types.feature_type_name",
            "select Ref_Feature_Types.feature_type_code, Ref_Feature_Types.feature_type_name",
            "select Ref_Feature_Types.feature_type_name, Other_Available_Features.feature_name",
            "select Ref_Feature_Types.feature_type_code_description",
            "select Ref_Feature_Types.feature_type_code",
            "select Ref_Feature_Types.feature_type_name, Other_Available_Features.feature_type_code",
            "select Ref_Feature_Types.feature_type_name, Other_Available_Features.feature_id",
            "select Ref_Feature_Types.feature_type_code_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What's the named feature type of Feature Air Conditioning., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code, c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description (Air Conditioning.)). t3: properties(c0: property_id, c1: property_type_code, c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Ref_Feature_Types Other_Available_Features",
        "real_label": "Ref_Feature_Types Other_Available_Features",
        "topk_preds": [
            "Ref_Feature_Types Other_Available_Features",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Property whose name is whether a house or apartment with rooms of more than one., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-DECIS-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE.UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Property whose name is whether a house or apartment with rooms of more than one., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "select t3.c4",
        "label": "select t3.c4",
        "score": true,
        "real_pred": "select Properties.property_name",
        "real_label": "select Properties.property_name",
        "topk_preds": [
            "select Properties.property_name",
            "select Properties.property_name--depending-on-whether-it's-an-apartment-or-a-house",
            "select Properties.property_name--depending-on-whether-it's-apartment-or-house",
            "select distinct Properties.property_name",
            "select Properties.property_name, Properties.property_type_code",
            "select Properties.property_name--depending-on-whether-it-is-apartment-or-house",
            "select Properties.property_name--depending-on-whether-it's-an-apartment-or-ahouse",
            "select Properties.property_name--depending-on-if-it's-apartment-or-house"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Property whose name is whether a house or apartment with rooms of more than one., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Properties",
        "real_label": "Properties",
        "topk_preds": [
            "Properties",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Properties whose name is either house or apartment, have more than one room., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE\u00adUNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Properties whose name is either house or apartment, have more than one room., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "select t3.c4",
        "label": "select t3.c4",
        "score": true,
        "real_pred": "select Properties.property_name",
        "real_label": "select Properties.property_name",
        "topk_preds": [
            "select Properties.property_name",
            "select Properties.property_name, Properties.room_count",
            "select Properties.property_name, Properties.property_type_code",
            "select Properties.property_name, Properties.property_address",
            "select Properties.property_name ou Properties.property_type_code",
            "select Properties.property_name-Properties.room_count",
            "select Properties.property_name, Properties.buyer_offered_price",
            "select Properties.property_name, Properties.property_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Properties whose name is either house or apartment, have more than one room., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Properties",
        "real_label": "Properties",
        "topk_preds": [
            "Properties",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    }
]