[
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old are singers from France on average, minimum and maximum?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country (France), c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (Avg(t1.c5), min(t1.c5), max(t1.c5)",
            "SELECT-FROM-WHERE, AVG(t1.c5), min(t1.c5), max(t1.c5)",
            "SELECT-FROM-WHERE (AVG(t1.c5), min(t1.c5), max(t1.c5)",
            "SELECT-FROM-WHERE (AVG, min(t1.c5), max(t1.c5)",
            "SELECT-FROM-WHERE-AGGREGATE, MINIMUM(t1.c5), MAX(t1.c5)",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old are singers from France on average, minimum and maximum?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country (France), c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select avg(t1.c5), min(t1.c5), max(t1.c5)",
        "label": "select avg(t1.c5), min(t1.c5), max(t1.c5)",
        "score": true,
        "real_pred": "select avg(singer.Age), min(singer.Age), max(singer.Age)",
        "real_label": "select avg(singer.Age), min(singer.Age), max(singer.Age)",
        "topk_preds": [
            "select avg(singer.Age), min(singer.Age), max(singer.Age)",
            "select avg(singer.Age), min(singer.Age),max(singer.Age)",
            "select avg(singer.Age), min(singer.Is_male), max(singer.Age)",
            "select avg(singer.Age), min(singer.Age), max(singer.Is_male)",
            "select avg(singer.Age), min(singer.Age), max(singer.Age)",
            "select avg(singer.Age), min(singer.Age) and max(singer.Age)",
            "select avg(singer.Age), min(singer.Age), maximum(singer.Age)",
            "select avg(singer.Age), min(singer.Age), max(singer.Age)."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old are singers from France on average, minimum and maximum?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country (France), c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are the singers and what numbers of concerts each one had?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GEOGRAPHY-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GAGGER-GROUP BY",
            "SELECT-FROM-GROUP BY (ORDER BY",
            "SELECT-FROM-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY -ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are the singers and what numbers of concerts each one had?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, count(*)",
        "label": "select t1.c1, count(*)",
        "score": true,
        "real_pred": "select singer.Name, count(*)",
        "real_label": "select singer.Name, count(*)",
        "topk_preds": [
            "select singer.Name, count(*)",
            "select singer.Name, count(*), concert.Stadium_ID",
            "select singer.Name, count(*), concert.concert_ID",
            "select singer.Name, count(*), concert.concert_Name",
            "select singer.Name, count(*), concert.Theme",
            "select count(*), singer.Name",
            "select singer.Name, count(*), concert.Year",
            "select singer.Name, count(*), singer_in_concert.Singer_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are the singers and what numbers of concerts each one had?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1 t2 t3",
        "label": "t1 t3",
        "score": false,
        "real_pred": "singer concert singer_in_concert",
        "real_label": "singer singer_in_concert",
        "topk_preds": [
            "singer concert singer_in_concert",
            "singer singer_in_concert",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name all stadiums which had no concert in 2014., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name all stadiums which had no concert in 2014., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select stadium.Name",
        "real_label": "select stadium.Name",
        "topk_preds": [
            "select stadium.Name",
            "select stadium.Stadium_ID, stadium.Name",
            "select stadium.Location, stadium.Name",
            "select stadium.Name, stadium.Location",
            "select stadium.Name, stadium.Stadium_ID",
            "select stadium.Name, concert.Stadium_ID",
            "select stadium.Stadium_ID, stadium.Location",
            "select stadium.Stadium_ID, stadium.Name,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name all stadiums which had no concert in 2014., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "stadium concert",
        "real_label": "stadium concert",
        "topk_preds": [
            "stadium concert",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name stadium's that didn't hold a concert in 2014., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE.",
            "SELECT-FROM-ESE-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name stadium's that didn't hold a concert in 2014., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select stadium.Name",
        "real_label": "select stadium.Name",
        "topk_preds": [
            "select stadium.Name",
            "select stadium.Stadium_ID, stadium.Name",
            "select stadium.Location, stadium.Name",
            "select stadium.Name, concert.Stadium_ID",
            "select stadium.Name, stadium.Stadium_ID",
            "select stadium.Stadium_ID, stadium.Location",
            "select stadium.Stadium_ID, stadium.Name,",
            "select stadium.Stadium_ID, stadium.Name."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name stadium's that didn't hold a concert in 2014., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "stadium concert",
        "real_label": "stadium concert",
        "topk_preds": [
            "stadium concert",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What were all stadiums that had no concerts in 2014?., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-ESE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What were all stadiums that had no concerts in 2014?., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select stadium.Name",
        "real_label": "select stadium.Name",
        "topk_preds": [
            "select stadium.Name",
            "select stadium.Stadium_ID, stadium.Name",
            "select stadium.Stadium_ID",
            "select stadium.Location, stadium.Name",
            "select stadium.Stadium_ID, stadium.Location",
            "select stadium.Name, stadium.Stadium_ID",
            "select stadium.Stadium_ID, stadium.Name,",
            "select stadium.Stadium_ID, stadium.Name."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What were all stadiums that had no concerts in 2014?., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "stadium concert",
        "real_label": "stadium concert",
        "topk_preds": [
            "stadium concert",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which stadium have highest average attendance? And what is its capacity?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which stadium have highest average attendance? And what is its capacity?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c2, t0.c3",
        "label": "select t0.c2, t0.c3",
        "score": true,
        "real_pred": "select stadium.Name, stadium.Capacity",
        "real_label": "select stadium.Name, stadium.Capacity",
        "topk_preds": [
            "select stadium.Name, stadium.Capacity",
            "select stadium.Stadium_ID, stadium.Name, stadium.Capacity",
            "select stadium.Location, stadium.Capacity",
            "select stadium.Capacity, stadium.Name",
            "select stadium.Name., stadium.Capacity",
            "select t0.c 2, stadium.Capacity",
            "select stadium.Name, stadium.Capacity, stadium.Average",
            "select stadium.Name, stadium.Capacity"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which stadium have highest average attendance? And what is its capacity?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "stadium",
        "real_label": "stadium",
        "topk_preds": [
            "stadium",
            "stadium concert",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What stadium had concerts that took place in 2014 and 2015? And where are they?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-CONCERT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-COUPON-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-COUPLE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-COUPON-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What stadium had concerts that took place in 2014 and 2015? And where are they?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c2, t0.c1",
        "label": "select t0.c2, t0.c1",
        "score": true,
        "real_pred": "select stadium.Name, stadium.Location",
        "real_label": "select stadium.Name, stadium.Location",
        "topk_preds": [
            "select stadium.Name, stadium.Location",
            "select stadium.Location, stadium.Name",
            "select stadium.Name.c1, stadium.Name",
            "select stadium.Stadium_ID, stadium.Location",
            "select stadium.Stadium_ID, stadium.Name",
            "select stadium.Name, stadium.Location",
            "select t0.c 2, stadium.Location",
            "select stadium.Name-, stadium.Location"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What stadium had concerts that took place in 2014 and 2015? And where are they?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "stadium concert",
        "real_label": "stadium concert",
        "topk_preds": [
            "stadium concert",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the stadium whose concerts happened in both 2014 and 2015 and their location?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE (GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE (t0.c2)",
            "SELECT SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the stadium whose concerts happened in both 2014 and 2015 and their location?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c2, t0.c1",
        "label": "select t0.c2, t0.c1",
        "score": true,
        "real_pred": "select stadium.Name, stadium.Location",
        "real_label": "select stadium.Name, stadium.Location",
        "topk_preds": [
            "select stadium.Name, stadium.Location",
            "select stadium.Location, stadium.Name",
            "select stadium.Stadium_ID, stadium.Location",
            "select stadium.Stadium_ID, stadium.Name, stadium.Location",
            "select stadium.Name.c1, stadium.Name",
            "select t0.c 2, stadium.Location",
            "select stadium.Name, stadium.Location, stadium.Capacity",
            "select stadium.Stadium_ID, stadium.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the stadium whose concerts happened in both 2014 and 2015 and their location?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "stadium concert",
        "real_label": "stadium concert",
        "topk_preds": [
            "stadium concert",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What stadiums had concerts that occurred in both 2014 and 2015? And Where are they located?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT-FROM- WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE?",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What stadiums had concerts that occurred in both 2014 and 2015? And Where are they located?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c2, t0.c1",
        "label": "select t0.c2, t0.c1",
        "score": true,
        "real_pred": "select stadium.Name, stadium.Location",
        "real_label": "select stadium.Name, stadium.Location",
        "topk_preds": [
            "select stadium.Name, stadium.Location",
            "select stadium.Location, stadium.Name",
            "select stadium.Stadium_ID, stadium.Location",
            "select stadium.Name.c1, stadium.Name",
            "select stadium.Stadium_ID, stadium.Name, stadium.Location",
            "select stadium.Stadium_ID, stadium.Name",
            "select stadium.Name, stadium.Location, stadium.Capacity",
            "select stadium.Stadium_ID, stadium.Location, stadium.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What stadiums had concerts that occurred in both 2014 and 2015? And Where are they located?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "stadium concert",
        "real_label": "stadium concert",
        "topk_preds": [
            "stadium concert",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What stadiums hosted concerts which took place in both 2014 and 2015? And where are those places?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE?",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE,"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What stadiums hosted concerts which took place in both 2014 and 2015? And where are those places?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c2, t0.c1",
        "score": false,
        "real_pred": "select stadium.Location, stadium.Name",
        "real_label": "select stadium.Name, stadium.Location",
        "topk_preds": [
            "select stadium.Location, stadium.Name",
            "select stadium.Name, stadium.Location",
            "select stadium.Stadium_ID, stadium.Location",
            "select stadium.Name.c1, stadium.Name",
            "select stadium.Location., stadium.Name",
            "select stadium.Stadium_ID, stadium.Name",
            "select stadium.Location, stadium.Stadium_ID",
            "select stadium.Location, stadium.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What stadiums hosted concerts which took place in both 2014 and 2015? And where are those places?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "stadium concert",
        "real_label": "stadium concert",
        "topk_preds": [
            "stadium concert",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What stadiums were used for concerts in 2014 and 2015? And where are they?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-CONNECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-CONCERT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-CONCERT-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What stadiums were used for concerts in 2014 and 2015? And where are they?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c2, t0.c1",
        "label": "select t0.c2, t0.c1",
        "score": true,
        "real_pred": "select stadium.Name, stadium.Location",
        "real_label": "select stadium.Name, stadium.Location",
        "topk_preds": [
            "select stadium.Name, stadium.Location",
            "select stadium.Location, stadium.Name",
            "select stadium.Stadium_ID, stadium.Location",
            "select stadium.Name.c1, stadium.Name",
            "select stadium.Stadium_ID, stadium.Name",
            "select stadium.Stadium_ID, stadium.Name, stadium.Location",
            "select stadium.Name, stadium.Location, stadium.Capacity",
            "select stadium.Name, stadium.Location, concert.Stadium_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What stadiums were used for concerts in 2014 and 2015? And where are they?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "stadium concert",
        "real_label": "stadium concert",
        "topk_preds": [
            "stadium concert",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What's the name/nation of a singer that has a song that haves with \"hey\"?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What's the name/nation of a singer that has a song that haves with \"hey\"?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select singer.Name, singer.Country",
        "real_label": "select singer.Name, singer.Country",
        "topk_preds": [
            "select singer.Name, singer.Country",
            "select singer.Name, singer.Country, singer.Song_Name",
            "select singer.Name, singer.Country, singer.Singer_ID",
            "select singer.Name, singer.Country - singer.Song_Name",
            "select singer.Name, singer.Country,",
            "select singer.Name, singer.Country, max(singer.Song_Name)",
            "select singer.Name / singer.Country",
            "select singer.Name, singer.Country,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What's the name/nation of a singer that has a song that haves with \"hey\"?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me list of songs by the singers who are older than average., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me list of songs by the singers who are older than average., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select singer.Song_Name",
        "real_label": "select singer.Song_Name",
        "topk_preds": [
            "select singer.Song_Name",
            "select singer.Song_Name, singer.Is_male",
            "select singer.Song_Name, singer.Age",
            "select singer.Song_Name, singer.Song_release_year",
            "select singer.Song_Name, singer.Country",
            "select singer.Song_Name, t1.c7",
            "select singer.Song_Name (singer.Song_release_year)",
            "select singer.Song_Name, t1.c8"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me list of songs by the singers who are older than average., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "singer singer_in_concert",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: list all the songs by those singers who are above average age., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SQL-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: list all the songs by those singers who are above average age., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select singer.Song_Name",
        "real_label": "select singer.Song_Name",
        "topk_preds": [
            "select singer.Song_Name",
            "select singer.Song_Name, singer.Song_release_year",
            "select singer.Song_Name, singer.Is_male",
            "select singer.Song_Name, singer.Age",
            "select singer.Song_Name, singer.Country",
            "select singer.Song_Name, t1.c7",
            "select singer.Song_Name (singer.Song_release_year)",
            "select singer.Song_Name - singer.Song_release_year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: list all the songs by those singers who are above average age., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "singer singer_in_concert",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Without concerts list stadiums., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-SECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-ON-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Without concerts list stadiums., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select stadium.Name",
        "real_label": "select stadium.Name",
        "topk_preds": [
            "select stadium.Name",
            "select stadium.Stadium_ID, stadium.Name",
            "select stadium.Location, stadium.Name",
            "select stadium.Name, stadium.Location",
            "select stadium.Stadium_ID, stadium.Location, stadium.Name",
            "select stadium.Name, stadium.Stadium_ID",
            "select stadium.Stadium_ID, stadium.Name, stadium.Capacity",
            "select stadium.Stadium_ID, stadium.Name, stadium.Capacity"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Without concerts list stadiums., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0 t2",
        "label": "t0",
        "score": false,
        "real_pred": "stadium concert",
        "real_label": "stadium",
        "topk_preds": [
            "stadium concert",
            "stadium singer concert",
            "",
            "stadium",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give stadiums without concerts., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-SECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give stadiums without concerts., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c0, t0.c2",
        "label": "select t0.c2",
        "score": false,
        "real_pred": "select stadium.Stadium_ID, stadium.Name",
        "real_label": "select stadium.Name",
        "topk_preds": [
            "select stadium.Stadium_ID, stadium.Name",
            "select stadium.Name",
            "select stadium.Location, stadium.Name",
            "select stadium.Stadium_ID, stadium.Name, stadium.Capacity",
            "select stadium.Capacity, stadium.Name",
            "select stadium.Stadium_ID, stadium.Name, stadium.Capacity",
            "select stadium.Stadium_ID, stadium.Location",
            "select stadium.Stadium_ID, stadium.Location, stadium.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give stadiums without concerts., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0 t2",
        "label": "t0",
        "score": false,
        "real_pred": "stadium concert",
        "real_label": "stadium",
        "topk_preds": [
            "stadium concert",
            "stadium",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Mention stadiums without concerts., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Mention stadiums without concerts., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select stadium.Name",
        "real_label": "select stadium.Name",
        "topk_preds": [
            "select stadium.Name",
            "select stadium.Stadium_ID, stadium.Name",
            "select stadium.Location, stadium.Name",
            "select stadium.Capacity, stadium.Name",
            "select stadium.Name, stadium.Stadium_ID",
            "select stadium.Name, stadium.Capacity",
            "select stadium.Stadium_ID, stadium.Location",
            "select stadium.Name, concert.Stadium_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Mention stadiums without concerts., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0 t2",
        "label": "t0",
        "score": false,
        "real_pred": "stadium concert",
        "real_label": "stadium",
        "topk_preds": [
            "stadium concert",
            "stadium",
            "stadium singer concert",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What singers performed in a concert in 2014?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What singers performed in a concert in 2014?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t1.c1",
        "score": false,
        "real_pred": "select singer_in_concert.Singer_ID",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer_in_concert.Singer_ID",
            "select singer_in_concert.Singer_ID, singer.Name",
            "select singer_in_concert.Singer_ID, singer.Country",
            "select singer_in_concert.Singer_ID, concert.Theme",
            "select singer.Name, singer_in_concert.Singer_ID",
            "select singer_in_concert.Singer_ID, singer.Song_Name",
            "select singer_in_concert.Singer_ID, t3.c2",
            "select singer_in_concert.Singer_ID, singer.Singer_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What singers performed in a concert in 2014?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "concert singer_in_concert",
        "real_label": "singer concert singer_in_concert",
        "topk_preds": [
            "concert singer_in_concert",
            "singer concert singer_in_concert",
            "stadium concert singer_in_concert",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who sang in a concert in 2014?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INSERT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who sang in a concert in 2014?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer_in_concert.Singer_ID",
            "select singer.Name, singer.Singer_ID",
            "select singer.Name, singer_in_concert.Singer_ID",
            "select singer.Name, concert.concert_ID",
            "select singer.Name, concert.concert_Name",
            "select singer.Name, singer_in_concert.concert_ID",
            "select singer.Name, singer.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who sang in a concert in 2014?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "concert singer_in_concert",
        "real_label": "singer concert singer_in_concert",
        "topk_preds": [
            "concert singer_in_concert",
            "singer concert singer_in_concert",
            "stadium singer concert singer_in_concert",
            "stadium concert singer_in_concert",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which singers sang in concert in 2014?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which singers sang in concert in 2014?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t1.c1",
        "score": false,
        "real_pred": "select singer_in_concert.Singer_ID",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer_in_concert.Singer_ID",
            "select singer_in_concert.Singer_ID, singer.Country",
            "select singer.Name, singer_in_concert.Singer_ID",
            "select singer_in_concert.Singer_ID, singer.Name",
            "select singer.Name",
            "select singer_in_concert.Singer_ID, concert.Theme",
            "select singer.Name, concert.concert_ID",
            "select singer.Name, singer_in_concert.concert_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which singers sang in concert in 2014?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "concert singer_in_concert",
        "real_label": "singer concert singer_in_concert",
        "topk_preds": [
            "concert singer_in_concert",
            "singer concert singer_in_concert",
            "",
            "stadium concert singer_in_concert",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who were the singers in a concert in 2014?., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-INSERT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who were the singers in a concert in 2014?., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer_in_concert.Singer_ID",
            "select singer.Name, singer.Singer_ID",
            "select singer.Name, concert.concert_ID",
            "select singer.Name, singer_in_concert.Singer_ID",
            "select singer.Name, concert.concert_Name",
            "select singer.Name, singer.Country",
            "select singer.Name, concert.Theme"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who were the singers in a concert in 2014?., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "concert singer_in_concert",
        "real_label": "singer concert singer_in_concert",
        "topk_preds": [
            "concert singer_in_concert",
            "singer concert singer_in_concert",
            "stadium concert singer_in_concert",
            "",
            "stadium singer concert singer_in_concert",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What singers were present at the concert held in 2014., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What singers were present at the concert held in 2014., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t1.c1",
        "score": false,
        "real_pred": "select singer_in_concert.Singer_ID",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer_in_concert.Singer_ID",
            "select singer_in_concert.Singer_ID, concert.Theme",
            "select singer_in_concert.Singer_ID, concert.Stadium_ID",
            "select singer_in_concert.Singer_ID, concert.concert_Name",
            "select singer_in_concert.Singer_ID, singer.Name",
            "select singer_in_concert.Singer_ID, t3.c2",
            "select singer_in_concert.Singer_ID, concert.concert_ID",
            "select singer_in_concert.Singer_ID, concert.Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What singers were present at the concert held in 2014., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "concert singer_in_concert",
        "real_label": "singer concert singer_in_concert",
        "topk_preds": [
            "concert singer_in_concert",
            "singer concert singer_in_concert",
            "stadium concert singer_in_concert",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List singer names, countries ordered by age from the oldest to the youngest. And how old are they?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2, t1.c5",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2 & t1.c5",
            "SELECT-FROM-ORDER BY TI1.c1, t1.c2, t1.c5",
            "SELECT-FROM-ORDER BY TI1.C1, t1.c2, t1.c5",
            "SELECT-FROM-ORDER BY (t1.c1), t1.c2, t1.c5",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2, t1.c5.",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2 and t1.c5"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List singer names, countries ordered by age from the oldest to the youngest. And how old are they?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2, t1.c5",
        "label": "select t1.c1, t1.c2, t1.c5",
        "score": true,
        "real_pred": "select singer.Name, singer.Country, singer.Age",
        "real_label": "select singer.Name, singer.Country, singer.Age",
        "topk_preds": [
            "select singer.Name, singer.Country, singer.Age",
            "select singer.Name, singer.Country & singer.Age",
            "select singer.Name, singer.Country, singer.Age.",
            "select singer.Name, singer.Country and singer.Age",
            "select singer.Name, singer.Country, min(singer.Age)",
            "select singer.Name, singer.Country. singer.Age",
            "select singer.Name, singer.Country, singer.Age",
            "select singer.Name, singer.Country& singer.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List singer names, countries ordered by age from the oldest to the youngest. And how old are they?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show list of songs by singers above the average age., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show list of songs by singers above the average age., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select singer.Song_Name",
        "real_label": "select singer.Song_Name",
        "topk_preds": [
            "select singer.Song_Name",
            "select singer.Song_Name, singer.Song_release_year",
            "select singer.Song_Name, singer.Is_male",
            "select singer.Song_Name, singer.Age",
            "select singer.Song_Name, singer.Country",
            "select singer.Song_Name, t1.c7",
            "select singer.Song_Name - singer.Song_release_year",
            "select singer.Song_Name (singer.Song_release_year)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show list of songs by singers above the average age., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all songs by singer ages above average, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all songs by singer ages above average, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select singer.Song_Name",
        "real_label": "select singer.Song_Name",
        "topk_preds": [
            "select singer.Song_Name",
            "select singer.Song_Name, singer.Song_release_year",
            "select singer.Song_Name, singer.Age",
            "select singer.Song_Name, singer.Is_male",
            "select singer.Song_Name, singer.Country",
            "select singer.Song_Name, t1.c7",
            "select singer.Song_Name del.icio.us",
            "select singer.Song_Name de singer.Song_release_year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all songs by singer ages above average, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "singer singer_in_concert",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all songs from singers above average age., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all songs from singers above average age., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select singer.Song_Name",
        "real_label": "select singer.Song_Name",
        "topk_preds": [
            "select singer.Song_Name",
            "select singer.Song_Name, singer.Song_release_year",
            "select singer.Song_Name, singer.Is_male",
            "select singer.Song_Name, singer.Age",
            "select singer.Song_Name, singer.Country",
            "select singer.Song_Name, t1.c7",
            "select singer.Song_Name (singer.Song_release_year)",
            "select singer.Song_Name de singer.Song_release_year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all songs from singers above average age., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show stadiums and capacities with most concerts in Year 2014 or later., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUPS-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-BY-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show stadiums and capacities with most concerts in Year 2014 or later., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c2, t0.c3",
        "label": "select t0.c2, t0.c3",
        "score": true,
        "real_pred": "select stadium.Name, stadium.Capacity",
        "real_label": "select stadium.Name, stadium.Capacity",
        "topk_preds": [
            "select stadium.Name, stadium.Capacity",
            "select stadium.Location, stadium.Capacity",
            "select stadium.Stadium_ID, stadium.Name, stadium.Capacity",
            "select stadium.Name.c2, stadium.Capacity",
            "select stadium.Stadium_ID, stadium.Capacity",
            "select stadium.Name, stadium.Capacity, stadium.Average",
            "select stadium.Name.c3, stadium.Name",
            "select stadium.Capacity, stadium.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show stadiums and capacities with most concerts in Year 2014 or later., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "stadium concert",
        "real_label": "stadium concert",
        "topk_preds": [
            "stadium concert",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give the list of singers that played in concerts in 2014., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give the list of singers that played in concerts in 2014., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t1.c1",
        "score": false,
        "real_pred": "select singer_in_concert.Singer_ID",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer_in_concert.Singer_ID",
            "select singer_in_concert.Singer_ID, concert.Theme",
            "select concert.concert_ID, singer.Name",
            "select singer.Name",
            "select singer.Name, concert.concert_ID",
            "select singer_in_concert.Singer_ID, singer.Country",
            "select singer_in_concert.Singer_ID, concert.Stadium_ID",
            "select concert.concert_Name, singer.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give the list of singers that played in concerts in 2014., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "concert singer_in_concert",
        "real_label": "singer concert singer_in_concert",
        "topk_preds": [
            "concert singer_in_concert",
            "singer concert singer_in_concert",
            "stadium concert singer_in_concert",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which singers appeared in concert in 2014?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which singers appeared in concert in 2014?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t1.c1",
        "score": false,
        "real_pred": "select singer_in_concert.Singer_ID",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer_in_concert.Singer_ID",
            "select singer.Name",
            "select singer.Name, singer_in_concert.Singer_ID",
            "select singer_in_concert.Singer_ID, singer.Country",
            "select singer.Name, concert.concert_ID",
            "select singer.Name, concert.concert_Name",
            "select singer_in_concert.Singer_ID, concert.Theme",
            "select singer.Name, singer.Singer_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which singers appeared in concert in 2014?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "concert singer_in_concert",
        "real_label": "singer concert singer_in_concert",
        "topk_preds": [
            "concert singer_in_concert",
            "singer concert singer_in_concert",
            "",
            "stadium concert singer_in_concert",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: list all singers in concerts in 2014., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: list all singers in concerts in 2014., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t1.c1",
        "score": false,
        "real_pred": "select singer_in_concert.Singer_ID",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer_in_concert.Singer_ID",
            "select singer_in_concert.Singer_ID, concert.concert_Name",
            "select singer_in_concert.Singer_ID, concert.Theme",
            "select singer_in_concert.Singer_ID, concert.concert_ID",
            "select singer_in_concert.Singer_ID, concert.Stadium_ID",
            "select singer_in_concert.Singer_ID, concert.Year",
            "select singer_in_concert.Singer_ID (concert.concert_ID)",
            "select singer_in_concert.Singer_ID, t3.c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: list all singers in concerts in 2014., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "concert singer_in_concert",
        "real_label": "singer concert singer_in_concert",
        "topk_preds": [
            "concert singer_in_concert",
            "singer concert singer_in_concert",
            "",
            "stadium concert singer_in_concert",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which singers were appearing in concerts in 2014?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which singers were appearing in concerts in 2014?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t1.c1",
        "score": false,
        "real_pred": "select singer_in_concert.Singer_ID",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer_in_concert.Singer_ID",
            "select singer.Name",
            "select singer_in_concert.Singer_ID, concert.Theme",
            "select singer.Name, concert.concert_ID",
            "select singer_in_concert.Singer_ID, singer.Name",
            "select singer_in_concert.Singer_ID, singer.Country",
            "select concert.concert_Name",
            "select singer_in_concert.Singer_ID, concert.Stadium_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which singers were appearing in concerts in 2014?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "concert singer_in_concert",
        "real_label": "singer concert singer_in_concert",
        "topk_preds": [
            "concert singer_in_concert",
            "singer concert singer_in_concert",
            "",
            "stadium concert singer_in_concert",
            "",
            "stadium singer concert singer_in_concert",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show list singers in concerts in 2014., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show list singers in concerts in 2014., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t1.c1",
        "score": false,
        "real_pred": "select singer_in_concert.Singer_ID",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer_in_concert.Singer_ID",
            "select singer_in_concert.Singer_ID, concert.concert_Name",
            "select singer_in_concert.Singer_ID, concert.Theme",
            "select concert.concert_Name, singer_in_concert.Singer_ID",
            "select singer_in_concert.Singer_ID, concert.Stadium_ID",
            "select singer_in_concert.Singer_ID, concert.concert_ID",
            "select singer_in_concert.Singer_ID, concert.Year",
            "select singer_in_concert.Singer_ID, t3.c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show list singers in concerts in 2014., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "concert singer_in_concert",
        "real_label": "singer concert singer_in_concert",
        "topk_preds": [
            "concert singer_in_concert",
            "singer concert singer_in_concert",
            "",
            "stadium concert singer_in_concert",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What singers have songs with Hey in their titles? And where are they from?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C1, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What singers have songs with Hey in their titles? And where are they from?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select singer.Name, singer.Country",
        "real_label": "select singer.Name, singer.Country",
        "topk_preds": [
            "select singer.Name, singer.Country",
            "select distinct singer.Name, singer.Country",
            "select concert_singer singer.Name, singer.Country",
            "select concert_singer_singer.Name, singer.Country",
            "select singer.Name, singer.Country, singer.Song_Name",
            "select two singer.Name, singer.Country",
            "select concert_singer.Name, singer.Country",
            "select singer.Name., singer.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What singers have songs with Hey in their titles? And where are they from?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who has songs with Hey in their titles? And where are they from?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who has songs with Hey in their titles? And where are they from?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select singer.Name, singer.Country",
        "real_label": "select singer.Name, singer.Country",
        "topk_preds": [
            "select singer.Name, singer.Country",
            "select distinct singer.Name, singer.Country",
            "select singer.Name, singer.Country,",
            "select the singer.Name, singer.Country",
            "select singer.Name., singer.Country",
            "select two singer.Name, singer.Country",
            "select singer singer.Name, singer.Country",
            "select singer.Name, singer.Country."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who has songs with Hey in their titles? And where are they from?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "singer concert",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who have songs with Hey in their titles, and from which countries are they?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE t1.c1, t1.c2",
            "SELECT-FROM-WHERE, SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who have songs with Hey in their titles, and from which countries are they?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select singer.Name, singer.Country",
        "real_label": "select singer.Name, singer.Country",
        "topk_preds": [
            "select singer.Name, singer.Country",
            "select distinct singer.Name, singer.Country",
            "select singer.Name.c2, singer.Song_Name",
            "select the singer.Name, singer.Country",
            "select singer.Name, singer.Country",
            "select sing-singer.Name, singer.Country",
            "select singer.Country, singer.Name",
            "select singer.Name, singer.Country,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who have songs with Hey in their titles, and from which countries are they?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which stadiums had concerts in 2014 and 2015? And Where were they?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-CONCERT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-CONCERT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which stadiums had concerts in 2014 and 2015? And Where were they?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c2, t0.c1",
        "label": "select t0.c2, t0.c1",
        "score": true,
        "real_pred": "select stadium.Name, stadium.Location",
        "real_label": "select stadium.Name, stadium.Location",
        "topk_preds": [
            "select stadium.Name, stadium.Location",
            "select stadium.Location, stadium.Name",
            "select stadium.Stadium_ID, stadium.Location",
            "select stadium.Stadium_ID, stadium.Name, stadium.Location",
            "select stadium.Stadium_ID, stadium.Name",
            "select stadium.Name.c1, stadium.Name",
            "select stadium.Stadium_ID, stadium.Location, stadium.Name",
            "select t0.c 2, stadium.Location"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which stadiums had concerts in 2014 and 2015? And Where were they?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "stadium concert",
        "real_label": "stadium concert",
        "topk_preds": [
            "stadium concert",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which singers performed how many concerts?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY -LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT ",
            "SELECT-FROM-GROUP BY (ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which singers performed how many concerts?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, count(*)",
        "label": "select t1.c1, count(*)",
        "score": true,
        "real_pred": "select singer.Name, count(*)",
        "real_label": "select singer.Name, count(*)",
        "topk_preds": [
            "select singer.Name, count(*)",
            "select singer.Name, count(*), concert.Stadium_ID",
            "select count(*), singer.Name",
            "select singer.Name, count(*), concert.concert_Name",
            "select singer.Name, count(*), concert.concert_ID",
            "select singer.Name, count(*), concert.Theme",
            "select singer.Name, count(*), concert.Year",
            "select singer.Name, count(*), singer_in_concert.Singer_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which singers performed how many concerts?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1 t3",
        "label": "t1 t3",
        "score": true,
        "real_pred": "singer singer_in_concert",
        "real_label": "singer singer_in_concert",
        "topk_preds": [
            "singer singer_in_concert",
            "singer concert singer_in_concert",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What singers have had how many concerts?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What singers have had how many concerts?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, count(*)",
        "label": "select t1.c1, count(*)",
        "score": true,
        "real_pred": "select singer.Name, count(*)",
        "real_label": "select singer.Name, count(*)",
        "topk_preds": [
            "select singer.Name, count(*)",
            "select count(*), singer.Name",
            "select concert_singer_singer.Name, count(*)",
            "select singer.Name, count(*), concert.Stadium_ID",
            "select singer.Name, count(*), concert.concert_Name",
            "select concert_singer.Name, count(*)",
            "select singer.Name, count(*), concert.Theme",
            "select singer.Name, count(*), concert.concert_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What singers have had how many concerts?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1 t3",
        "label": "t1 t3",
        "score": true,
        "real_pred": "singer singer_in_concert",
        "real_label": "singer singer_in_concert",
        "topk_preds": [
            "singer singer_in_concert",
            "singer concert singer_in_concert",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which song were the youngest singer released, and when was it released?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which song were the youngest singer released, and when was it released?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c3, t1.c4",
        "label": "select t1.c3, t1.c4",
        "score": true,
        "real_pred": "select singer.Song_Name, singer.Song_release_year",
        "real_label": "select singer.Song_Name, singer.Song_release_year",
        "topk_preds": [
            "select singer.Song_Name, singer.Song_release_year",
            "select singer.Country, singer.Song_release_year",
            "select singer.Name, singer.Song_release_year",
            "select singer.Song_Name, singer.Song_release_year.",
            "select singer.Song_Name, t1.1.c4",
            "select singer.Song_Name, singer.Country",
            "select singer.Song_Name, singer.Song_release_year,",
            "select singer.Song_Name, t01.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which song were the youngest singer released, and when was it released?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the songs of the youngest singer and release year., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the songs of the youngest singer and release year., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c3, t1.c4",
        "label": "select t1.c3, t1.c4",
        "score": true,
        "real_pred": "select singer.Song_Name, singer.Song_release_year",
        "real_label": "select singer.Song_Name, singer.Song_release_year",
        "topk_preds": [
            "select singer.Song_Name, singer.Song_release_year",
            "select singer.Country, singer.Song_release_year",
            "select singer.Song_Name), singer.Song_release_year",
            "select singer.Song_Name, singer.Song_release_year.",
            "select singer.Song_Name, t01.c4",
            "select singer.Song_Name, singer.Song_release_year,",
            "select singer.Song_Name, singer.Country",
            "select singer.Name, singer.Song_release_year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the songs of the youngest singer and release year., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Stadiums without concerts?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Stadiums without concerts?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select stadium.Name",
        "real_label": "select stadium.Name",
        "topk_preds": [
            "select stadium.Name",
            "select stadium.Stadium_ID",
            "select stadium.Stadium_ID, stadium.Name",
            "select stadium.Location, stadium.Name",
            "select stadium.Capacity, stadium.Name",
            "select stadium.Name, stadium.Stadium_ID",
            "select stadium.Stadium_ID, stadium.Location",
            "select stadium.Name, stadium.Capacity"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Stadiums without concerts?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0 t2",
        "label": "t0",
        "score": false,
        "real_pred": "stadium concert",
        "real_label": "stadium",
        "topk_preds": [
            "stadium concert",
            "stadium",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which stadiums have not had a concert?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which stadiums have not had a concert?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c0, t0.c2",
        "label": "select t0.c2",
        "score": false,
        "real_pred": "select stadium.Stadium_ID, stadium.Name",
        "real_label": "select stadium.Name",
        "topk_preds": [
            "select stadium.Stadium_ID, stadium.Name",
            "select stadium.Name",
            "select stadium.Location, stadium.Name",
            "select stadium.Stadium_ID, stadium.Location, stadium.Name",
            "select stadium.Stadium_ID, stadium.Name, stadium.Capacity",
            "select stadium.Stadium_ID, stadium.Name, stadium.Capacity",
            "select stadium.Stadium_ID, stadium.Location",
            "select stadium.Capacity, stadium.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which stadiums have not had a concert?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "stadium",
        "real_label": "stadium",
        "topk_preds": [
            "stadium",
            "stadium concert",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show singers; show where they come from; and show their ages in descending order., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2, t1.c5",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.C1, t1.c2, t1.c5",
            "SELECT-FROM-ORDER BY TI1.c1, t1.c2, t1.c5",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2 & t1.c5",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2 and t1.c5",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2 und t1.c5"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show singers; show where they come from; and show their ages in descending order., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2, t1.c5",
        "label": "select t1.c1, t1.c2, t1.c5",
        "score": true,
        "real_pred": "select singer.Name, singer.Country, singer.Age",
        "real_label": "select singer.Name, singer.Country, singer.Age",
        "topk_preds": [
            "select singer.Name, singer.Country, singer.Age",
            "select singer.Singer_ID, singer.Country, singer.Age",
            "select singer.Name, singer.Country, singer.Age",
            "select singer.Name, singer.Country & singer.Age",
            "select singer.Name., singer.Country, singer.Age",
            "select singer.Name, singer.Country, singer.Age",
            "select singer.Name ; singer.Country ; singer.Age",
            "select singer.Name, singer.Country and singer.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show singers; show where they come from; and show their ages in descending order., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the largest attended stadium on average? And how much is the capacity?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the largest attended stadium on average? And how much is the capacity?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c2, t0.c3",
        "label": "select t0.c2, t0.c3",
        "score": true,
        "real_pred": "select stadium.Name, stadium.Capacity",
        "real_label": "select stadium.Name, stadium.Capacity",
        "topk_preds": [
            "select stadium.Name, stadium.Capacity",
            "select stadium.Capacity, avg(concert.Year)",
            "select stadium.Capacity, stadium.Highest",
            "select stadium.Location, stadium.Capacity",
            "select avg(stadium.Highest), avg(stadium.Capacity)",
            "select stadium.Stadium_ID, avg(t2.c8)",
            "select stadium.Stadium_ID, avg(concert.Year)",
            "select stadium.Capacity, avg(t2.c8)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the largest attended stadium on average? And how much is the capacity?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0 t2",
        "label": "t0",
        "score": false,
        "real_pred": "stadium concert",
        "real_label": "stadium",
        "topk_preds": [
            "stadium concert",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What stations have capacity between 5000 and 10000? And Where are they?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What stations have capacity between 5000 and 10000? And Where are they?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select stadium.Location, stadium.Name",
        "real_label": "select stadium.Location, stadium.Name",
        "topk_preds": [
            "select stadium.Location, stadium.Name",
            "select stadium.Stadium_ID, stadium.Location",
            "select stadium.Name, stadium.Location",
            "select stadium.Location.c2, stadium.Location",
            "select stadium.Location, stadium.Name.",
            "select t0.c 1, stadium.Name",
            "select stadium.Location, stadium.Name",
            "select stadium.Location, stadium.Name,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What stations have capacity between 5000 and 10000? And Where are they?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "stadium",
        "real_label": "stadium",
        "topk_preds": [
            "stadium",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which songs did the youngest singer sing, and what were their release years?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which songs did the youngest singer sing, and what were their release years?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c3, t1.c4",
        "label": "select t1.c3, t1.c4",
        "score": true,
        "real_pred": "select singer.Song_Name, singer.Song_release_year",
        "real_label": "select singer.Song_Name, singer.Song_release_year",
        "topk_preds": [
            "select singer.Song_Name, singer.Song_release_year",
            "select singer.Country, singer.Song_release_year",
            "select singer.Name, singer.Song_release_year",
            "select singer.Song_Name.c4, singer.Song_Name",
            "select singer.Country, singer.Song_Name",
            "select singer.Song_Name, singer.Country",
            "select singer.Song_Name), singer.Song_release_year",
            "select singer.Song_Name, t01.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which songs did the youngest singer sing, and what were their release years?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which songs did the youngest singer sing, and when were they released?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which songs did the youngest singer sing, and when were they released?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c3, t1.c4",
        "label": "select t1.c3, t1.c4",
        "score": true,
        "real_pred": "select singer.Song_Name, singer.Song_release_year",
        "real_label": "select singer.Song_Name, singer.Song_release_year",
        "topk_preds": [
            "select singer.Song_Name, singer.Song_release_year",
            "select singer.Country, singer.Song_release_year",
            "select singer.Song_Name, singer.Song_release_year.",
            "select singer.Name, singer.Song_release_year",
            "select singer.Song_Name, singer.Country",
            "select singer.Song_Name, t01.c4",
            "select singer.Song_Name, singer.Song_release_year,",
            "select singer.Country, singer.Song_Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which songs did the youngest singer sing, and when were they released?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find how old are pets on average and show maximum of them for each type., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY, AVERAGE-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY, avg(t2.c2), max(t2.c2)",
            "SELECT-FROM-GROUP BY, AVG-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY, AVG(t2.c2), max(t2.c2)",
            "SELECT-FROM-GROUP BY, AVERAGE(t2.c2), max(t2.c2)",
            "SELECT-FROM-GROUP BY, AVERAGE-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find how old are pets on average and show maximum of them for each type., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select avg(t2.c2), max(t2.c2), t2.c1",
        "label": "select avg(t2.c2), max(t2.c2), t2.c1",
        "score": true,
        "real_pred": "select avg(Pets.pet_age), max(Pets.pet_age), Pets.PetType",
        "real_label": "select avg(Pets.pet_age), max(Pets.pet_age), Pets.PetType",
        "topk_preds": [
            "select avg(Pets.pet_age), max(Pets.pet_age), Pets.PetType",
            "select Pets.PetType, avg(Pets.pet_age), max(Pets.pet_age)",
            "select avg(Pets.pet_age), Pets.PetType",
            "select avg(Pets.pet_age), min(Pets.pet_age), Pets.PetType",
            "select max(Pets.pet_age), avg(Pets.pet_age), Pets.PetType",
            "select Pets.PetType, avg(Pets.pet_age)",
            "select Pets.PetID, avg(Pets.pet_age), max(Pets.pet_age)",
            "select min(Pets.pet_age), avg(Pets.pet_age), Pets.PetType"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find how old are pets on average and show maximum of them for each type., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old are pets on average for each type, and what is the largest age for each type of pet?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY max(t2.c2), SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY maximum(t2.c2), SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY (Avg(t2.c2), max(t2.c2)",
            "SELECT-FROM-GROUP BY maximum(t2.c2), AVG(t2.c2)",
            "SELECT-FROM-GROUP BY maximum(t2.c2), SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY max(t2.c2), SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old are pets on average for each type, and what is the largest age for each type of pet?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t2.c1, avg(t2.c2), max(t2.c2)",
        "label": "select avg(t2.c2), max(t2.c2), t2.c1",
        "score": false,
        "real_pred": "select Pets.PetType, avg(Pets.pet_age), max(Pets.pet_age)",
        "real_label": "select avg(Pets.pet_age), max(Pets.pet_age), Pets.PetType",
        "topk_preds": [
            "select Pets.PetType, avg(Pets.pet_age), max(Pets.pet_age)",
            "select avg(Pets.pet_age), max(Pets.pet_age), Pets.PetType",
            "select Pets.PetType, avg(Pets.pet_age)",
            "select Pets.PetType, avg(Pets.pet_age), max(Pets.pet_age)",
            "select pettype, avg(Pets.pet_age), max(Pets.pet_age)",
            "select average(Pets.pet_age), max(Pets.pet_age), Pets.PetType",
            "select min(Pets.pet_age), avg(Pets.pet_age), Pets.PetType",
            "select max(Pets.pet_age), avg(Pets.pet_age), Pets.PetType"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old are pets on average for each type, and what is the largest age for each type of pet?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old are students without pet on average?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-AVERAGE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old are students without pet on average?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select avg(t0.c3)",
        "label": "select avg(t0.c3)",
        "score": true,
        "real_pred": "select avg(Student.Age)",
        "real_label": "select avg(Student.Age)",
        "topk_preds": [
            "select avg(Student.Age)",
            "select an avg(Student.Age)",
            "select avg(Student.Age), Student.StuID",
            "select avg(t0-Student.Age)",
            "select  avg(Student.Age)",
            "select Avg(Student.Age)",
            "select avg(Student.Age), Has_Pet.StuID",
            "select avg(Student.Age),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old are students without pet on average?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Student",
        "real_label": "Student",
        "topk_preds": [
            "Student",
            "Student Has_Pet",
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old is the average student who does not own any pet animals?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old is the average student who does not own any pet animals?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select avg(t0.c3)",
        "label": "select avg(t0.c3)",
        "score": true,
        "real_pred": "select avg(Student.Age)",
        "real_label": "select avg(Student.Age)",
        "topk_preds": [
            "select avg(Student.Age)",
            "select avg(Student.Age), Student.Sex",
            "select an avg(Student.Age)",
            "select avg(Student.Age), Student.StuID",
            "select avg(Student.Age), Student.Fname",
            "select avg(t0-Student.Age)",
            "select avg(Student.Age), Student.Advisor",
            "select avg(Student.Age), Student.Major"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old is the average student who does not own any pet animals?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Student",
        "real_label": "Student",
        "topk_preds": [
            "Student",
            "Student Has_Pet Pets",
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How much does each type of pet weigh, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY (UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY (UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-GROUP BY (ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How much does each type of pet weigh, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t2.c1, sum(t2.c3)",
        "label": "select avg(t2.c3), t2.c1",
        "score": false,
        "real_pred": "select Pets.PetType, sum(Pets.weight)",
        "real_label": "select avg(Pets.weight), Pets.PetType",
        "topk_preds": [
            "select Pets.PetType, sum(Pets.weight)",
            "select Pets.PetType, Pets.weight",
            "select Pets.PetType, max(Pets.weight)",
            "select Pets.PetType, average(Pets.weight)",
            "select Pets.PetType, avg(Pets.weight)",
            "select Pets.PetType, sum(Pets.weight), Pets.weight",
            "select distinct Pets.PetType, sum(Pets.weight)",
            "select distinct Pets.PetType, Pets.weight"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How much does each type of pet weigh, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How much heavy is each type of pet?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY (UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY (SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY (UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY pet2.c1, max(t2.c3)",
            "SELECT-FROM-GROUP BY-ORDER BY pet2.c1, sum(t2.c3)",
            "SELECT-FROM-GROUP BY-ORDER BY pet2.c1, t2.c3"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How much heavy is each type of pet?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t2.c1, sum(t2.c3)",
        "label": "select avg(t2.c3), t2.c1",
        "score": false,
        "real_pred": "select Pets.PetType, sum(Pets.weight)",
        "real_label": "select avg(Pets.weight), Pets.PetType",
        "topk_preds": [
            "select Pets.PetType, sum(Pets.weight)",
            "select Pets.PetType, Pets.weight",
            "select Pets.PetType, max(Pets.weight)",
            "select Pets.PetType, avg(Pets.weight)",
            "select Pets.PetType, average(Pets.weight)",
            "select Pets.PetType, min(Pets.weight)",
            "select distinct Pets.PetType, Pets.weight",
            "select distinct Pets.PetType, sum(Pets.weight)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How much heavy is each type of pet?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which pets are older than one year? Show id and how much do they weigh?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which pets are older than one year? Show id and how much do they weigh?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t2.c0, t2.c3",
        "label": "select t2.c0, t2.c3",
        "score": true,
        "real_pred": "select Pets.PetID, Pets.weight",
        "real_label": "select Pets.PetID, Pets.weight",
        "topk_preds": [
            "select Pets.PetID, Pets.weight",
            "select Pets.PetID, Pets.weight.",
            "select Pets.PetID, Pets.weight)",
            "select Pets.PetID, Pets.weight,",
            "select Pets.PetType, Pets.weight",
            "select Pets.PetID-, Pets.weight",
            "select Pets.PetID, Pets.weight3",
            "select Pets.PetID0, Pets.weight"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which pets are older than one year? Show id and how much do they weigh?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the first names of students that have a dog but no cats as pets. And how old are they?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog, cat), c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE but-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE BUT-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the first names of students that have a dog but no cats as pets. And how old are they?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog, cat), c2: pet_age, c3: weight).",
        "prediction": "select t0.c2, t0.c3",
        "label": "select t0.c2, t0.c3",
        "score": true,
        "real_pred": "select Student.Fname, Student.Age",
        "real_label": "select Student.Fname, Student.Age",
        "topk_preds": [
            "select Student.Fname, Student.Age",
            "select Student.LName, Student.Age",
            "select Student.LName, Student.Fname, Student.Age",
            "select Student.StuID, Student.Fname, Student.Age",
            "select Student.Fname, Student.Age, Student.Sex",
            "select Student.Age, Student.Fname",
            "select Student.Fname, Student.Fname, Student.Age",
            "select Student.Fname.c3, Student.Fname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the first names of students that have a dog but no cats as pets. And how old are they?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog, cat), c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who has a pet? Show the first name and how old?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who has a pet? Show the first name and how old?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t0.c2, t0.c3",
        "label": "select distinct t0.c2, t0.c3",
        "score": false,
        "real_pred": "select Student.Fname, Student.Age",
        "real_label": "select distinct Student.Fname, Student.Age",
        "topk_preds": [
            "select Student.Fname, Student.Age",
            "select Student.Fname, Pets.pet_age",
            "select distinct Student.Fname, Student.Age",
            "select Student.LName, Student.Age",
            "select Student.Fname, t02.c2",
            "select Student.Fname, t1.c3",
            "select Student.Fname, t1.c2",
            "select Student.Fname, Student.Fname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who has a pet? Show the first name and how old?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1",
        "score": false,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How heavy is the youngest dog?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-OF-ORDER BY-LIMIT",
            "SELECT-FROM-CATEGORY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How heavy is the youngest dog?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "select t2.c3",
        "label": "select t2.c3",
        "score": true,
        "real_pred": "select Pets.weight",
        "real_label": "select Pets.weight",
        "topk_preds": [
            "select Pets.weight",
            "select max(Pets.weight)",
            "select min(Pets.weight)",
            "select Pets.weight, Pets.pet_age",
            "select max(Pets.weight), Pets.pet_age",
            "select Pets.weight)",
            "select Pets.weight.c3",
            "select maximum(Pets.weight)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How heavy is the youngest dog?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "Student Pets",
            "Has_Pet Pets",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How much did the youngest dog weigh, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How much did the youngest dog weigh, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "select t2.c3",
        "label": "select t2.c3",
        "score": true,
        "real_pred": "select Pets.weight",
        "real_label": "select Pets.weight",
        "topk_preds": [
            "select Pets.weight",
            "select min(Pets.weight)",
            "select max(Pets.weight)",
            "select Pets.PetID, Pets.weight",
            "select Pets.PetID, max(Pets.weight)",
            "select Pets.weight, Pets.pet_age",
            "select Pets.weight)",
            "select Pets.PetID, min(Pets.weight)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How much did the youngest dog weigh, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How heavy is the youngest dog?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-OF-ORDER BY-LIMIT",
            "SELECT-FROM-CATEGORY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How heavy is the youngest dog?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "select t2.c3",
        "label": "select t2.c3",
        "score": true,
        "real_pred": "select Pets.weight",
        "real_label": "select Pets.weight",
        "topk_preds": [
            "select Pets.weight",
            "select max(Pets.weight)",
            "select min(Pets.weight)",
            "select Pets.weight, Pets.pet_age",
            "select max(Pets.weight), Pets.pet_age",
            "select Pets.weight)",
            "select Pets.weight.c3",
            "select maximum(Pets.weight)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How heavy is the youngest dog?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "Student Pets",
            "Has_Pet Pets",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How much does the youngest dog weigh?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-CATEGORY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How much does the youngest dog weigh?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "select t2.c3",
        "label": "select t2.c3",
        "score": true,
        "real_pred": "select Pets.weight",
        "real_label": "select Pets.weight",
        "topk_preds": [
            "select Pets.weight",
            "select min(Pets.weight)",
            "select max(Pets.weight)",
            "select Pets.weight, Pets.pet_age",
            "select max(Pets.weight), Pets.pet_age",
            "select min(Pets.weight), Pets.pet_age",
            "select Pets.weight)",
            "select Pets.weight, max(Pets.weight)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How much does the youngest dog weigh?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old are the students who own pets and what are their first names?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-INTERSECT-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-WITH",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old are the students who own pets and what are their first names?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t0.c3, t0.c2",
        "label": "select distinct t0.c2, t0.c3",
        "score": false,
        "real_pred": "select Student.Age, Student.Fname",
        "real_label": "select distinct Student.Fname, Student.Age",
        "topk_preds": [
            "select Student.Age, Student.Fname",
            "select Student.Fname, Student.Age",
            "select distinct Student.Fname, Student.Age",
            "select distinct Student.Age, Student.Fname",
            "select Student.LName, Student.Fname",
            "select age(Student.Age), Student.Fname",
            "select Has_Pet.StuID, Student.Fname",
            "select t1.c3, Student.Fname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old are the students who own pets and what are their first names?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Student Has_Pet",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet",
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What type is the youngest pet, and how much does it weigh?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What type is the youngest pet, and how much does it weigh?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t2.c1, t2.c3",
        "label": "select t2.c1, t2.c3",
        "score": true,
        "real_pred": "select Pets.PetType, Pets.weight",
        "real_label": "select Pets.PetType, Pets.weight",
        "topk_preds": [
            "select Pets.PetType, Pets.weight",
            "select Pets.PetID, Pets.PetType, Pets.weight",
            "select Pets.PetType, Pets.weight, Pets.pet_age",
            "select Pets.PetType.c1, Pets.weight",
            "select Pets.PetType, Pets.weight)",
            "select t2.c type, Pets.weight",
            "select t2.ctype, Pets.weight",
            "select Pets.PetType, Pets.weight, max(Pets.pet_age)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What type is the youngest pet, and how much does it weigh?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old are students on average who don't own pets?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old are students on average who don't own pets?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select avg(t0.c3)",
        "label": "select avg(t0.c3)",
        "score": true,
        "real_pred": "select avg(Student.Age)",
        "real_label": "select avg(Student.Age)",
        "topk_preds": [
            "select avg(Student.Age)",
            "select an avg(Student.Age)",
            "select avg(Student.Age), Student.StuID",
            "select avg(Student.Age), Student.Sex",
            "select avg(Student.Age), Student.Fname",
            "select avg(t0-Student.Age)",
            "select  avg(Student.Age)",
            "select avg(Student.Age), Student.LName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old are students on average who don't own pets?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Student",
        "real_label": "Student",
        "topk_preds": [
            "Student",
            "Student Has_Pet",
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old are kids with no pets on average, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AVERAGE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old are kids with no pets on average, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select avg(t0.c3)",
        "label": "select avg(t0.c3)",
        "score": true,
        "real_pred": "select avg(Student.Age)",
        "real_label": "select avg(Student.Age)",
        "topk_preds": [
            "select avg(Student.Age)",
            "select an avg(Student.Age)",
            "select avg(t0-Student.Age)",
            "select Avg(Student.Age)",
            "select  avg(Student.Age)",
            "select avg(Student.Age),",
            "select avg(tStudent.Age)",
            "select avg(Student.Age)."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old are kids with no pets on average, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Student",
        "real_label": "Student",
        "topk_preds": [
            "Student",
            "Student Has_Pet Pets",
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How much are animals of each type weighting, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY (UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY pet2.c1, sum(t2.c3)",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-GROUP BY (UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How much are animals of each type weighting, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t2.c1, sum(t2.c3)",
        "label": "select avg(t2.c3), t2.c1",
        "score": false,
        "real_pred": "select Pets.PetType, sum(Pets.weight)",
        "real_label": "select avg(Pets.weight), Pets.PetType",
        "topk_preds": [
            "select Pets.PetType, sum(Pets.weight)",
            "select Pets.PetType, max(Pets.weight)",
            "select Pets.PetType, Pets.weight",
            "select distinct Pets.PetType, sum(Pets.weight)",
            "select Pets.PetType, average(Pets.weight)",
            "select pettype, sum(Pets.weight)",
            "select Pets.PetType, Pets.weight",
            "select type, sum(Pets.weight)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How much are animals of each type weighting, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How heavy are pets on average for each type, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY (Avg(t2.c3)",
            "SELECT-FROM-GROUP BY (avg(t2.c3)",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-GROUP BY.",
            "SELECT-FROM-GROUPS-GROUP BY",
            "SELECT-FROM-GROUP BY "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How heavy are pets on average for each type, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t2.c1, avg(t2.c3)",
        "label": "select avg(t2.c3), t2.c1",
        "score": false,
        "real_pred": "select Pets.PetType, avg(Pets.weight)",
        "real_label": "select avg(Pets.weight), Pets.PetType",
        "topk_preds": [
            "select Pets.PetType, avg(Pets.weight)",
            "select avg(Pets.weight), Pets.PetType",
            "select pettype, avg(Pets.weight)",
            "select Pets.PetType, Avg(Pets.weight)",
            "select type Pets.PetType, avg(Pets.weight)",
            "select Pets.PetType, avg(Pets.weight)",
            "select type, avg(Pets.weight)",
            "select average(Pets.weight), Pets.PetType"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How heavy are pets on average for each type, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List which countries has at least one car-maker, and mention their id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM -GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List which countries has at least one car-maker, and mention their id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c0, t1.c1",
        "label": "select t1.c1, t1.c0",
        "score": false,
        "real_pred": "select countries.CountryId, countries.CountryName",
        "real_label": "select countries.CountryName, countries.CountryId",
        "topk_preds": [
            "select countries.CountryId, countries.CountryName",
            "select countries.CountryId, car_makers.Country",
            "select countries.CountryId, car_makers.Maker",
            "select distinct countries.CountryId, countries.CountryName",
            "select countries.CountryId, countries.CountryName.c1",
            "select countries.CountryId, countries.CountryName.",
            "select countries.CountryName, car_makers.Id",
            "select countries.CountryName, countries.CountryId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List which countries has at least one car-maker, and mention their id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "countries car_makers model_list",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show names for car makers along with id and how many models., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM for t2.c1, count(*)",
            "SELECT-FROM-GROUP BY SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY t2.c1, count(*)",
            "SELECT-FROM-GROUP BY t2.c2, count(*)",
            "SELECT-FROM-GROUP BY t2.c0, count(*)",
            "SELECT-FROM PER-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show names for car makers along with id and how many models., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2, t3.c1, count(*)",
        "label": "select t2.c2, t2.c0, count(*)",
        "score": false,
        "real_pred": "select car_makers.FullName, model_list.Maker, count(*)",
        "real_label": "select car_makers.FullName, car_makers.Id, count(*)",
        "topk_preds": [
            "select car_makers.FullName, model_list.Maker, count(*)",
            "select car_makers.Maker, count(*)",
            "select car_makers.FullName, model_list.ModelId, count(*)",
            "select car_makers.Maker, model_list.ModelId, count(*)",
            "select car_makers.FullName, count(*)",
            "select car_makers.Maker, model_list.Maker, count(*)",
            "select car_makers.FullName, car_names.Model, count(*)",
            "select car_makers.FullName, car_names.MakeId, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show names for car makers along with id and how many models., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t2 t3",
        "score": false,
        "real_pred": "car_makers model_list car_names",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "car_makers model_list car_names",
            "continents car_makers model_list car_names",
            "countries model_list car_names",
            "",
            "model_list car_names",
            "",
            "car_makers model_list",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Full name of each car maker, along with its id and how many models., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY ORDINARY-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-GROUP BY ORDINARY-ORDER BY",
            "SELECT-FROM-GROUP BY TI3.C1, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Full name of each car maker, along with its id and how many models., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2, t3.c1, count(*)",
        "label": "select t2.c2, t2.c0, count(*)",
        "score": false,
        "real_pred": "select car_makers.FullName, model_list.Maker, count(*)",
        "real_label": "select car_makers.FullName, car_makers.Id, count(*)",
        "topk_preds": [
            "select car_makers.FullName, model_list.Maker, count(*)",
            "select car_makers.FullName, car_names.Model, count(*)",
            "select car_makers.FullName, car_names.MakeId, count(*)",
            "select car_makers.Maker, model_list.Maker, count(*)",
            "select car_makers.Maker, car_names.MakeId, count(*)",
            "select car_makers.FullName, car_makers.Id, count(*)",
            "select car_makers.FullName, model_list.ModelId, count(*)",
            "select car_makers.FullName, count(*), model_list.Maker"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Full name of each car maker, along with its id and how many models., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t2 t3",
        "score": false,
        "real_pred": "car_makers model_list car_names",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "car_makers model_list car_names",
            "",
            "",
            "",
            "",
            "countries car_makers model_list car_names",
            "car_makers car_names",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: list makers cars along with their identifications and how many models they produce., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY (t3.c1) et count(*)",
            "SELECT-FROM-GROUP BY (t2.c0, count(*)",
            "SELECT-FROM-GROUP BY (t3.c1), count(*)",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY (t2.c1), count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: list makers cars along with their identifications and how many models they produce., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c0, count(*)",
        "label": "select t2.c2, t2.c0, count(*)",
        "score": false,
        "real_pred": "select car_makers.Id, count(*)",
        "real_label": "select car_makers.FullName, car_makers.Id, count(*)",
        "topk_preds": [
            "select car_makers.Id, count(*)",
            "select car_makers.Maker, count(*)",
            "select car_makers.FullName, model_list.Maker, count(*)",
            "select car_makers.Maker, model_list.Maker, count(*)",
            "select model_list.Maker, count(*)",
            "select car_makers.Id, count(*), car_makers.FullName",
            "select car_makers.Maker, car_makers.FullName, count(*)",
            "select car_makers.Id, count(*), model_list.Maker"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: list makers cars along with their identifications and how many models they produce., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "car_makers model_list",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "car_makers model_list",
            "car_makers model_list car_names",
            "model_list car_makers",
            "model_list car_names",
            "continents car_makers model_list",
            "",
            "countries model_list",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What country does not include cars?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM",
            "SELECT-FROM-STRICT-EXCEPT-SELECT-FROM",
            "SELECT-FROM-A-EXCEPT-SELECT-FROM",
            "SELECT-FROM-HAVE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM t2.c3",
            "SELECT-FROM- EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What country does not include cars?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, countries.Continent",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName (countries.CountryId)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What country does not include cars?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "countries",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name the countries with no car manufacturers, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EN-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name the countries with no car manufacturers, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, countries.Continent",
            "select countries.CountryName, t0.c2",
            "select countries.CountryId, countries.CountryName",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, continents.ContId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name the countries with no car manufacturers, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "countries",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name countries without car makers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name countries without car makers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, countries.Continent",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryId, countries.CountryName",
            "select countries.CountryName, t1.c3",
            "select countries.CountryName (countries.CountryId)",
            "select countries.CountryName, t1.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name countries without car makers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1",
        "label": "t1 t2",
        "score": false,
        "real_pred": "countries",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries",
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the country that do not have car makers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EN-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-A-EXCEPT-SELECT-FROM",
            "SELECT-FROM-HOLD-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the country that do not have car makers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, countries.Continent",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryId, countries.CountryName",
            "select countries.CountryName, continents.ContId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the country that do not have car makers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "countries",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name the countries where there is no car manufacturer, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name the countries where there is no car manufacturer, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, countries.Continent",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryId, countries.CountryName",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, continents.ContId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name the countries where there is no car manufacturer, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "countries",
            "",
            "countries car_makers model_list",
            "",
            "",
            "",
            "countries car_makers car_names"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me which countries do not have car makers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EN-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-HOLD-EXCEPT-SELECT-FROM",
            "SELECT-FROM-A-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me which countries do not have car makers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryId, countries.CountryName",
            "select countries.CountryName, countries.Continent",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, car_makers.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me which countries do not have car makers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "countries",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What countries don't have car makers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EN-EXCEPT-SELECT-FROM",
            "SELECT-FROM-STRICT-EXCEPT-SELECT-FROM",
            "SELECT-FROM-A-EXCEPT-SELECT-FROM",
            "SELECT-FROM-HOLD-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What countries don't have car makers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, countries.Continent",
            "select countries.CountryId, countries.CountryName",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, t1.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What countries don't have car makers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "countries",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: State which countries do not have a car maker., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: State which countries do not have a car maker., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryId, countries.CountryName",
            "select countries.CountryName, countries.Continent",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, t1.c3",
            "select countries.CountryName (countries.CountryId)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: State which countries do not have a car maker., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1",
        "label": "t1 t2",
        "score": false,
        "real_pred": "countries",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries",
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How much do cars weigh on average per year?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM GIGA-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM GIGA-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How much do cars weigh on average per year?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c5), t5.c7",
        "label": "select avg(t5.c5), t5.c7",
        "score": true,
        "real_pred": "select avg(cars_data.Weight), cars_data.Year",
        "real_label": "select avg(cars_data.Weight), cars_data.Year",
        "topk_preds": [
            "select avg(cars_data.Weight), cars_data.Year",
            "select avg(cars_data.Weight)",
            "select avg(cars_data.Weight)/cars_data.Year",
            "select an avg(cars_data.Weight), cars_data.Year",
            "select avg(cars_data.Weight) / cars_data.Year",
            "select avg(cars_data.Weight), t55.c7",
            "select avg(cars_data.Weight) per year",
            "select Avg(cars_data.Weight), cars_data.Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How much do cars weigh on average per year?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How heavy were different cars each year on average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How heavy were different cars each year on average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c5), t5.c7",
        "label": "select avg(t5.c5), t5.c7",
        "score": true,
        "real_pred": "select avg(cars_data.Weight), cars_data.Year",
        "real_label": "select avg(cars_data.Weight), cars_data.Year",
        "topk_preds": [
            "select avg(cars_data.Weight), cars_data.Year",
            "select cars_data.Year, avg(cars_data.Weight)",
            "select min(cars_data.Weight), avg(cars_data.Weight)",
            "select cars_data.Weight, avg(cars_data.Weight)",
            "select car_cars_data.Year, avg(cars_data.Weight)",
            "select accu(cars_data.Weight), cars_data.Year",
            "select average(cars_data.Weight), cars_data.Year",
            "select avg(cars_data.Weight), t55.c7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How heavy were different cars each year on average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How much do cars weigh each year on average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY CENTURY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How much do cars weigh each year on average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c5), t5.c7",
        "label": "select avg(t5.c5), t5.c7",
        "score": true,
        "real_pred": "select avg(cars_data.Weight), cars_data.Year",
        "real_label": "select avg(cars_data.Weight), cars_data.Year",
        "topk_preds": [
            "select avg(cars_data.Weight), cars_data.Year",
            "select cars_data.Year, avg(cars_data.Weight)",
            "select min(cars_data.Weight), avg(cars_data.Weight)",
            "select accu(cars_data.Weight), cars_data.Year",
            "select an avg(cars_data.Weight), cars_data.Year",
            "select avg(cars_data.Weight), t55.c7",
            "select c7, avg(cars_data.Weight)",
            "select min(cars_data.Weight), cars_data.Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How much do cars weigh each year on average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List every european country, which has at least three manufacturars., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAGROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List every european country, which has at least three manufacturars., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, t0.c4",
            "select countries.CountryName, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List every european country, which has at least three manufacturars., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "continents car_makers",
            "",
            "",
            "",
            "",
            "",
            "continents countries"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which country is known as the country with many automakers (car companies)?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which country is known as the country with many automakers (car companies)?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, countries.Continent",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, t1.c3",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName (countries.CountryId)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which country is known as the country with many automakers (car companies)?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name of country with most car makers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GEOGRAPHY-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name of country with most car makers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName (countries.Continent)",
            "select countries.CountryName, countries.Continent",
            "select countries.CountryName (countries.CountryId)",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, t0.c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name of country with most car makers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the country with the largest number of car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the country with the largest number of car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName commensurate with count(*)",
            "select countries.CountryName pour car_makers.Country",
            "select countries.CountryName commensurate with car_makers.Country",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, countries.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the country with the largest number of car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which airport with code AKO?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AKO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AKO), c3: destairport (AKO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which airport with code AKO?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AKO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AKO), c3: destairport (AKO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select airports.AirportName",
        "real_label": "select airports.AirportName",
        "topk_preds": [
            "select airports.AirportName",
            "select airports.City, airports.AirportName",
            "select airports.AirportName, airports.Country",
            "select avg(airports.AirportName)",
            "select airports.AirportName, airports.AirportCode",
            "select airports.AirportNameaeroprom-with-the-IATA-C1",
            "select airports.AirportNameaeroprom-with-serial-number",
            "select airports.AirportNameaeroprom-with-airports.AirportCode"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which airport with code AKO?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AKO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AKO), c3: destairport (AKO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "airports",
        "real_label": "airports",
        "topk_preds": [
            "airports",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Tell what airport has code AKO., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AKO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AKO), c3: destairport (AKO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Tell what airport has code AKO., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AKO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AKO), c3: destairport (AKO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select airports.AirportName",
        "real_label": "select airports.AirportName",
        "topk_preds": [
            "select airports.AirportName",
            "select airports.City, airports.AirportName",
            "select airports.AirportName, airports.Country",
            "select airports.AirportName, airports.Country, airports.CountryAbbrev",
            "select airports.AirportNameaeroprom-with-the-letter airports.AirportCode",
            "select airports.AirportNameaeroprom-with-hash",
            "select airports.AirportNameaeroprom-with-the-letter-a.c1",
            "select airports.AirportNameaeroprom-WHERE"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Tell what airport has code AKO., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AKO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AKO), c3: destairport (AKO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "airports",
        "real_label": "airports",
        "topk_preds": [
            "airports",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which airport has code 'AKO'?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AKO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AKO), c3: destairport (AKO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which airport has code 'AKO'?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AKO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AKO), c3: destairport (AKO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select airports.AirportName",
        "real_label": "select airports.AirportName",
        "topk_preds": [
            "select airports.AirportName",
            "select airports.City, airports.AirportName",
            "select airports.AirportName, airports.Country",
            "select airports.AirportName, airports.AirportCode",
            "select airports.AirportName,",
            "select airports.AirportName, airports.City",
            "select airports.AirportName, airports.CountryAbbrev",
            "select airports.AirportName, t1.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which airport has code 'AKO'?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AKO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AKO), c3: destairport (AKO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "airports",
        "real_label": "airports",
        "topk_preds": [
            "airports",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: what airport has code AKO, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AKO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AKO), c3: destairport (AKO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INSERT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: what airport has code AKO, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AKO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AKO), c3: destairport (AKO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select airports.AirportName",
        "real_label": "select airports.AirportName",
        "topk_preds": [
            "select airports.AirportName",
            "select airports.City, airports.AirportName",
            "select airports.AirportName, airports.Country",
            "select airports.AirportName, airports.AirportCode",
            "select airports.AirportNameaeroprom-WHERE",
            "select airports.AirportName, airports.City",
            "select airports.AirportName, airports.CountryAbbrev",
            "select airports.AirportName, t1.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: what airport has code AKO, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AKO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AKO), c3: destairport (AKO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "airports",
        "real_label": "airports",
        "topk_preds": [
            "airports",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which airport has code AKO?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AKO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AKO), c3: destairport (AKO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which airport has code AKO?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AKO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AKO), c3: destairport (AKO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select airports.AirportName",
        "real_label": "select airports.AirportName",
        "topk_preds": [
            "select airports.AirportName",
            "select airports.City, airports.AirportName",
            "select airports.AirportName, airports.Country",
            "select airports.AirportName, airports.AirportCode",
            "select airports.AirportNameaeroprom-WHERE",
            "select airports.AirportName,",
            "select airports.AirportName, airports.City",
            "select airports.AirportName, airports.CountryAbbrev"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which airport has code AKO?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AKO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AKO), c3: destairport (AKO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "airports",
        "real_label": "airports",
        "topk_preds": [
            "airports",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which airports don't have flights in or Out?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-SECT-FROM-EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which airports don't have flights in or Out?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select airports.AirportName",
        "real_label": "select airports.AirportName",
        "topk_preds": [
            "select airports.AirportName",
            "select airports.AirportCode, airports.AirportName",
            "select airports.City, airports.AirportName",
            "select airports.AirportName, airports.AirportCode",
            "select airports.AirportName, flights.SourceAirport",
            "select airports.AirportName, flights.DestAirport",
            "select airports.AirportName, airports.Country",
            "select airports.City, airports.AirportCode"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which airports don't have flights in or Out?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "airports",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which airport has no flights in or out., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which airport has no flights in or out., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select airports.AirportName",
        "real_label": "select airports.AirportName",
        "topk_preds": [
            "select airports.AirportName",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportName, flights.SourceAirport",
            "select airports.AirportName, flights.SourceAirport, flights.DestAirport",
            "select airports.City, airports.AirportName",
            "select airports.AirportName, airports.AirportCode",
            "select airports.AirportCode, airports.AirportName, airports.Country",
            "select airports.AirportName, airports.AirportCode, airports.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which airport has no flights in or out., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "airports",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give the airport which have no flight in and out., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give the airport which have no flight in and out., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select airports.AirportName",
        "real_label": "select airports.AirportName",
        "topk_preds": [
            "select airports.AirportName",
            "select airports.AirportCode, airports.AirportName",
            "select airports.City, airports.AirportName",
            "select airports.AirportName, flights.SourceAirport",
            "select airports.AirportName, airports.AirportCode",
            "select airports.AirportName, flights.DestAirport",
            "select airports.AirportName, airports.Country",
            "select airports.City, airports.AirportCode"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give the airport which have no flight in and out., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "airports",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What airports do we have at Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What airports do we have at Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select airports.AirportName",
        "real_label": "select airports.AirportName",
        "topk_preds": [
            "select airports.AirportName",
            "select airports.City, airports.AirportCode, airports.AirportName",
            "select airports.AirportName, airports.AirportCode",
            "select airports.AirportCode, airports.AirportName",
            "select airports.City, airports.AirportName",
            "select airports.City, airports.Country, airports.AirportName",
            "select airports.AirportName, airports.AirportCode, airports.Country",
            "select airports.City, airports.AirportCode & airports.AirportName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What airports do we have at Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "airports",
        "real_label": "airports",
        "topk_preds": [
            "airports",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which airports are in city 'Aberdeen'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which airports are in city 'Aberdeen'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select airports.AirportName",
        "real_label": "select airports.AirportName",
        "topk_preds": [
            "select airports.AirportName",
            "select airports.AirportName, airports.AirportCode",
            "select airports.City, airports.AirportName",
            "select airports.AirportCode, airports.AirportName",
            "select airports.City, airports.AirportCode, airports.AirportName",
            "select airports.AirportName, airports.AirportCode, airports.Country",
            "select airports.AirportName, airports.AirportCode, airports.AirportCode",
            "select airports.AirportName, airports.AirportCode, airports.City"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which airports are in city 'Aberdeen'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "airports",
        "real_label": "airports",
        "topk_preds": [
            "airports",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What airports are there at city Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What airports are there at city Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select airports.AirportName",
        "real_label": "select airports.AirportName",
        "topk_preds": [
            "select airports.AirportName",
            "select airports.AirportName, airports.AirportCode",
            "select airports.City, airports.AirportCode, airports.AirportName",
            "select airports.City, airports.AirportName",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportName, airports.AirportCode, airports.Country",
            "select airports.AirportName (https://airports.AirportCode, airports.AirportCode)",
            "select airports.City, airports.AirportName, airports.AirportCode"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What airports are there at city Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "airports",
        "real_label": "airports",
        "topk_preds": [
            "airports",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What airports are there in Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROMWHERE",
            "SELECT-FROM-WHERE (SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What airports are there in Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select airports.AirportName",
        "real_label": "select airports.AirportName",
        "topk_preds": [
            "select airports.AirportName",
            "select airports.City, airports.AirportCode, airports.AirportName",
            "select airports.City, airports.AirportName",
            "select airports.AirportName, airports.AirportCode",
            "select airports.AirportCode, airports.AirportName",
            "select airports.City, airports.Country, airports.AirportName",
            "select airports.AirportName, airports.AirportCode, airports.Country",
            "select airports.City, airports.AirportName, airports.AirportCode"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What airports are there in Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "airports",
        "real_label": "airports",
        "topk_preds": [
            "airports",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Where do JetBlue Airlines belong to?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INSERT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Where do JetBlue Airlines belong to?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c3",
        "label": "select t0.c3",
        "score": true,
        "real_pred": "select airlines.Country",
        "real_label": "select airlines.Country",
        "topk_preds": [
            "select airlines.Country",
            "select airlines.Country, airlines.Abbreviation",
            "select airlines.Abbreviation, airlines.Country",
            "select airlines.Airline, airlines.Country",
            "select airlines.Country, t0.c4",
            "select airlines.Country, airlines.Airline",
            "select airlines.Country (select airlines.Abbreviation)",
            "select t0, airlines.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Where do JetBlue Airlines belong to?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Where are Jetblue Airways affiliated to., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INSERT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Where are Jetblue Airways affiliated to., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c3",
        "label": "select t0.c3",
        "score": true,
        "real_pred": "select airlines.Country",
        "real_label": "select airlines.Country",
        "topk_preds": [
            "select airlines.Country",
            "select airlines.Country, airlines.Abbreviation",
            "select airlines.Country, t0.c4",
            "select distinct airlines.Country",
            "select airlines.Airline, airlines.Country",
            "select airlines.Country (symbol airlines.Abbreviation)",
            "select airlines.Country, airlines.Airline",
            "select airlines.Country (symbol airlines.Airline)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Where are Jetblue Airways affiliated to., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "airlines airports",
            "airlines flights",
            "",
            "",
            "",
            "",
            "airlines airports flights"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which airports in Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROMWHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which airports in Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select airports.AirportName",
        "real_label": "select airports.AirportName",
        "topk_preds": [
            "select airports.AirportName",
            "select airports.City, airports.AirportName",
            "select airports.City, airports.AirportCode, airports.AirportName",
            "select airports.AirportName, airports.AirportCode",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportName, airports.AirportCode, airports.Country",
            "select avg(airports.AirportName)",
            "select airports.City, airports.Country, airports.AirportName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which airports in Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "airports",
        "real_label": "airports",
        "topk_preds": [
            "airports",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which airports are in Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which airports are in Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select airports.AirportName",
        "real_label": "select airports.AirportName",
        "topk_preds": [
            "select airports.AirportName",
            "select airports.City, airports.AirportCode, airports.AirportName",
            "select airports.AirportName, airports.AirportCode",
            "select airports.AirportCode, airports.AirportName",
            "select airports.City, airports.AirportName",
            "select airports.City, airports.Country, airports.AirportName",
            "select airports.City, airports.AirportCode & airports.AirportName",
            "select airports.AirportName, airports.AirportCode, airports.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which airports are in Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "airports",
        "real_label": "airports",
        "topk_preds": [
            "airports",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What airports are there in Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROMWHERE",
            "SELECT-FROM-WHERE (SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What airports are there in Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select airports.AirportName",
        "real_label": "select airports.AirportName",
        "topk_preds": [
            "select airports.AirportName",
            "select airports.City, airports.AirportCode, airports.AirportName",
            "select airports.City, airports.AirportName",
            "select airports.AirportName, airports.AirportCode",
            "select airports.AirportCode, airports.AirportName",
            "select airports.City, airports.Country, airports.AirportName",
            "select airports.AirportName, airports.AirportCode, airports.Country",
            "select airports.City, airports.AirportName, airports.AirportCode"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What airports are there in Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "airports",
        "real_label": "airports",
        "topk_preds": [
            "airports",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What airports do we have in Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What airports do we have in Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select airports.AirportName",
        "real_label": "select airports.AirportName",
        "topk_preds": [
            "select airports.AirportName",
            "select airports.City, airports.AirportCode, airports.AirportName",
            "select airports.AirportName, airports.AirportCode",
            "select airports.AirportCode, airports.AirportName",
            "select airports.City, airports.AirportName",
            "select airports.City, airports.Country, airports.AirportName",
            "select airports.AirportName, airports.AirportCode, airports.Country",
            "select airports.City, airports.AirportCode & airports.AirportName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What airports do we have in Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "airports",
        "real_label": "airports",
        "topk_preds": [
            "airports",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which airlines are there in the USA? And Their abbreviations?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country (USA)). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which airlines are there in the USA? And Their abbreviations?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country (USA)). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select airlines.Airline, airlines.Abbreviation",
        "real_label": "select airlines.Airline, airlines.Abbreviation",
        "topk_preds": [
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.uid, airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation, airlines.Country",
            "select t0.c 1, airlines.Abbreviation",
            "select airlines.Airline.c2, airlines.Airline",
            "select airlines.Airline, airlines.Abbreviation,",
            "select airlines.Airline, airlines.Abbreviation",
            "select distinct airlines.Airline, airlines.Abbreviation"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which airlines are there in the USA? And Their abbreviations?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country (USA)). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What airlines exist in USA? and what are their abbreviations?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country (USA)). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What airlines exist in USA? and what are their abbreviations?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country (USA)). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select airlines.Airline, airlines.Abbreviation",
        "real_label": "select airlines.Airline, airlines.Abbreviation",
        "topk_preds": [
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.uid, airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation, airlines.Country",
            "select airlines.Airline.c2, airlines.Airline",
            "select t0.c 1, airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation,",
            "select airlines.Airline, airlines.Abbreviation2",
            "select distinct airlines.Airline, airlines.Abbreviation"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What airlines exist in USA? and what are their abbreviations?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country (USA)). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name all airlines in USA with their abbrevs, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country (USA)). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name all airlines in USA with their abbrevs, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country (USA)). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select airlines.Airline, airlines.Abbreviation",
        "real_label": "select airlines.Airline, airlines.Abbreviation",
        "topk_preds": [
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.uid, airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation, airlines.Country",
            "select airlines.Airline, airlines.Abbreviation, airlines.Abbreviation",
            "select t0.c 1, airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation,",
            "select airlines.Airline, t0.c 2",
            "select airlines.Airline, airlines.Abbreviation"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name all airlines in USA with their abbrevs, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country (USA)). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Write down every airline and its abbreviation in USA., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country (USA)). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Write down every airline and its abbreviation in USA., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country (USA)). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select airlines.Airline, airlines.Abbreviation",
        "real_label": "select airlines.Airline, airlines.Abbreviation",
        "topk_preds": [
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation, airlines.Country",
            "select airlines.Airline.c1, airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation2",
            "select airlines.Airline, airlines.Abbreviation,",
            "select t0.c 1, airlines.Abbreviation",
            "select airlines.uid, airlines.Abbreviation",
            "select airlines.Airline, airlines.uid2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Write down every airline and its abbreviation in USA., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country (USA)). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show airport codes and airports in the city of Anthony., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Anthony), c1: airportcode, c2: airportname (Anthony), c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show airport codes and airports in the city of Anthony., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Anthony), c1: airportcode, c2: airportname (Anthony), c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select airports.AirportCode, airports.AirportName",
        "real_label": "select airports.AirportCode, airports.AirportName",
        "topk_preds": [
            "select airports.AirportCode, airports.AirportName",
            "select avg(airports.AirportCode), avg(airports.AirportName)",
            "select avg(airports.AirportCode), airports.AirportName",
            "select airports.AirportCode.c1, airports.AirportName",
            "select airports.AirportCode, airports.AirportName, airports.City",
            "select airports.AirportCode, airports.AirportName,",
            "select airports.AirportCode, airports.AirportName2",
            "select avc1, airports.AirportName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show airport codes and airports in the city of Anthony., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Anthony), c1: airportcode, c2: airportname (Anthony), c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "airports",
        "real_label": "airports",
        "topk_preds": [
            "airports",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Where is airline \u201cJetblue Airway\u201d from?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Where is airline \u201cJetblue Airway\u201d from?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c3",
        "label": "select t0.c3",
        "score": true,
        "real_pred": "select airlines.Country",
        "real_label": "select airlines.Country",
        "topk_preds": [
            "select airlines.Country",
            "select airlines.Country, airlines.Abbreviation",
            "select airlines.Airline, airlines.Country",
            "select airlines.Country, t0.c4",
            "select airlines.Country, airlines.Airline",
            "select airlines.Country,",
            "select t0-airlines.Country",
            "select airlines.Country, t0.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Where is airline \u201cJetblue Airway\u201d from?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Where is Airline JetBlue Airways from?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Where is Airline JetBlue Airways from?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c3",
        "label": "select t0.c3",
        "score": true,
        "real_pred": "select airlines.Country",
        "real_label": "select airlines.Country",
        "topk_preds": [
            "select airlines.Country",
            "select airlines.Country, airlines.Abbreviation",
            "select airlines.Airline, airlines.Country",
            "select airlines.Abbreviation, airlines.Country",
            "select airlines.Country, t0.c4",
            "select airlines.Country (select airlines.Abbreviation)",
            "select t0, airlines.Country",
            "select airlines.Country, airlines.Airline"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Where is Airline JetBlue Airways from?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: which airport is AKO?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AKO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AKO), c3: destairport (AKO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: which airport is AKO?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AKO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AKO), c3: destairport (AKO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select airports.AirportName",
        "real_label": "select airports.AirportName",
        "topk_preds": [
            "select airports.AirportName",
            "select airports.City, airports.AirportName",
            "select avg(airports.AirportName)",
            "select airports.AirportName, airports.AirportCode",
            "select airports.AirportName, airports.AirportCode, airports.Country",
            "select airports.AirportName dependant on airports.AirportCode",
            "select airports.City, airports.AirportName, airports.Country",
            "select airports.AirportName, airports.AirportCode - airports.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: which airport is AKO?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AKO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AKO), c3: destairport (AKO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "airports",
        "real_label": "airports",
        "topk_preds": [
            "airports",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which employee has been awarded the most times during the evalutation?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which employee has been awarded the most times during the evalutation?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select employee.Name",
        "real_label": "select employee.Name",
        "topk_preds": [
            "select employee.Name",
            "select employee.Name, evaluation.Employee_ID",
            "select employee.Name, employee.Employee_ID",
            "select employee.Employee_ID, employee.Name",
            "select employee.Name, employee.City",
            "select employee.Name, employee.Age",
            "select employee.Name, evaluation.Employee_ID",
            "select employee.Name, evaluation.Bonus"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which employee has been awarded the most times during the evalutation?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0 t3",
        "label": "t0 t3",
        "score": true,
        "real_pred": "employee evaluation",
        "real_label": "employee evaluation",
        "topk_preds": [
            "employee evaluation",
            "employee hiring evaluation",
            "employee shop evaluation",
            "",
            "employee hiring",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which employee was awarded the most times in the evaluation?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which employee was awarded the most times in the evaluation?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select employee.Name",
        "real_label": "select employee.Name",
        "topk_preds": [
            "select employee.Name",
            "select employee.Name, evaluation.Employee_ID",
            "select employee.Name, employee.Employee_ID",
            "select employee.Employee_ID, employee.Name",
            "select employee.Name, employee.City",
            "select employee.Name, employee.Age",
            "select employee.Name, evaluation.Employee_ID",
            "select employee.Name, t03.c0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which employee was awarded the most times in the evaluation?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0 t3",
        "label": "t0 t3",
        "score": true,
        "real_pred": "employee evaluation",
        "real_label": "employee evaluation",
        "topk_preds": [
            "employee evaluation",
            "employee hiring evaluation",
            "employee shop evaluation",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: which employee has received the most awards during an evaluation?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: which employee has received the most awards during an evaluation?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select employee.Name",
        "real_label": "select employee.Name",
        "topk_preds": [
            "select employee.Name",
            "select employee.Name, evaluation.Employee_ID",
            "select employee.Name, employee.Employee_ID",
            "select employee.Name, employee.City",
            "select employee.Employee_ID, employee.Name",
            "select employee.Name, employee.Age",
            "select employee.Name, evaluation.Bonus",
            "select employee.Name, t03.c0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: which employee has received the most awards during an evaluation?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0 t3",
        "label": "t0 t3",
        "score": true,
        "real_pred": "employee evaluation",
        "real_label": "employee evaluation",
        "topk_preds": [
            "employee evaluation",
            "employee hiring evaluation",
            "employee shop evaluation",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which employee has been awarded most in evaluatio?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which employee has been awarded most in evaluatio?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select employee.Name",
        "real_label": "select employee.Name",
        "topk_preds": [
            "select employee.Name",
            "select employee.Name, evaluation.Employee_ID",
            "select employee.Name, employee.Employee_ID",
            "select employee.Employee_ID, employee.Name",
            "select employee.Name, employee.City",
            "select employee.Name, employee.Age",
            "select employee.Name, t03.c0",
            "select evaluation.Employee_ID, employee.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which employee has been awarded most in evaluatio?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0 t3",
        "label": "t0 t3",
        "score": true,
        "real_pred": "employee evaluation",
        "real_label": "employee evaluation",
        "topk_preds": [
            "employee evaluation",
            "employee hiring evaluation",
            "",
            "employee shop evaluation",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who had the highest number of awards during an evaluation?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GIG-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who had the highest number of awards during an evaluation?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select employee.Name",
        "real_label": "select employee.Name",
        "topk_preds": [
            "select employee.Name",
            "select employee.Name, employee.City",
            "select employee.Name, evaluation.Employee_ID",
            "select employee.Name, evaluation.Bonus",
            "select employee.Name, employee.Age",
            "select employee.Name, evaluation.Year_awarded",
            "select employee.Name, shop.District",
            "select employee.Name, t03.c0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who had the highest number of awards during an evaluation?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0 t3",
        "label": "t0 t3",
        "score": true,
        "real_pred": "employee evaluation",
        "real_label": "employee evaluation",
        "topk_preds": [
            "employee evaluation",
            "employee hiring evaluation",
            "employee shop evaluation",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show managers and districts of shops that sell most products, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show managers and districts of shops that sell most products, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c5, t1.c3",
        "label": "select t1.c5, t1.c3",
        "score": true,
        "real_pred": "select shop.Manager_name, shop.District",
        "real_label": "select shop.Manager_name, shop.District",
        "topk_preds": [
            "select shop.Manager_name, shop.District",
            "select shop.Manager_name, shop.Location",
            "select shop.Manager_name, shop.District,",
            "select shop.Name, shop.District",
            "select shop.Manager_name, shop.District.",
            "select shop.Number_products, shop.District",
            "select shop.Location, shop.District",
            "select shop.District, shop.Manager_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show managers and districts of shops that sell most products, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who is the manager of the shop that has the most products and which district does this shop belong to?., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who is the manager of the shop that has the most products and which district does this shop belong to?., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c5, t1.c3",
        "label": "select t1.c5, t1.c3",
        "score": true,
        "real_pred": "select shop.Manager_name, shop.District",
        "real_label": "select shop.Manager_name, shop.District",
        "topk_preds": [
            "select shop.Manager_name, shop.District",
            "select shop.Name, shop.District",
            "select shop.Manager_name, shop.Location",
            "select shop.Location, shop.District",
            "select shop.Manager_name, shop.District,",
            "select shop.Manager_name, shop.District.",
            "select shop.District, shop.Manager_name",
            "select shop.Number_products, shop.District"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who is the manager of the shop that has the most products and which district does this shop belong to?., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Manager who work at this shop that has sold the greatest number of products, and which District do they belong to?., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Manager who work at this shop that has sold the greatest number of products, and which District do they belong to?., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c5, t1.c3",
        "label": "select t1.c5, t1.c3",
        "score": true,
        "real_pred": "select shop.Manager_name, shop.District",
        "real_label": "select shop.Manager_name, shop.District",
        "topk_preds": [
            "select shop.Manager_name, shop.District",
            "select shop.Manager_name, shop.Location",
            "select shop.Name, shop.District",
            "select shop.Location, shop.District",
            "select shop.Manager_name.c5, shop.District",
            "select shop.Manager_name, shop.District,",
            "select shop.Manager_name, shop.District.",
            "select shop.District, shop.Manager_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Manager who work at this shop that has sold the greatest number of products, and which District do they belong to?., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are managers of the shop selling most products? Districts?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are managers of the shop selling most products? Districts?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c5",
        "label": "select t1.c5, t1.c3",
        "score": false,
        "real_pred": "select shop.Manager_name",
        "real_label": "select shop.Manager_name, shop.District",
        "topk_preds": [
            "select shop.Manager_name",
            "select shop.Manager_name, shop.District",
            "select shop.Manager_name (shop.District), shop.Location",
            "select shop.Manager_name dependant on shop.District, shop.Location",
            "select shop.Manager_name (shop.District), shop.District",
            "select shop.Manager_name dependant on shop.District",
            "select shop.Manager_name dependant on shop.Location, shop.District",
            "select shop.Manager_name, shop.District"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are managers of the shop selling most products? Districts?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which manager is responsible for the shop that sells the most products? And which district does it belong to?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which manager is responsible for the shop that sells the most products? And which district does it belong to?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c5, t1.c3",
        "label": "select t1.c5, t1.c3",
        "score": true,
        "real_pred": "select shop.Manager_name, shop.District",
        "real_label": "select shop.Manager_name, shop.District",
        "topk_preds": [
            "select shop.Manager_name, shop.District",
            "select shop.Manager_name, shop.Location",
            "select shop.Name, shop.District",
            "select shop.Location, shop.District",
            "select shop.Manager_name, shop.District,",
            "select shop.Manager_name, shop.District.",
            "select shop.District, shop.Manager_name",
            "select shop.Number_products, shop.District"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which manager is responsible for the shop that sells the most products? And which district does it belong to?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For each shop, how many people work there and what is the shop called?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY (t1.c1), SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY SELECT-FROM-GROUP BY",
            "SELECT-FROM-GEOGRAPHY-GROUP BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For each shop, how many people work there and what is the shop called?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1, count(*)",
        "label": "select count(*), t1.c1",
        "score": false,
        "real_pred": "select shop.Name, count(*)",
        "real_label": "select count(*), shop.Name",
        "topk_preds": [
            "select shop.Name, count(*)",
            "select count(*), shop.Name",
            "select shop.Name, count(*), shop.Location",
            "select shop shop.Name, count(*)",
            "select t1, count(*), shop.Name",
            "select shop.Name, count(*), hiring.Shop_ID",
            "select shop.Name, count(*), shop.Shop_ID",
            "select shop_shop.Name, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For each shop, how many people work there and what is the shop called?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "shop hiring",
        "real_label": "shop hiring",
        "topk_preds": [
            "shop hiring",
            "employee shop hiring",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: which employees have not won awards during an evaluation period?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: which employees have not won awards during an evaluation period?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select employee.Employee_ID",
        "real_label": "select employee.Name",
        "topk_preds": [
            "select employee.Employee_ID",
            "select employee.Name",
            "select employee.Name, employee.City",
            "select employee.Employee_ID, employee.Name",
            "select employee.Name, employee.Age",
            "select employee.Name, employee.Employee_ID",
            "select employee.Name, employee.Employee_ID3",
            "select employee.Name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: which employees have not won awards during an evaluation period?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0 t3",
        "label": "t0",
        "score": false,
        "real_pred": "employee evaluation",
        "real_label": "employee",
        "topk_preds": [
            "employee evaluation",
            "employee",
            "employee hiring evaluation",
            "employee shop evaluation",
            "employee hiring",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who have never been awarded during an evaluation, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who have never been awarded during an evaluation, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select employee.Name",
        "real_label": "select employee.Name",
        "topk_preds": [
            "select employee.Name",
            "select *",
            "select employee.Employee_ID",
            "select employee.Name, employee.City",
            "select employee.Name, employee.Age",
            "select employee.Name, employee.Employee_ID",
            "select employee.Name, evaluation.Employee_ID",
            "select employee.Name, evaluation.Bonus"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who have never been awarded during an evaluation, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "employee",
        "real_label": "employee",
        "topk_preds": [
            "employee",
            "employee evaluation",
            "employee hiring evaluation",
            "employee hiring",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name some shops whose number products are higher than average, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name some shops whose number products are higher than average, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.Number_products",
            "select shop.Name, shop.District",
            "select shop.Name, shop.Manager_name",
            "select shop.Name, t1.c6",
            "select shop.Name, shop.Shop_ID",
            "select shop.Name, t1.c7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name some shops whose number products are higher than average, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Where do you have shops that sell fewer than 3000 products or those selling more than 10000 products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE or-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE OR-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE,-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-2-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Where do you have shops that sell fewer than 3000 products or those selling more than 10000 products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c2",
        "label": "select t1.c3",
        "score": false,
        "real_pred": "select shop.Location",
        "real_label": "select shop.District",
        "topk_preds": [
            "select shop.Location",
            "select shop.Location, shop.District",
            "select shop.Location dependant on whether you have shop.Name, shop.Location",
            "select shop.Location dependant on whether you have shop.Name or shop.Location",
            "select shop.Location dependant on whether you have shop.Name",
            "select shop.Location dependant on whether you have shop.Name ou shop.Location",
            "select shop.Location dependant on whether you have shop.District, shop.Number_products",
            "select shop.Location, shop.District, max(shop.Number_products)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Where do you have shops that sell fewer than 3000 products or those selling more than 10000 products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name all employees and sort in ascending order by their age., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY (t0.c1)",
            "SELECT-FROM-ORDER BY t0",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY t0.c1"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name all employees and sort in ascending order by their age., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select employee.Name, employee.Age",
        "real_label": "select employee.Name",
        "topk_preds": [
            "select employee.Name, employee.Age",
            "select employee.Name",
            "select employee.Name, employee.Age, employee.City",
            "select employee.Name, employee.Age, employee.City",
            "select employee.Name&sort(employee.Age)",
            "select employee.Name and employee.Age",
            "select employee.Name, employee.City",
            "select employee.Name, employee.Age, employee.City"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name all employees and sort in ascending order by their age., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "employee",
        "real_label": "employee",
        "topk_preds": [
            "employee",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show list of employee and rank by how old in ascending order., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY t0",
            "SELECT-FROM-ORDER BY (t0.c1)",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY(t0.c1)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show list of employee and rank by how old in ascending order., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select employee.Name, employee.Age",
        "real_label": "select employee.Name",
        "topk_preds": [
            "select employee.Name, employee.Age",
            "select employee.Employee_ID, employee.Name, employee.Age",
            "select employee.Employee_ID, employee.Name",
            "select employee.Name, employee.City",
            "select employee.Name, employee.Age, employee.City",
            "select employee.Name, age(employee.Age)",
            "select employee.Name, employee.Age in employee.City",
            "select employee.Employee_ID, employee.Name, employee.City"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show list of employee and rank by how old in ascending order., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "employee",
        "real_label": "employee",
        "topk_preds": [
            "employee",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which shop has the most workers?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GIG-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which shop has the most workers?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, hiring.Shop_ID",
            "select shop.Name, hiring.Employee_ID",
            "select shop.Name, hiring.Start_from",
            "select shop.Name, shop.Location",
            "select shop.Name, hiring.Is_full_time",
            "select shop.Name, shop.District",
            "select shop.Name, shop.Shop_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which shop has the most workers?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "shop hiring",
        "real_label": "shop hiring",
        "topk_preds": [
            "shop hiring",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Choose the shop which has most employees., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Choose the shop which has most employees., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, hiring.Start_from",
            "select shop.Name, shop.Location",
            "select shop.Name, hiring.Shop_ID",
            "select shop.Name, hiring.Employee_ID",
            "select shop.Name, shop.District",
            "select shop.Name, hiring.Is_full_time",
            "select shop.Name (shop.Location)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Choose the shop which has most employees., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "shop hiring",
        "real_label": "shop hiring",
        "topk_preds": [
            "shop hiring",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name that shop with most employees!, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name that shop with most employees!, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, hiring.Shop_ID",
            "select shop.Name, hiring.Employee_ID",
            "select shop.Name, hiring.Start_from",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.District",
            "select shop.Name, hiring.Is_full_time",
            "select shop.Name, shop.Manager_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name that shop with most employees!, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "shop hiring",
        "real_label": "shop hiring",
        "topk_preds": [
            "shop hiring",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who has received the highest once off bonus?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who has received the highest once off bonus?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select employee.Name",
        "real_label": "select employee.Name",
        "topk_preds": [
            "select employee.Name",
            "select evaluation.Year_awarded",
            "select evaluation.Employee_ID, employee.Name",
            "select employee.Name, evaluation.Employee_ID",
            "select employee.Name, employee.Age",
            "select evaluation.Employee_ID, evaluation.Year_awarded",
            "select employee.Name, employee.City",
            "select employee.Name, evaluation.Bonus"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who has received the highest once off bonus?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0 t3",
        "label": "t0 t3",
        "score": true,
        "real_pred": "employee evaluation",
        "real_label": "employee evaluation",
        "topk_preds": [
            "employee evaluation",
            "evaluation",
            "employee hiring evaluation",
            "hiring evaluation",
            "shop evaluation",
            "employee shop evaluation",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the person who received the most one-time bonus., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GEOGRAPHY-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the person who received the most one-time bonus., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select employee.Name",
        "real_label": "select employee.Name",
        "topk_preds": [
            "select employee.Name",
            "select employee.Name, evaluation.Employee_ID",
            "select employee.Name, employee.Age",
            "select employee.Name, employee.City",
            "select employee.Name, evaluation.Bonus",
            "select employee.Employee_ID, employee.Name",
            "select employee.Name, evaluation.Year_awarded",
            "select employee.Name, employee.Employee_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the person who received the most one-time bonus., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0 t3",
        "label": "t0 t3",
        "score": true,
        "real_pred": "employee evaluation",
        "real_label": "employee evaluation",
        "topk_preds": [
            "employee evaluation",
            "employee hiring evaluation",
            "employee shop evaluation",
            "hiring evaluation",
            "shop evaluation",
            "",
            "",
            "evaluation"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which Employee has been given highest one-time Bonus., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which Employee has been given highest one-time Bonus., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select employee.Name",
        "real_label": "select employee.Name",
        "topk_preds": [
            "select employee.Name",
            "select evaluation.Employee_ID",
            "select employee.Employee_ID, employee.Name",
            "select employee.Name, evaluation.Employee_ID",
            "select employee.Name, employee.Employee_ID",
            "select evaluation.Employee_ID, employee.Name",
            "select employee.Employee_ID, evaluation.Year_awarded",
            "select employee.Name, employee.City"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which Employee has been given highest one-time Bonus., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0 t3",
        "label": "t0 t3",
        "score": true,
        "real_pred": "employee evaluation",
        "real_label": "employee evaluation",
        "topk_preds": [
            "employee evaluation",
            "evaluation",
            "",
            "",
            "hiring evaluation",
            "shop evaluation",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What shops don't hire anybody., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-ELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-HOLD-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What shops don't hire anybody., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, shop.Location",
            "select shop.Name, hiring.Shop_ID",
            "select shop.Name, hiring.Start_from",
            "select shop.Name, shop.District",
            "select shop.Name, shop.Shop_ID",
            "select shop.Name, hiring.Employee_ID",
            "select shop.Name, hiring.Is_full_time"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What shops don't hire anybody., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "shop hiring",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which stores do not hire any employee?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which stores do not hire any employee?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.Location, shop.District",
            "select shop.Name, shop.Location, shop.District",
            "select shop.Name, shop.District",
            "select shop.Name, shop.Location, shop.District, shop.Number_products",
            "select shop.Name, shop.Location, shop.District, shop.Location",
            "select shop.Name, shop.Location, shop.District, shop.District"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which stores do not hire any employee?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "shop hiring",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What stores are there that don't employ anyone?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What stores are there that don't employ anyone?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.Location, shop.District",
            "select shop.Name, shop.District",
            "select shop.Name, shop.District, shop.Number_products",
            "select shop.Name, shop.District, shop.Location",
            "select shop.Name, shop.Shop_ID",
            "select shop.Name de-select shop.Shop_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What stores are there that don't employ anyone?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "shop hiring",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which shops don't hire any workers?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which shops don't hire any workers?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.District",
            "select shop.Name, shop.Shop_ID",
            "select shop.Name, hiring.Start_from",
            "select shop.Name, hiring.Shop_ID",
            "select shop.Name (shop.Shop_ID)",
            "select shop.Name, shop.Number_products"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which shops don't hire any workers?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "shop hiring",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What shops don't hire anybody?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-HOLD-EXCEPT-SELECT-FROM",
            "SELECT-FROM-ELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What shops don't hire anybody?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, shop.Location",
            "select shop.Name, hiring.Start_from",
            "select shop.Name, shop.District",
            "select shop.Name, hiring.Shop_ID",
            "select shop.Name, shop.Shop_ID",
            "select shop.Name, hiring.Employee_ID",
            "select shop.Name (shop.Shop_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What shops don't hire anybody?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "shop hiring",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: In which shop do they hire most people, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GEOGRAPHY-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: In which shop do they hire most people, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, hiring.Shop_ID",
            "select shop.Name, hiring.Employee_ID",
            "select shop.Name, shop.Location",
            "select shop.Name, hiring.Start_from",
            "select shop.Name, shop.District",
            "select shop.Name, hiring.Is_full_time",
            "select shop.Name pour hiring.Employee_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: In which shop do they hire most people, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "shop hiring",
        "real_label": "shop hiring",
        "topk_preds": [
            "shop hiring",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which store is hiring the most people?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUPS-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GEOGRAPHY-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which store is hiring the most people?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, hiring.Shop_ID",
            "select shop.Name, hiring.Employee_ID",
            "select shop.Name, hiring.Start_from",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.District",
            "select shop.Name, hiring.Is_full_time",
            "select shop.Name (shop.Location)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which store is hiring the most people?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "shop hiring",
        "real_label": "shop hiring",
        "topk_preds": [
            "shop hiring",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which stores have a number products greater than the average product of what stores?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which stores have a number products greater than the average product of what stores?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, shop.Shop_ID",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.District",
            "select shop.Name, shop.Number_products",
            "select distinct shop.Name, shop.Location",
            "select distinct shop.Name, shop.Shop_ID",
            "select distinct shop.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which stores have a number products greater than the average product of what stores?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What stores have more products than average?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What stores have more products than average?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, shop.Shop_ID",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.District",
            "select shop.Name, shop.Number_products",
            "select distinct shop.Name",
            "select shop.Shop_ID, shop.Name",
            "select shop.Name, t1.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What stores have more products than average?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: list documents using template with template type code BK., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (BK), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (BK), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: list documents using template with template type code BK., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (BK), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (BK), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c2",
        "label": "select t2.c2",
        "score": true,
        "real_pred": "select Documents.Document_Name",
        "real_label": "select Documents.Document_Name",
        "topk_preds": [
            "select Documents.Document_Name",
            "select Documents.Document_Name, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Documents.Document_ID",
            "select Documents.Document_ID, Templates.Template_Type_Code",
            "select Documents.Document_ID, Templates.Version_Number",
            "select Documents.Document_ID, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Template_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: list documents using template with template type code BK., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (BK), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (BK), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "Ref_Template_Types Templates Documents",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which documents use templates with the code BK?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (BK), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (BK), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which documents use templates with the code BK?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (BK), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (BK), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c2",
        "label": "select t2.c2",
        "score": true,
        "real_pred": "select Documents.Document_Name",
        "real_label": "select Documents.Document_Name",
        "topk_preds": [
            "select Documents.Document_Name",
            "select Documents.Document_Name, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Documents.Document_ID",
            "select Documents.Document_ID, Documents.Template_ID",
            "select Documents.Template_ID",
            "select Documents.Document_ID, Templates.Version_Number",
            "select Documents.Document_ID, Templates.Template_Type_Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which documents use templates with the code BK?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (BK), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (BK), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "Ref_Template_Types Templates Documents",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What documents that use template with code BK?., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (BK), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (BK), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What documents that use template with code BK?., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (BK), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (BK), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c2",
        "label": "select t2.c2",
        "score": true,
        "real_pred": "select Documents.Document_Name",
        "real_label": "select Documents.Document_Name",
        "topk_preds": [
            "select Documents.Document_Name",
            "select Documents.Document_Name, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Documents.Template_ID, Documents.Document_Name",
            "select Documents.Document_Name, Documents.Other_Details",
            "select Documents.Document_Name und Documents.Document_Description",
            "select Documents.Document_Name and Documents.Document_Description",
            "select Documents.Document_ID, Documents.Template_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What documents that use template with code BK?., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (BK), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (BK), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "Ref_Template_Types Templates Documents",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are documents that use template with code BK?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (BK), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (BK), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are documents that use template with code BK?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (BK), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (BK), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c2",
        "label": "select t2.c2",
        "score": true,
        "real_pred": "select Documents.Document_Name",
        "real_label": "select Documents.Document_Name",
        "topk_preds": [
            "select Documents.Document_Name",
            "select Documents.Document_Name, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Documents.Document_Name, Documents.Document_Description, Documents.Other_Details",
            "select Documents.Document_ID, Documents.Document_Name, Documents.Document_Description",
            "select Documents.Document_Name, Documents.Document_Description, Documents.Document_Description",
            "select Documents.Document_Name, Documents.Document_Description, Documents.Other_Details",
            "select Documents.Template_ID, Documents.Document_Description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are documents that use template with code BK?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (BK), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (BK), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "Ref_Template_Types Templates Documents",
            "",
            "Documents",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show letter w documents names and ids, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-C2, t2.c0",
            "SELECT-FROM-C2, SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show letter w documents names and ids, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c2, t2.c0",
        "label": "select t2.c2, t2.c1",
        "score": false,
        "real_pred": "select Documents.Document_Name, Documents.Document_ID",
        "real_label": "select Documents.Document_Name, Documents.Template_ID",
        "topk_preds": [
            "select Documents.Document_Name, Documents.Document_ID",
            "select Documents.Document_Name, Documents.Document_ID, Documents.Template_ID",
            "select Documents.Document_Name, Documents.Document_ID, Documents.Template_ID",
            "select Documents.Template_ID, Documents.Document_ID",
            "select Documents.Other_Details, Documents.Document_Name",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Documents.Other_Details, Documents.Document_Name, Documents.Document_ID",
            "select Documents.Document_Name-, Documents.Document_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show letter w documents names and ids, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Documents",
        "real_label": "Documents",
        "topk_preds": [
            "Documents",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give names and template ID\u2019s for documents which has the letter \u201cw\u201d in them., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give names and template ID\u2019s for documents which has the letter \u201cw\u201d in them., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c2, t2.c1",
        "label": "select t2.c2, t2.c1",
        "score": true,
        "real_pred": "select Documents.Document_Name, Documents.Template_ID",
        "real_label": "select Documents.Document_Name, Documents.Template_ID",
        "topk_preds": [
            "select Documents.Document_Name, Documents.Template_ID",
            "select Documents.Document_ID, Documents.Document_Name, Documents.Template_ID",
            "select Documents.Template_ID, Documents.Document_Name",
            "select Documents.Document_Name, Documents.Template_ID, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Documents.Other_Details, Documents.Document_Name",
            "select Documents.Document_Name, Documents.Template_ID, Documents.Document_ID",
            "select t2.c5, Documents.Template_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give names and template ID\u2019s for documents which has the letter \u201cw\u201d in them., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Documents",
        "real_label": "Documents",
        "topk_preds": [
            "Documents",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find documents containing the letter w in its name and what are their template, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INDEX-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find documents containing the letter w in its name and what are their template, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c2, t2.c1",
        "label": "select t2.c2, t2.c1",
        "score": true,
        "real_pred": "select Documents.Document_Name, Documents.Template_ID",
        "real_label": "select Documents.Document_Name, Documents.Template_ID",
        "topk_preds": [
            "select Documents.Document_Name, Documents.Template_ID",
            "select Documents.Document_ID, Documents.Template_ID",
            "select Documents.Template_ID, Documents.Document_Name",
            "select Documents.Document_Name, Templates.Template_Details",
            "select Documents.Document_ID, t2.c5",
            "select Documents.Other_Details, Documents.Template_ID",
            "select Documents.Template_ID, Documents.Document_Description",
            "select Documents.Template_ID, Templates.Template_Details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find documents containing the letter w in its name and what are their template, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Documents",
        "real_label": "Documents",
        "topk_preds": [
            "Documents",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: show, list of teachers and number of courses taught., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY ORDINANCE-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-GROUP BY (ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY ORDINARY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: show, list of teachers and number of courses taught., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, count(*)",
        "label": "select t1.c1, count(*)",
        "score": true,
        "real_pred": "select teacher.Name, count(*)",
        "real_label": "select teacher.Name, count(*)",
        "topk_preds": [
            "select teacher.Name, count(*)",
            "select teacher.Name, sum(course.Course)",
            "select teacher.Name, count(distinct course.Course)",
            "select teacher.Name, count(*), course.Course",
            "select teacher.Name, count(course.Course)",
            "select course_arrange.Teacher_ID, count(*)",
            "select teacher.Name, course.Course",
            "select teacher.Name, count(*), course.Course_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: show, list of teachers and number of courses taught., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name the teachers whose classes have not been set up?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name the teachers whose classes have not been set up?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Teacher_ID",
            "select teacher.Name, course_arrange.Teacher_ID",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, course.Course",
            "select teacher.Name, course_arrange.Grade",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, t1.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name the teachers whose classes have not been set up?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "course teacher course_arrange",
            "teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are the teachers and how many courses they teach?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY SELECT-FROM-GROUP BY",
            "SELECT-FROM-GEOGRAPHIC-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-GIRL-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are the teachers and how many courses they teach?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, count(*)",
        "label": "select t1.c1, count(*)",
        "score": true,
        "real_pred": "select teacher.Name, count(*)",
        "real_label": "select teacher.Name, count(*)",
        "topk_preds": [
            "select teacher.Name, count(*)",
            "select teacher.Name, count(distinct course.Course)",
            "select teacher.Name, count(*), course.Course",
            "select teacher.Name, count(*), course.Course_ID",
            "select teacher.Name, count(course.Course)",
            "select teacher.Name, count(*), course_arrange.Teacher_ID",
            "select teacher.Name, count(*), course.Staring_Date",
            "select teacher.Name, count(*), teacher.Teacher_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are the teachers and how many courses they teach?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are the teachers whose hometown is not little lever urban district?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are the teachers whose hometown is not little lever urban district?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, teacher.Teacher_ID",
            "select teacher.Name, teacher.Name",
            "select teacher.Name, t1.c6",
            "select teacher.Name, teacher.Teacher_ID3",
            "select teacher.Name, t1.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are the teachers whose hometown is not little lever urban district?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which teachers teach two or more courses?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which teachers teach two or more courses?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, course.Course",
            "select teacher.Name, course.Course_ID",
            "select teacher.Name, course.Staring_Date",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, course_arrange.Teacher_ID",
            "select teacher.Name, t0.c3",
            "select teacher.Name,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which teachers teach two or more courses?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which faculty members are assigned teaching responsibilities in more than one course?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAGLE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GATHERING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAGLE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAMMA-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which faculty members are assigned teaching responsibilities in more than one course?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, teacher.Teacher_ID",
            "select teacher.Name, course.Course",
            "select teacher.Name, teacher.Name",
            "select teacher.Name, course_arrange.Teacher_ID",
            "select teacher.Name, t1.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which faculty members are assigned teaching responsibilities in more than one course?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which Teachers teach at least 2 courses?., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which Teachers teach at least 2 courses?., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, course.Course",
            "select teacher.Name, course.Course_ID",
            "select teacher.Name, course.Staring_Date",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, t0.c3",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, teacher.Teacher_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which Teachers teach at least 2 courses?., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which teachers teaches the two courses, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-UNION-SELECT-FROM",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-UNION-SELECT-FROM",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which teachers teaches the two courses, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, course_arrange.Teacher_ID",
            "select teacher.Name, teacher.Teacher_ID",
            "select teacher.Name, course.Course",
            "select teacher.Name, teacher.Age",
            "select teacher.Name (course.Course)",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, course.Staring_Date"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which teachers teaches the two courses, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which teachers teach two classes?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-PAIR-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GEOMETRY-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GEOMETRY-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GATHER-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which teachers teach two classes?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, teacher.Teacher_ID",
            "select teacher.Name, course.Course",
            "select teacher.Name, course_arrange.Teacher_ID",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, teacher.Name",
            "select teacher.Name, course.Staring_Date"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which teachers teach two classes?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "",
            "course teacher",
            "teacher course_arrange",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to know which teachers teach more than one course., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM",
            "SELECT-FROM-GEOMETRY-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GEOMETRIC-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to know which teachers teach more than one course., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select course_arrange.Teacher_ID",
            "select teacher.Name, course.Course",
            "select course_arrange.Teacher_ID, teacher.Name",
            "select teacher.Name, course_arrange.Teacher_ID",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, course.Course_ID",
            "select teacher.Name, course.Staring_Date"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to know which teachers teach more than one course., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: About how old and what city did teachers originate from?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: About how old and what city did teachers originate from?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c2, t1.c3",
        "label": "select t1.c2, t1.c3",
        "score": true,
        "real_pred": "select teacher.Age, teacher.Hometown",
        "real_label": "select teacher.Age, teacher.Hometown",
        "topk_preds": [
            "select teacher.Age, teacher.Hometown",
            "select teacher.Hometown, teacher.Age",
            "select teacher.Teacher_ID, teacher.Age, teacher.Hometown",
            "select teacher.Name, teacher.Age, teacher.Hometown",
            "select teacher.Age, teacher.Hometown, teacher.Teacher_ID",
            "select teacher.Age, teacher.Hometown, t1.c4",
            "select teacher.Age.c3, teacher.Age",
            "select sum(teacher.Age), teacher.Hometown"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: About how old and what city did teachers originate from?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old are teachers and where are they from?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old are teachers and where are they from?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c2, t1.c3",
        "label": "select t1.c2, t1.c3",
        "score": true,
        "real_pred": "select teacher.Age, teacher.Hometown",
        "real_label": "select teacher.Age, teacher.Hometown",
        "topk_preds": [
            "select teacher.Age, teacher.Hometown",
            "select teacher.Hometown, teacher.Age",
            "select teacher.Teacher_ID, teacher.Age, teacher.Hometown",
            "select teacher.Name, teacher.Age, teacher.Hometown",
            "select teacher.Age, teacher.Hometown, teacher.Teacher_ID",
            "select teacher.Age, teacher.Hometown, t1.c4",
            "select teacher.Age, teacher.Hometown,",
            "select teacher.Age., teacher.Hometown"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old are teachers and where are they from?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What teacher's hometown is not Little Lever Urban District?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHICH-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What teacher's hometown is not Little Lever Urban District?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Teacher_ID",
            "select teacher.Name, teacher.Age",
            "select teacher.Teacher_ID, teacher.Name",
            "select teacher.Name, teacher.Teacher_ID3",
            "select teacher.Name, teacher.Hometown,",
            "select teacher.Name, teacher.Teacher_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What teacher's hometown is not Little Lever Urban District?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List teacher's hometowns that are not Little Lever Urban District'., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List teacher's hometowns that are not Little Lever Urban District'., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select distinct t1.c3",
        "label": "select t1.c1",
        "score": false,
        "real_pred": "select distinct teacher.Hometown",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select distinct teacher.Hometown",
            "select teacher.Hometown",
            "select distinct teacher.Hometown, teacher.Teacher_ID",
            "select distinct teacher.Hometown, t1.c4",
            "select different teacher.Hometown",
            "select distinct teacher.Hometown, teacher.Age",
            "select differet teacher.Hometown",
            "select separate teacher.Hometown"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List teacher's hometowns that are not Little Lever Urban District'., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Describe teachers whose hometown is not Little Lever Urban district., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Describe teachers whose hometown is not Little Lever Urban district., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, teacher.Age",
            "select teacher.Age, teacher.Hometown",
            "select teacher.Teacher_ID, teacher.Name",
            "select teacher.Hometown, teacher.Name",
            "select teacher.Name, teacher.Hometown,",
            "select teacher.Age, teacher.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Describe teachers whose hometown is not Little Lever Urban district., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name teachers in ascending order of age, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c1",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY.",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t1.c1)",
            "SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name teachers in ascending order of age, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, teacher.Age, teacher.Hometown",
            "select teacher.Name in teacher.Age",
            "select teacher.Name and teacher.Age",
            "select teacher.Name, teacher.Age - teacher.Hometown",
            "select teacher.Name-ordered",
            "select teacher.Name-ORDER BY"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name teachers in ascending order of age, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show who are teachers aged between 32 and 33., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show who are teachers aged between 32 and 33., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, teacher.Age, teacher.Hometown",
            "select teacher.Name, teacher.Age, teacher.Teacher_ID",
            "select teacher.Name, teacher.Hometown, teacher.Age",
            "select teacher.Name, teacher.Age, teacher.Hometown",
            "select teacher.Name, teacher.Hometown, t1.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show who are teachers aged between 32 and 33., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which teachers were 32 or 33 years old?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which teachers were 32 or 33 years old?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name ou teacher.Age",
            "select teacher.Name ou teacher.Hometown",
            "select teacher.Name sau teacher.Age",
            "select teacher.Name or teacher.Hometown",
            "select teacher.Name or teacher.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which teachers were 32 or 33 years old?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are teachers aged either 32 or 33?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INSERT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are teachers aged either 32 or 33?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name ou teacher.Hometown",
            "select teacher.Name or teacher.Hometown",
            "select teacher.Name ou teacher.Age",
            "select teacher.Name, teacher.Teacher_ID",
            "select teacher.Name or teacher.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are teachers aged either 32 or 33?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who teaches with ages 32 or 33, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who teaches with ages 32 or 33, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, teacher.Age",
            "select teacher.Name ou teacher.Hometown",
            "select teacher.Name or teacher.Hometown",
            "select teacher.Name, teacher.Teacher_ID",
            "select teacher.Name ou teacher.Age",
            "select teacher.Name, teacher.Hometown,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who teaches with ages 32 or 33, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are teachers aged between 32 and 33?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are teachers aged between 32 and 33?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Teacher_ID",
            "select teacher.Name, t1.c6",
            "select teacher.Name, teacher.Age,",
            "select teacher.Name,",
            "select teacher.Name, teacher.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are teachers aged between 32 and 33?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who teaches math course?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who teaches math course?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, course.Course",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, teacher.Teacher_ID",
            "select distinct teacher.Name",
            "select teacher.Name, course.Course_ID",
            "select teacher.Name, course.Staring_Date",
            "select teacher.Name, t0.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who teaches math course?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "course teacher course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which teachers teach math courses?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-COLLEECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which teachers teach math courses?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, course_arrange.Teacher_ID",
            "select teacher.Name, teacher.Age",
            "select distinct teacher.Name",
            "select teacher.Name, teacher.Teacher_ID",
            "select distinct teacher.Name, teacher.Age",
            "select course_arrange.Teacher_ID",
            "select distinct teacher.Name, course_arrange.Teacher_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which teachers teach math courses?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t2",
        "label": "t0 t1 t2",
        "score": false,
        "real_pred": "course course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course course_arrange",
            "course teacher course_arrange",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name instructors on courses they're teaching., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-INSTRUCT-SELECT-FROM",
            "SELECT-FROM IDENTIFY-UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name instructors on courses they're teaching., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1, t0.c2",
        "score": false,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name, course.Course",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, course.Course",
            "select distinct teacher.Name",
            "select distinct teacher.Name, course.Course",
            "select teacher.Name, course.Staring_Date",
            "select teacher.Name, course.Course_ID",
            "select teacher.Name, course_arrange.Teacher_ID",
            "select teacher.Name, t0.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name instructors on courses they're teaching., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "course teacher course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who will teach what courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who will teach what courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t0.c2",
        "label": "select t1.c1, t0.c2",
        "score": true,
        "real_pred": "select teacher.Name, course.Course",
        "real_label": "select teacher.Name, course.Course",
        "topk_preds": [
            "select teacher.Name, course.Course",
            "select distinct teacher.Name, course.Course",
            "select course_arrange.Teacher_ID, course.Course",
            "select teacher.Name, course.Course_ID",
            "select teacher.Name, t0.c3",
            "select teacher.Name, course.Staring_Date",
            "select teacher.Name, course.Course,",
            "select teacher.Name, course.Course."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who will teach what courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "course teacher course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: who are teachers and which course do they teach?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-C1, SELECT-FROM-C2",
            "SELECT-FROM-C1, SELECT-FROM-GROUP BY",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: who are teachers and which course do they teach?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t0.c2",
        "label": "select t1.c1, t0.c2",
        "score": true,
        "real_pred": "select teacher.Name, course.Course",
        "real_label": "select teacher.Name, course.Course",
        "topk_preds": [
            "select teacher.Name, course.Course",
            "select distinct teacher.Name, course.Course",
            "select teacher.Name, course.Course, course_arrange.Teacher_ID",
            "select teacher.Name, course.Course, course_arrange.Course_ID",
            "select teacher.Name, course.Course, teacher.Teacher_ID",
            "select teacher.Name, course.Course, teacher.Hometown",
            "select course_arrange.Teacher_ID, course.Course",
            "select teacher.Name, course.Course, t2.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: who are teachers and which course do they teach?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "course teacher course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which teachers are arranged to teach which courses?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM, UNION-SELECT-FROM",
            "SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which teachers are arranged to teach which courses?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t2.c1, t0.c2",
        "label": "select t1.c1, t0.c2",
        "score": false,
        "real_pred": "select course_arrange.Teacher_ID, course.Course",
        "real_label": "select teacher.Name, course.Course",
        "topk_preds": [
            "select course_arrange.Teacher_ID, course.Course",
            "select distinct course_arrange.Teacher_ID, course.Course",
            "select distinct course_arrange.Teacher_ID",
            "select course_arrange.Teacher_ID",
            "select course_arrange.Teacher_ID, course.Staring_Date",
            "select teacher.Name, course.Course",
            "select different course_arrange.Teacher_ID, course.Course",
            "select course_arrange.Teacher_ID, course_arrange.Grade"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which teachers are arranged to teach which courses?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t2",
        "label": "t0 t1 t2",
        "score": false,
        "real_pred": "course course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course course_arrange",
            "course teacher course_arrange",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show list of teachers who have not been assigned courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show list of teachers who have not been assigned courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, teacher.Teacher_ID",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Teacher_ID, teacher.Name",
            "select teacher.Name, t1.c6",
            "select teacher.Name, course_arrange.Teacher_ID",
            "select teacher.Name, t1.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show list of teachers who have not been assigned courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "teacher course_arrange",
            "",
            "",
            "",
            "course teacher",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which teachers did not teach course?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHICH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which teachers did not teach course?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, teacher.Teacher_ID",
            "select teacher.Name, course.Course",
            "select distinct teacher.Name",
            "select teacher.Name, t1.c6",
            "select distinct teacher.Name, teacher.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which teachers did not teach course?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "course teacher",
            "course teacher course_arrange",
            "teacher course_arrange",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show teachers that haven't been arranged to teach courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show teachers that haven't been arranged to teach courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, teacher.Teacher_ID",
            "select teacher.Name, t1.c6",
            "select teacher.Name, t1.c4",
            "select teacher.Teacher_ID, teacher.Name",
            "select teacher.Name, course_arrange.Teacher_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show teachers that haven't been arranged to teach courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "teacher course_arrange",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who has not been asked to teach classes?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHAT-EXCEPT-SELECT-FROM",
            "SELECT-FROM-HOLD-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who has not been asked to teach classes?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, teacher.Hometown",
            "select distinct teacher.Name, teacher.Age",
            "select distinct teacher.Name",
            "select teacher.Name (teacher.Age)",
            "select teacher.Name, t1.c6",
            "select distinct teacher.Name, teacher.Hometown"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who has not been asked to teach classes?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "teacher course_arrange",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all teaching staff who haven't had lessons arranged for them., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all teaching staff who haven't had lessons arranged for them., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, teacher.Teacher_ID",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, t1.c6",
            "select teacher.Name, teacher.Teacher_ID2",
            "select teacher.Name, teacher.Name",
            "select teacher.Name, t1.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all teaching staff who haven't had lessons arranged for them., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "teacher course_arrange",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which teachers are 32 or 33 years old?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which teachers are 32 or 33 years old?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name ou teacher.Hometown",
            "select teacher.Name ou teacher.Age",
            "select teacher.Name sau teacher.Age",
            "select teacher.Name or teacher.Hometown",
            "select teacher.Name oder teacher.Hometown"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which teachers are 32 or 33 years old?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show which teachers teaches at least 2 courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show which teachers teaches at least 2 courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, course.Course",
            "select teacher.Name, course.Course_ID",
            "select teacher.Name, course.Staring_Date",
            "select teacher.Name, t0.c3",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, course_arrange.Teacher_ID",
            "select teacher.Name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show which teachers teaches at least 2 courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which teachers teach at least two courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which teachers teach at least two courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, course.Course",
            "select teacher.Name, course.Course_ID",
            "select teacher.Name, course.Staring_Date",
            "select teacher.Name, t0.c3",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, course_arrange.Teacher_ID",
            "select teacher.Name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which teachers teach at least two courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name all teachers teaching at least two subjects., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GATHER-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name all teachers teaching at least two subjects., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, course_arrange.Teacher_ID",
            "select teacher.Name, teacher.Teacher_ID",
            "select teacher.Name, course.Course",
            "select teacher.Name, course_arrange.Grade",
            "select teacher.Name, course.Staring_Date",
            "select teacher.Name, teacher.Hometown"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name all teachers teaching at least two subjects., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "teacher course_arrange",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which teachers teaches at least 2 courses?., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which teachers teaches at least 2 courses?., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, course.Course",
            "select teacher.Name, course.Course_ID",
            "select teacher.Name, course.Staring_Date",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, t0.c3",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which teachers teaches at least 2 courses?., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher",
            "course teacher course_arrange",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name the person who visited both a museum that has been open before 2009 and a new one that has been opened after 2011., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE AND-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT-FROM-WHERE,-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name the person who visited both a museum that has been open before 2009 and a new one that has been opened after 2011., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select visitor.Name",
        "real_label": "select visitor.Name",
        "topk_preds": [
            "select visitor.Name",
            "select visitor.Name, museum.Name",
            "select visitor.Name, museum.Open_Year",
            "select visitor.Name, visit.visitor_ID",
            "select visitor.Name, museum.Num_of_Staff",
            "select visitor.Name, visit.Museum_ID",
            "select visitor.Name, visitor.ID",
            "select visitor.Name, museum.Museum_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name the person who visited both a museum that has been open before 2009 and a new one that has been opened after 2011., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "museum visitor visit",
        "real_label": "museum visitor visit",
        "topk_preds": [
            "museum visitor visit",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: On average how old are visitors whose membership level is not higher than 4?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: On average how old are visitors whose membership level is not higher than 4?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select avg(t1.c3)",
        "label": "select avg(t1.c3)",
        "score": true,
        "real_pred": "select avg(visitor.Age)",
        "real_label": "select avg(visitor.Age)",
        "topk_preds": [
            "select avg(visitor.Age)",
            "select an avg(visitor.Age)",
            "select  avg(visitor.Age)",
            "select Avg(visitor.Age)",
            "select avg(t1.c 3)",
            "select avg(visitor.Age),",
            "select \u2018avg(visitor.Age)",
            "select avg(t1.c)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: On average how old are visitors whose membership level is not higher than 4?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old are visitors on average whose membership level is not higher than four?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AVERAGE",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old are visitors on average whose membership level is not higher than four?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select avg(t1.c3)",
        "label": "select avg(t1.c3)",
        "score": true,
        "real_pred": "select avg(visitor.Age)",
        "real_label": "select avg(visitor.Age)",
        "topk_preds": [
            "select avg(visitor.Age)",
            "select an avg(visitor.Age)",
            "select  avg(visitor.Age)",
            "select Avg(visitor.Age)",
            "select rate(avg(visitor.Age)",
            "select avg(t1.c 3)",
            "select \u0430vg(visitor.Age)",
            "select avg(t1.c)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old are visitors on average whose membership level is not higher than four?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which museums have more staff than the minimum number since the opening of new ones after 2010?., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which museums have more staff than the minimum number since the opening of new ones after 2010?., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select museum.Name",
        "real_label": "select museum.Name",
        "topk_preds": [
            "select museum.Name",
            "select museum.Name, museum.Num_of_Staff",
            "select museum.Museum_ID, museum.Name",
            "select museum.Museum_ID",
            "select museum.Museum_ID, museum.Name, museum.Num_of_Staff",
            "select museum.Name, museum.Num_of_Staff, museum.Open_Year",
            "select museum.Name, museum.Open_Year",
            "select museum.Museum_ID, museum.Num_of_Staff"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which museums have more staff than the minimum number since the opening of new ones after 2010?., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "museum",
        "real_label": "museum",
        "topk_preds": [
            "museum",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which museum has more people working at it than the minimum number of staff required of all new museums opened after 2010., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which museum has more people working at it than the minimum number of staff required of all new museums opened after 2010., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select museum.Name",
        "real_label": "select museum.Name",
        "topk_preds": [
            "select museum.Name",
            "select museum.Museum_ID, museum.Name",
            "select museum.Name, museum.Num_of_Staff",
            "select museum.Museum_ID, museum.Name, museum.Num_of_Staff",
            "select museum.Museum_ID, museum.Name, museum.Num_of_Staff",
            "select museum.Name, museum.Num_of_Staff, museum.Open_Year",
            "select museum.Museum_ID, museum.Name, museum.Open_Year",
            "select museum.Museum_ID, museum.Name (or museum.Num_of_Staff)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which museum has more people working at it than the minimum number of staff required of all new museums opened after 2010., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "museum",
        "real_label": "museum",
        "topk_preds": [
            "museum",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which members have level greater than 4, and list them from highest to lowest., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-WHERE-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY.",
            "SELECT-FROM-WHERE-ORDER BY (t1.c2)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY(t1.c2)",
            "SELECT-FROM-WHERE-ORDER BY ",
            "SELECT-FROM-WHERE-ORDER BY ("
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which members have level greater than 4, and list them from highest to lowest., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c0",
        "label": "select t1.c1",
        "score": false,
        "real_pred": "select visitor.ID",
        "real_label": "select visitor.Name",
        "topk_preds": [
            "select visitor.ID",
            "select visitor.ID, visitor.Level_of_membership",
            "select visitor.Name, visitor.Level_of_membership",
            "select visitor.ID, visitor.Name",
            "select visitor.ID, sort(visitor.Level_of_membership)",
            "select visitor.ID, visitor.Age",
            "select t1.c4",
            "select visitor.ID, visitor.Level_of_membership"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which members have level greater than 4, and list them from highest to lowest., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which members have higher level than four? Show it in order from high to low., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-WHERE-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY(t1.c2)",
            "SELECT-FROM-WHERE-ORDER BY.",
            "SELECT-FROM-WHERE-ORDER BY (",
            "SELECT-FROM-WHERE-ORDER BY ",
            "SELECT-FROM-WHERE-ORDER BY t1.c2",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE\u2013ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which members have higher level than four? Show it in order from high to low., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c0",
        "label": "select t1.c1",
        "score": false,
        "real_pred": "select visitor.ID",
        "real_label": "select visitor.Name",
        "topk_preds": [
            "select visitor.ID",
            "select visitor.ID, visitor.Level_of_membership",
            "select visitor.Name, visitor.Level_of_membership",
            "select visitor.Name",
            "select visitor.ID, visitor.Name",
            "select visitor.ID, visitor.Age",
            "select visitor.ID, visitor.Level_of_membership",
            "select visitor.ID in visitor.Level_of_membership"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which members have higher level than four? Show it in order from high to low., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which visitor bought most tickets at once? And What his/her age?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-C1 - SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-C1, SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which visitor bought most tickets at once? And What his/her age?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c3",
        "label": "select t1.c1, t1.c3",
        "score": true,
        "real_pred": "select visitor.Name, visitor.Age",
        "real_label": "select visitor.Name, visitor.Age",
        "topk_preds": [
            "select visitor.Name, visitor.Age",
            "select visit.visitor_ID, visitor.Age",
            "select visitor.ID, visitor.Name, visitor.Age",
            "select t1, visitor.Name, visitor.Age",
            "select t1, visitor.Name, visitor.Age",
            "select visitor.Name, visitor.Level_of_membership",
            "select visitor.Name, visitor.Age, visitor.ID",
            "select t 1.c1, visitor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which visitor bought most tickets at once? And What his/her age?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "visitor visit",
        "real_label": "visitor visit",
        "topk_preds": [
            "visitor visit",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which visitor bought the most tickets at once? And What is his or her age?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which visitor bought the most tickets at once? And What is his or her age?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c3",
        "label": "select t1.c1, t1.c3",
        "score": true,
        "real_pred": "select visitor.Name, visitor.Age",
        "real_label": "select visitor.Name, visitor.Age",
        "topk_preds": [
            "select visitor.Name, visitor.Age",
            "select visit.visitor_ID, visitor.Age",
            "select visitor.ID, visitor.Name, visitor.Age",
            "select t1, visitor.Name, visitor.Age",
            "select t1, visitor.Name, visitor.Age",
            "select visitor.Name, visitor.Age, visitor.ID",
            "select visitor.Name, visitor.Level_of_membership",
            "select t1.c 1, visitor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which visitor bought the most tickets at once? And What is his or her age?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "visitor visit",
        "real_label": "visitor visit",
        "topk_preds": [
            "visitor visit",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name of the museum that did not get visitors, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name of the museum that did not get visitors, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select museum.Name",
        "real_label": "select museum.Name",
        "topk_preds": [
            "select museum.Name",
            "select museum.Name, museum.Museum_ID",
            "select museum.Name, museum.Num_of_Staff",
            "select museum.Name, museum.Open_Year",
            "select museum.Name, t0.c6",
            "select museum.Name (museum.Museum_ID)",
            "select museum.Name, t0.c5",
            "select museum.Name, museum.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name of the museum that did not get visitors, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "museum",
        "real_label": "museum",
        "topk_preds": [
            "museum",
            "museum visit",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name of the museum that has no visitor yet?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name of the museum that has no visitor yet?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select museum.Name",
        "real_label": "select museum.Name",
        "topk_preds": [
            "select museum.Name",
            "select museum.Name, museum.Museum_ID",
            "select museum.Name, museum.Num_of_Staff",
            "select museum.Name, museum.Open_Year",
            "select museum.Name (syntax museum.Name)",
            "select museum.Name (syntax museum.Num_of_Staff)",
            "select museum.Name (syntax museum.Museum_ID)",
            "select museum.Name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name of the museum that has no visitor yet?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "museum",
        "real_label": "museum",
        "topk_preds": [
            "museum",
            "museum visit",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What museum has not seen visitors yet?., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What museum has not seen visitors yet?., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select museum.Name",
        "real_label": "select museum.Name",
        "topk_preds": [
            "select museum.Name",
            "select museum.Museum_ID, museum.Name",
            "select museum.Name, museum.Museum_ID",
            "select museum.Name, museum.Num_of_Staff",
            "select museum.Name, museum.Open_Year",
            "select museum.Name (museum.Museum_ID)",
            "select museum.Name, t0.c6",
            "select museum.Name, t0.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What museum has not seen visitors yet?., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "museum",
        "real_label": "museum",
        "topk_preds": [
            "museum",
            "museum visit",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name the museum that had no visitors yet., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name the museum that had no visitors yet., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select museum.Name",
        "real_label": "select museum.Name",
        "topk_preds": [
            "select museum.Name",
            "select museum.Name, museum.Museum_ID",
            "select museum.Name, museum.Num_of_Staff",
            "select museum.Name, museum.Open_Year",
            "select museum.Name (select museum.Museum_ID)",
            "select museum.Name, t0.c6",
            "select museum.Name (museum.Museum_ID)",
            "select museum.Name, t0.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name the museum that had no visitors yet., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "museum",
        "real_label": "museum",
        "topk_preds": [
            "museum",
            "museum visit",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What tournament has more than 10 matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING Solve-IT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What tournament has more than 10 matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c20",
        "label": "select t1.c20",
        "score": true,
        "real_pred": "select matches.tourney_name",
        "real_label": "select matches.tourney_name",
        "topk_preds": [
            "select matches.tourney_name",
            "select matches.tourney_name, matches.tourney_date",
            "select matches.tourney_name, matches.minutes",
            "select matches.tourney_name, matches.winner_hand",
            "select matches.tourney_name, matches.winner_age",
            "select matches.tourney_name, matches.tourney_id",
            "select matches.tourney_name, matches.match_num",
            "select matches.tourney_name, matches.round"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What tournament has more than 10 matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which tournament had more than 10 matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING Solve-IT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which tournament had more than 10 matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c20",
        "label": "select t1.c20",
        "score": true,
        "real_pred": "select matches.tourney_name",
        "real_label": "select matches.tourney_name",
        "topk_preds": [
            "select matches.tourney_name",
            "select matches.tourney_name, matches.tourney_date",
            "select matches.tourney_name, matches.minutes",
            "select matches.tourney_name (matches.match_num)",
            "select matches.tourney_name, matches.winner_hand",
            "select matches.tourney_name,",
            "select matches.tourney_name, matches.tourney_id",
            "select matches.tourney_name, matches.winner_age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which tournament had more than 10 matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which tournament (tourney?) had more than 10 matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING Solve-IT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which tournament (tourney?) had more than 10 matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c20",
        "label": "select t1.c20",
        "score": true,
        "real_pred": "select matches.tourney_name",
        "real_label": "select matches.tourney_name",
        "topk_preds": [
            "select matches.tourney_name",
            "select matches.tourney_name, matches.tourney_date",
            "select matches.tourney_name (matches.tourney_date)",
            "select matches.tourney_name,",
            "select matches.tourney_name (matches.loser_ioc)",
            "select matches.tourney_name, matches.winner_hand",
            "select matches.tourney_name (matches.loser_name)",
            "select matches.tourney_name, matches.minutes"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which tournament (tourney?) had more than 10 matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "matches rankings",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which tournament has more than 10 matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING Solve-IT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which tournament has more than 10 matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c20",
        "label": "select t1.c20",
        "score": true,
        "real_pred": "select matches.tourney_name",
        "real_label": "select matches.tourney_name",
        "topk_preds": [
            "select matches.tourney_name",
            "select matches.tourney_name, matches.tourney_date",
            "select matches.tourney_name, matches.minutes",
            "select matches.tourney_name, matches.winner_hand",
            "select matches.tourney_name, matches.winner_age",
            "select matches.tourney_name, matches.tourney_id",
            "select matches.tourney_name (matches.match_num)",
            "select matches.tourney_name, matches.winner_entry"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which tournament has more than 10 matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which tournament have more than 10 matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING Solve-IT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which tournament have more than 10 matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c20",
        "label": "select t1.c20",
        "score": true,
        "real_pred": "select matches.tourney_name",
        "real_label": "select matches.tourney_name",
        "topk_preds": [
            "select matches.tourney_name",
            "select matches.tourney_name, matches.tourney_date",
            "select matches.tourney_name, matches.minutes",
            "select matches.tourney_name, matches.winner_hand",
            "select matches.tourney_name, matches.tourney_id",
            "select matches.tourney_name, matches.winner_age",
            "select matches.tourney_name (matches.match_num)",
            "select matches.tourney_name, matches.round"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which tournament have more than 10 matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the tournament that has more than 10 matchs, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the tournament that has more than 10 matchs, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c20",
        "label": "select t1.c20",
        "score": true,
        "real_pred": "select matches.tourney_name",
        "real_label": "select matches.tourney_name",
        "topk_preds": [
            "select matches.tourney_name",
            "select matches.tourney_name, matches.tourney_date",
            "select matches.tourney_name, matches.winner_hand",
            "select matches.tourney_name, matches.minutes",
            "select matches.tourney_name, matches.winner_age",
            "select matches.tourney_name, matches.winner_entry",
            "select matches.tourney_name, matches.tourney_name",
            "select matches.tourney_name, matches.loser_entry"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the tournament that has more than 10 matchs, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "matches rankings",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who is the winner with most rank points participating in Australian open tournaments?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (Australian Open), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-CORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GIG-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-C27-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who is the winner with most rank points participating in Australian open tournaments?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (Australian Open), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c27",
        "label": "select t1.c27",
        "score": true,
        "real_pred": "select matches.winner_name",
        "real_label": "select matches.winner_name",
        "topk_preds": [
            "select matches.winner_name",
            "select rankings.player_id7",
            "select rankings.ranking_date, rankings.player_id7",
            "select matches.winner_name, rankings.ranking_points",
            "select rankings.ranking_date, matches.winner_name",
            "select rankings.ranking_date, t2.c7",
            "select rankings.ranking_date, rankings.ranking",
            "select rankings.ranking_date, rankings.player_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who is the winner with most rank points participating in Australian open tournaments?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (Australian Open), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1",
        "score": false,
        "real_pred": "matches rankings",
        "real_label": "matches",
        "topk_preds": [
            "matches rankings",
            "matches",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are the three youngest winners across all matches? And their ranks?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are the three youngest winners across all matches? And their ranks?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c27, t1.c28",
        "label": "select distinct t1.c27, t1.c28",
        "score": false,
        "real_pred": "select matches.winner_name, matches.winner_rank",
        "real_label": "select distinct matches.winner_name, matches.winner_rank",
        "topk_preds": [
            "select matches.winner_name, matches.winner_rank",
            "select matches.winner_rank, matches.winner_name",
            "select matches.loser_age, matches.winner_rank",
            "select matches.loser_ioc, matches.winner_rank",
            "select matches.winner_ioc, matches.winner_rank",
            "select matches.winner_age, matches.winner_rank",
            "select matches.winner_hand, matches.winner_rank",
            "select matches.winner_entry, matches.winner_rank"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are the three youngest winners across all matches? And their ranks?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who was the winner that had the highest rank points and participated in the Australian Open tournament?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (Australian Open), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who was the winner that had the highest rank points and participated in the Australian Open tournament?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (Australian Open), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c27",
        "label": "select t1.c27",
        "score": true,
        "real_pred": "select matches.winner_name",
        "real_label": "select matches.winner_name",
        "topk_preds": [
            "select matches.winner_name",
            "select matches.winner_name, rankings.ranking_points",
            "select matches.tourney_name, matches.winner_name",
            "select rankings.player_id7",
            "select matches.winner_name, rankings.player_id",
            "select matches.winner_name, matches.winner_rank",
            "select matches.winner_name, rankings.ranking_date",
            "select matches.winner_name, rankings.ranking_points"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who was the winner that had the highest rank points and participated in the Australian Open tournament?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (Australian Open), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1",
        "score": false,
        "real_pred": "matches rankings",
        "real_label": "matches",
        "topk_preds": [
            "matches rankings",
            "players matches rankings",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who is the winner that has the most points and participates in the Australian open test., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (Australian Open), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-CONSIDER-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who is the winner that has the most points and participates in the Australian open test., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (Australian Open), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c27",
        "label": "select t1.c27",
        "score": true,
        "real_pred": "select matches.winner_name",
        "real_label": "select matches.winner_name",
        "topk_preds": [
            "select matches.winner_name",
            "select matches.winner_name, matches.winner_rank_points",
            "select matches.winner_name, matches.winner_entry",
            "select matches.winner_name, matches.winner_ioc",
            "select matches.winner_name, matches.winner_rank",
            "select matches.winner_name, matches.winner_hand",
            "select matches.winner_name, matches.winner_seed",
            "select matches.winner_name, matches.tourney_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who is the winner that has the most points and participates in the Australian open test., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (Australian Open), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "matches rankings",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name each left-handed player in order of birth., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-WHERE-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-ORDER BY.",
            "SELECT-FROM-WHERE-ORDER BY(t0.c1)",
            "SELECT-FROM-WHERE-ORDER BY "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name each left-handed player in order of birth., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select players.first_name, players.last_name",
        "real_label": "select players.first_name, players.last_name",
        "topk_preds": [
            "select players.first_name, players.last_name",
            "select players.first_name, players.last_name, players.hand",
            "select players.first_name, players.last_name, players.birth_date",
            "select players.first_name, players.hand, players.last_name",
            "select players.first_name, players.last_name and players.hand",
            "select players.first_name, players.last_name in players.birth_date",
            "select players.first_name, players.last_name, players.hand",
            "select players.first_name, players.last_name or players.hand"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name each left-handed player in order of birth., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What players played and won in 2013 and 2016?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-COUPLE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE AND-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-CONTRAST-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-COUPLING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What players played and won in 2013 and 2016?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c23, t1.c26",
        "label": "select t1.c27",
        "score": false,
        "real_pred": "select matches.winner_hand, matches.winner_ioc",
        "real_label": "select matches.winner_name",
        "topk_preds": [
            "select matches.winner_hand, matches.winner_ioc",
            "select matches.winner_hand",
            "select matches.winner_hand, matches.winner_name",
            "select matches.winner_hand, matches.winner_id",
            "select matches.winner_hand, matches.winner_ht",
            "select matches.winner_hand, matches.winner_hand",
            "select matches.winner_hand, matches.loser_age",
            "select matches.minutes, matches.round"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What players played and won in 2013 and 2016?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "matches rankings",
            "players matches",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name all players who won in both 2013 and 2016?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE,",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name all players who won in both 2013 and 2016?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t1.c27",
        "score": false,
        "real_pred": "select players.first_name, players.last_name",
        "real_label": "select matches.winner_name",
        "topk_preds": [
            "select players.first_name, players.last_name",
            "select players.player_id, players.first_name, players.last_name",
            "select players.player_id, players.first_name",
            "select players.player_id, players.first_name, players.last_name",
            "select matches.winner_name",
            "select players.first_name, players.last_name, players.player_id",
            "select players.player_id",
            "select players.first_name, players.last_name, matches.winner_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name all players who won in both 2013 and 2016?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "matches rankings",
            "players matches",
            "",
            "",
            "",
            "players matches rankings",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which player has the most wins and how much rank points he/she has?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, t2.c2, t2.c3",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which player has the most wins and how much rank points he/she has?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2, t2.c3",
        "label": "select t1.c27, t1.c29",
        "score": false,
        "real_pred": "select players.first_name, players.last_name, rankings.ranking_points",
        "real_label": "select matches.winner_name, matches.winner_rank_points",
        "topk_preds": [
            "select players.first_name, players.last_name, rankings.ranking_points",
            "select players.first_name, players.last_name, sum(rankings.ranking_points)",
            "select rankings.player_id, rankings.ranking_points",
            "select matches.draw_size, players.last_name, rankings.ranking_points",
            "select players.first_name, players.last_name, count(*)",
            "select rankings.player_id, sum(rankings.ranking_points)",
            "select players.first_name, players.last_name, total(rankings.ranking_points)",
            "select matches.draw_size, players.last_name, sum(rankings.ranking_points)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which player has the most wins and how much rank points he/she has?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1",
        "score": false,
        "real_pred": "players matches rankings",
        "real_label": "matches",
        "topk_preds": [
            "players matches rankings",
            "matches rankings",
            "",
            "",
            "players matches",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who won and lost the most in game with the most minutes played., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who won and lost the most in game with the most minutes played., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c27, t1.c28",
        "label": "select t1.c27, t1.c8",
        "score": false,
        "real_pred": "select matches.winner_name, matches.winner_rank",
        "real_label": "select matches.winner_name, matches.loser_name",
        "topk_preds": [
            "select matches.winner_name, matches.winner_rank",
            "select matches.winner_hand, matches.winner_ht",
            "select matches.minutes, matches.winner_name",
            "select matches.winner_entry, matches.winner_hand",
            "select matches.winner_name, matches.loser_name",
            "select matches.minutes, matches.loser_name",
            "select matches.loser_name, matches.loser_rank",
            "select matches.minutes, matches.winner_rank"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who won and lost the most in game with the most minutes played., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the winners and losers who played the most minutes in the game., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the winners and losers who played the most minutes in the game., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c27, t1.c8",
        "label": "select t1.c27, t1.c8",
        "score": true,
        "real_pred": "select matches.winner_name, matches.loser_name",
        "real_label": "select matches.winner_name, matches.loser_name",
        "topk_preds": [
            "select matches.winner_name, matches.loser_name",
            "select matches.winner_hand, matches.loser_name",
            "select matches.winner_hand, matches.winner_rank",
            "select matches.winner_entry, matches.loser_name",
            "select matches.minutes, matches.loser_name",
            "select matches.minutes, matches.winner_name",
            "select matches.winner_entry, matches.winner_hand",
            "select matches.winner_id, matches.loser_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the winners and losers who played the most minutes in the game., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: list all winners who played in 2013 and 2016., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-IN-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE AND-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: list all winners who played in 2013 and 2016., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c27",
        "label": "select t1.c27",
        "score": true,
        "real_pred": "select matches.winner_name",
        "real_label": "select matches.winner_name",
        "topk_preds": [
            "select matches.winner_name",
            "select matches.winner_id",
            "select matches.winner_ioc",
            "select matches.winner_hand",
            "select matches.loser_age",
            "select matches.winner_rank",
            "select matches.winner_entry",
            "select matches.winner_ht"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: list all winners who played in 2013 and 2016., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: list all winners who played in both 2013 and 2016, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE (t1.c27)",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE,",
            "SELECT-FROM-1913-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE (t1.c2)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: list all winners who played in both 2013 and 2016, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c27",
        "label": "select t1.c27",
        "score": true,
        "real_pred": "select matches.winner_name",
        "real_label": "select matches.winner_name",
        "topk_preds": [
            "select matches.winner_name",
            "select matches.winner_id",
            "select matches.winner_ioc",
            "select matches.loser_age",
            "select matches.winner_hand",
            "select matches.winner_rank",
            "select matches.winner_entry",
            "select matches.winner_ht"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: list all winners who played in both 2013 and 2016, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name all the winners who played in both 2013 and 2016., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE,",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE (t1.c27)",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-1913-WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name all the winners who played in both 2013 and 2016., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c27",
        "label": "select t1.c27",
        "score": true,
        "real_pred": "select matches.winner_name",
        "real_label": "select matches.winner_name",
        "topk_preds": [
            "select matches.winner_name",
            "select matches.winner_name, matches.winner_ioc",
            "select matches.winner_name, matches.winner_entry",
            "select matches.winner_name, matches.winner_seed",
            "select matches.winner_name, matches.winner_hand",
            "select matches.winner_name, matches.winner_rank",
            "select matches.winner_name, matches.tourney_name",
            "select matches.winner_name, matches.winner_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name all the winners who played in both 2013 and 2016., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who were winners and losers who play in the longest match?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-T1.c27, SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-T1.c27, SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who were winners and losers who play in the longest match?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c27, t1.c8",
        "label": "select t1.c27, t1.c8",
        "score": true,
        "real_pred": "select matches.winner_name, matches.loser_name",
        "real_label": "select matches.winner_name, matches.loser_name",
        "topk_preds": [
            "select matches.winner_name, matches.loser_name",
            "select matches.winner_rank, matches.loser_name",
            "select matches.winner_rank, matches.loser_rank",
            "select matches.winner_hand, matches.loser_name",
            "select matches.winner_ioc, matches.loser_name",
            "select matches.loser_age, matches.loser_name",
            "select matches.winner_ht, matches.loser_name",
            "select matches.winner_id, matches.loser_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who were winners and losers who play in the longest match?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which players were the winners or losers in the longest match?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which players were the winners or losers in the longest match?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t1.c27, t1.c8",
        "score": false,
        "real_pred": "select players.first_name, players.last_name",
        "real_label": "select matches.winner_name, matches.loser_name",
        "topk_preds": [
            "select players.first_name, players.last_name",
            "select matches.winner_name, matches.loser_name",
            "select matches.winner_name, matches.winner_rank",
            "select t0.c8, players.last_name",
            "select matches.winner_name, players.last_name",
            "select t0.c7, t0.c8",
            "select matches.winner_hand, matches.winner_name",
            "select matches.loser_name, matches.loser_rank"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which players were the winners or losers in the longest match?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "matches rankings",
            "players matches",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who had the longest match? And What were the winning and losing sides?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who had the longest match? And What were the winning and losing sides?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c8, t1.c9",
        "label": "select t1.c27, t1.c8",
        "score": false,
        "real_pred": "select matches.loser_name, matches.loser_rank",
        "real_label": "select matches.winner_name, matches.loser_name",
        "topk_preds": [
            "select matches.loser_name, matches.loser_rank",
            "select matches.match_num, matches.loser_name, matches.round",
            "select matches.minutes, matches.loser_name, matches.round",
            "select matches.minutes, matches.round",
            "select matches.loser_name, matches.round",
            "select matches.match_num, matches.loser_name, matches.score",
            "select matches.match_num, matches.loser_name, matches.loser_rank",
            "select matches.minutes, matches.loser_name, matches.loser_rank"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who had the longest match? And What were the winning and losing sides?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old are winners and losers across matches on average?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY avg(t1.c21, t1.c2)",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM, avg(t1.c21, t1.c2)",
            "SELECT-FROM-GROUP BY avg(t1.c21 - t1.c2)",
            "SELECT-FROM, avg(t1.c21, avg(t1.c2)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old are winners and losers across matches on average?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select avg(t1.c21, avg(t1.c2)",
        "label": "select avg(t1.c2), avg(t1.c21)",
        "score": false,
        "real_pred": "select avg(matches.winner_age, avg(matches.loser_age)",
        "real_label": "select avg(matches.loser_age), avg(matches.winner_age)",
        "topk_preds": [
            "select avg(matches.winner_age, avg(matches.loser_age)",
            "select avg(matches.loser_age), matches.winner_age",
            "select avg(matches.winner_age - avg(matches.loser_age)",
            "select avg(matches.loser_age), avg(matches.winner_age)",
            "select avg(matches.winner_age, avg(matches.winner_entry)",
            "select avg(matches.winner_age & avg(matches.loser_age)",
            "select avg(matches.loser_ht), avg(matches.loser_age)",
            "select avg(matches.loser_age), avg(matches.winner_age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old are winners and losers across matches on average?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old are losers and winners across matches on average?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY avg(t1.c2), avg(t1.c21)",
            "SELECT-FROM-GROUP BY avg(t1.c2), avg(t1.c21",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old are losers and winners across matches on average?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select avg(t1.c2), avg(t1.c21)",
        "label": "select avg(t1.c2), avg(t1.c21)",
        "score": true,
        "real_pred": "select avg(matches.loser_age), avg(matches.winner_age)",
        "real_label": "select avg(matches.loser_age), avg(matches.winner_age)",
        "topk_preds": [
            "select avg(matches.loser_age), avg(matches.winner_age)",
            "select avg(matches.loser_age), avg(matches.winner_age",
            "select avg(matches.loser_age), avg(matches.loser_age)",
            "select avg(matches.loser_age), avg(matches.loser_entry)",
            "select avg(matches.loser_age), avg(matches.draw_size)",
            "select avg(matches.loser_age)., avg(matches.winner_age)",
            "select avg(matches.loser_age), avg(matches.winner_age).",
            "select avg(matches.loser_age), avg(matches.tourney_name)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old are losers and winners across matches on average?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old are those who win and lose across matches on average?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old are those who win and lose across matches on average?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select avg(t1.c2)",
        "label": "select avg(t1.c2), avg(t1.c21)",
        "score": false,
        "real_pred": "select avg(matches.loser_age)",
        "real_label": "select avg(matches.loser_age), avg(matches.winner_age)",
        "topk_preds": [
            "select avg(matches.loser_age)",
            "select avg(matches.loser_age), matches.winner_age",
            "select avg(matches.winner_age, matches.loser_age)",
            "select avg(matches.winner_age, avg(matches.loser_age)",
            "select avg(matches.winner_age, matches.winner_entry",
            "select avg(matches.winner_age, matches.loser_age",
            "select avg(matches.winner_age, matches.winner_entry)",
            "select avg(matches.winner_age, matches.winner_hand"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old are those who win and lose across matches on average?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old are the winners of all matches and losers on average?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM",
            "SELECT-FROM, avg(t1.c21 & avg(t1.c2)",
            "SELECT-FROM, avg(t1.c21 - t1.c2)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old are the winners of all matches and losers on average?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select avg(t1.c2), t1.c21",
        "label": "select avg(t1.c2), avg(t1.c21)",
        "score": false,
        "real_pred": "select avg(matches.loser_age), matches.winner_age",
        "real_label": "select avg(matches.loser_age), avg(matches.winner_age)",
        "topk_preds": [
            "select avg(matches.loser_age), matches.winner_age",
            "select avg(matches.winner_age, matches.loser_age)",
            "select matches.winner_age, avg(matches.loser_age)",
            "select avg(matches.winner_age - avg(matches.loser_age)",
            "select avg(matches.winner_age & avg(matches.loser_age)",
            "select avg(matches.winner_age, matches.loser_age",
            "select avg(matches.winner_age - matches.loser_age)",
            "select avg(matches.winner_age), matches.loser_age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old are the winners of all matches and losers on average?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which tournaments contain more than ten games?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which tournaments contain more than ten games?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c20",
        "label": "select t1.c20",
        "score": true,
        "real_pred": "select matches.tourney_name",
        "real_label": "select matches.tourney_name",
        "topk_preds": [
            "select matches.tourney_name",
            "select matches.tourney_name, matches.tourney_date",
            "select matches.tourney_name, matches.minutes",
            "select matches.tourney_name, matches.winner_hand",
            "select matches.tourney_name, matches.draw_size",
            "select matches.tourney_date",
            "select matches.tourney_name, matches.winner_age",
            "select matches.tourney_name (matches.tourney_date)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which tournaments contain more than ten games?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the tourneys that have more than ten matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the tourneys that have more than ten matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c20",
        "label": "select t1.c20",
        "score": true,
        "real_pred": "select matches.tourney_name",
        "real_label": "select matches.tourney_name",
        "topk_preds": [
            "select matches.tourney_name",
            "select matches.tourney_name, matches.tourney_date",
            "select matches.tourney_name, matches.winner_hand",
            "select matches.tourney_name, matches.winner_age",
            "select matches.tourney_name, matches.minutes",
            "select matches.tourney_name, matches.winner_entry",
            "select matches.tourney_name, matches.tourney_level",
            "select matches.tourney_name, matches.tourney_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the tourneys that have more than ten matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who has won the most time? And what are their rank points?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, t2.c2, t2.c3",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, t2.c2, t2.c3"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who has won the most time? And what are their rank points?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t2.c2, t2.c3",
        "label": "select t1.c27, t1.c29",
        "score": false,
        "real_pred": "select rankings.player_id, rankings.ranking_points",
        "real_label": "select matches.winner_name, matches.winner_rank_points",
        "topk_preds": [
            "select rankings.player_id, rankings.ranking_points",
            "select matches.draw_size, rankings.ranking_points",
            "select matches.winner_name, rankings.ranking_points",
            "select players.first_name, players.last_name, rankings.ranking_points",
            "select rankings.ranking, rankings.ranking_points",
            "select matches.draw_size, rankings.player_id",
            "select rankings.ranking_date, rankings.ranking_points",
            "select matches.winner_rank, rankings.ranking_points"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who has won the most time? And what are their rank points?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1",
        "score": false,
        "real_pred": "matches rankings",
        "real_label": "matches",
        "topk_preds": [
            "matches rankings",
            "players matches rankings",
            "",
            "rankings",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which ship has caused most total injuries, and what is its ID?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, t1.c1",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which ship has caused most total injuries, and what is its ID?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select t1.c2, t1.c1",
        "label": "select t1.c1, t1.c2",
        "score": false,
        "real_pred": "select ship.name, ship.id",
        "real_label": "select ship.id, ship.name",
        "topk_preds": [
            "select ship.name, ship.id",
            "select ship.id, ship.name",
            "select ship.name.c1, ship.id",
            "select ship.lost_in_battle, ship.name",
            "select ship.name, ship.id",
            "select death.id, ship.name",
            "select t1.c 2, ship.id",
            "select ship.name.c1, ship.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which ship has caused most total injuries, and what is its ID?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "ship death",
        "real_label": "ship death",
        "topk_preds": [
            "ship death",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find battles and results when Bulgarians commander is not'Boril'., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander (Boril), c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find battles and results when Bulgarians commander is not'Boril'., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander (Boril), c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select t0.c1, t0.c5",
        "label": "select t0.c1, t0.c5",
        "score": true,
        "real_pred": "select battle.name, battle.result",
        "real_label": "select battle.name, battle.result",
        "topk_preds": [
            "select battle.name, battle.result",
            "select battle.id, battle.name, battle.result",
            "select battle.name, battle.date, battle.bulgarian_commander, battle.result",
            "select battle.name, battle.bulgarian_commander, battle.result",
            "select battle.id, battle.result",
            "select battle.id, battle.bulgarian_commander, battle.result",
            "select battle.name, battle.date, battle.result",
            "select battle.id, battle.name, battle.bulgarian_commander, battle.result"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find battles and results when Bulgarians commander is not'Boril'., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander (Boril), c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "battle",
        "real_label": "battle",
        "topk_preds": [
            "battle",
            "battle ship",
            "battle death",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name the distinct battles, that happened between Bulgarian Commander Kaloyan and Latin Commander Baldwin I?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander (Kaloyan), c4: latin_commander (Baldwin I), c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name the distinct battles, that happened between Bulgarian Commander Kaloyan and Latin Commander Baldwin I?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander (Kaloyan), c4: latin_commander (Baldwin I), c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select distinct t0.c1",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select distinct battle.name",
        "real_label": "select battle.name",
        "topk_preds": [
            "select distinct battle.name",
            "select distinct battle.name, battle.date",
            "select distinct battle.name, battle.date, battle.bulgarian_commander, battle.latin_commander",
            "select distinct battle.name, battle.bulgarian_commander, battle.latin_commander",
            "select distinct battle.name, battle.date, battle.bulgarian_commander, battle.latin_commander",
            "select distinct battle.name, battle.date, battle.bulgarian_commander",
            "select distinct battle.name, battle.date.c3, battle.latin_commander",
            "select battle.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name the distinct battles, that happened between Bulgarian Commander Kaloyan and Latin Commander Baldwin I?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander (Kaloyan), c4: latin_commander (Baldwin I), c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "battle",
        "real_label": "battle",
        "topk_preds": [
            "battle",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What were the different battles involving commander Kaloyan against Latin commander Baldwin I?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander (Kaloyan), c4: latin_commander (Baldwin I), c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DIFFEXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-SECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What were the different battles involving commander Kaloyan against Latin commander Baldwin I?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander (Kaloyan), c4: latin_commander (Baldwin I), c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select distinct t0.c1",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select distinct battle.name",
        "real_label": "select battle.name",
        "topk_preds": [
            "select distinct battle.name",
            "select distinct battle.name, battle.date",
            "select count(*)",
            "select count(distinct battle.name)",
            "select distinct battle.name, battle.bulgarian_commander",
            "select distinct battle.name, battle.latin_commander",
            "select distinct battle.name, battle.result",
            "select battle.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What were the different battles involving commander Kaloyan against Latin commander Baldwin I?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander (Kaloyan), c4: latin_commander (Baldwin I), c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "battle",
        "real_label": "battle",
        "topk_preds": [
            "battle",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: A list of battles, where were they held, and what was the results?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM, WHERE-UNION-SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM, WHERE-INTERSECT-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM, WHERE-ORDER BY-LIMIT",
            "SELECT-FROM -ORDER BY-LIMIT",
            "SELECT-FROM, WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: A list of battles, where were they held, and what was the results?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select t0.c1, t0.c2, t0.c5",
        "label": "select t0.c1, t0.c2",
        "score": false,
        "real_pred": "select battle.name, battle.date, battle.result",
        "real_label": "select battle.name, battle.date",
        "topk_preds": [
            "select battle.name, battle.date, battle.result",
            "select battle.id, battle.name, battle.date, battle.result",
            "select battle.id, battle.date, battle.result",
            "select battle.name, battle.bulgarian_commander, battle.latin_commander, battle.result",
            "select battle.name, battle.date, battle.result",
            "select battle.name, battle.bulgarian_commander, battle.latin_commander",
            "select battle.name, battle.date, battle.result",
            "select battle.name, battle.bulgarian_commander, battle.result"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: A list of battles, where were they held, and what was the results?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "battle",
        "real_label": "battle",
        "topk_preds": [
            "battle",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When is transcripts for two or more courses, what id does it contain?., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAMMA-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAGLE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAGLE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When is transcripts for two or more courses, what id does it contain?., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment",
        "prediction": "select t8.c1",
        "label": "select t9.c1, t10.c1",
        "score": false,
        "real_pred": "select Student_Enrolment_Courses.course_id",
        "real_label": "select Transcripts.transcript_date, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select Student_Enrolment_Courses.course_id",
            "select Student_Enrolment_Courses.student_course_id",
            "select Student_Enrolment.degree_program_id",
            "select Student_Enrolment.student_enrolment_id",
            "select Transcripts.transcript_id",
            "select Transcript_Contents.student_course_id",
            "select Student_Enrolment_Courses.student_course_id0",
            "select Student_Enrolment_Courses.student_enrolment_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When is transcripts for two or more courses, what id does it contain?., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "t8",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Student_Enrolment_Courses",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Student_Enrolment_Courses",
            "Transcript_Contents",
            "Transcripts",
            "Courses Student_Enrolment_Courses",
            "Semesters Student_Enrolment",
            "Semesters Student_Enrolment_Courses",
            "Student_Enrolment",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: In which courses have less than two sections? And their ids?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: In which courses have less than two sections? And their ids?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0",
        "prediction": "select t4.c1, t4.c2",
        "label": "select t1.c1, t1.c0",
        "score": false,
        "real_pred": "select Sections.course_id, Sections.section_name",
        "real_label": "select Courses.course_name, Courses.course_id",
        "topk_preds": [
            "select Sections.course_id, Sections.section_name",
            "select Courses.course_name, Sections.course_id",
            "select Sections.course_id, Courses.course_description",
            "select Sections.course_id, Courses.course_name",
            "select Sections.course_id, Sections.course_id",
            "select Sections.course_id, Sections.section_id",
            "select Courses.course_name, Courses.course_id",
            "select Courses.course_id, Sections.course_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: In which courses have less than two sections? And their ids?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "t4",
        "label": "t1 t4",
        "score": false,
        "real_pred": "Sections",
        "real_label": "Courses Sections",
        "topk_preds": [
            "Sections",
            "Courses Sections",
            "Departments Sections",
            "Courses Departments Sections",
            "Degree_Programs Sections",
            "Addresses Courses Sections",
            "Courses Degree_Programs Sections",
            "Courses Departments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are the people studying bachelor degrees?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name (Bachelor), c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_i",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are the people studying bachelor degrees?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name (Bachelor), c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "select distinct t7.c1, t7.c2",
        "label": "select distinct t6.c3, t6.c4, t6.c5",
        "score": false,
        "real_pred": "select distinct Student_Enrolment.degree_program_id, Student_Enrolment.semester_id",
        "real_label": "select distinct Students.first_name, Students.middle_name, Students.last_name",
        "topk_preds": [
            "select distinct Student_Enrolment.degree_program_id, Student_Enrolment.semester_id",
            "select distinct Student_Enrolment_Courses.course_id, Student_Enrolment_Courses.student_enrolment_id",
            "select Student_Enrolment_Courses.course_id",
            "select distinct Student_Enrolment_Courses.course_id",
            "select distinct Student_Enrolment.student_enrolment_id",
            "select distinct Student_Enrolment.degree_program_id",
            "select Student_Enrolment.degree_program_id, Student_Enrolment.semester_id",
            "select Students.current_address_id, Students.permanent_address_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are the people studying bachelor degrees?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name (Bachelor), c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id",
        "prediction": "t3 t6 t8",
        "label": "t3 t6 t7",
        "score": false,
        "real_pred": "Degree_Programs Students Student_Enrolment_Courses",
        "real_label": "Degree_Programs Students Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Students Student_Enrolment_Courses",
            "Degree_Programs Students",
            "Degree_Programs Students Student_Enrolment",
            "Degree_Programs Students Transcripts",
            "Departments Degree_Programs Students Student_Enrolment_Courses",
            "Courses Degree_Programs Students Student_Enrolment_Courses",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which program has the highest number of students enrolled in it?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-PROGRAM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUPS-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which program has the highest number of students enrolled in it?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "select t3.c2",
        "label": "select t3.c2",
        "score": true,
        "real_pred": "select Degree_Programs.degree_summary_name",
        "real_label": "select Degree_Programs.degree_summary_name",
        "topk_preds": [
            "select Degree_Programs.degree_summary_name",
            "select Degree_Programs.department_id",
            "select Departments.department_name, Student_Enrolment.semester_id",
            "select Departments.department_name",
            "select Degree_Programs.department_id, Student_Enrolment.semester_id",
            "select Departments.department_name, Degree_Programs.degree_summary_name",
            "select Departments.department_name, Departments.department_description",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which program has the highest number of students enrolled in it?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_i",
        "prediction": "t1 t3 t7",
        "label": "t3 t7",
        "score": false,
        "real_pred": "Courses Degree_Programs Student_Enrolment",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Courses Degree_Programs Student_Enrolment",
            "Courses Departments Degree_Programs Student_Enrolment",
            "Departments Degree_Programs Student_Enrolment",
            "Courses Semesters Degree_Programs Student_Enrolment",
            "Courses Student_Enrolment",
            "Courses Students Student_Enrolment",
            "Courses Semesters Student_Enrolment",
            "Courses Semesters Students Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which program has most number of people are studying., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id,",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-COURSE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which program has most number of people are studying., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "select t3.c1",
        "label": "select t3.c2",
        "score": false,
        "real_pred": "select Degree_Programs.department_id",
        "real_label": "select Degree_Programs.degree_summary_name",
        "topk_preds": [
            "select Degree_Programs.department_id",
            "select Degree_Programs.degree_summary_name",
            "select Degree_Programs.department_id, Student_Enrolment.semester_id",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id",
            "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name",
            "select Degree_Programs.department_id, Student_Enrolment.degree_program_id",
            "select Departments.department_name, Degree_Programs.degree_summary_name",
            "select Degree_Programs.degree_program_id, Degree_Programs.department_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which program has most number of people are studying., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, ",
        "prediction": "t3 t7",
        "label": "t3 t7",
        "score": true,
        "real_pred": "Degree_Programs Student_Enrolment",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Student_Enrolment",
            "Degree_Programs Students Student_Enrolment",
            "Departments Degree_Programs Student_Enrolment",
            "Courses Degree_Programs Student_Enrolment",
            "Courses Departments Degree_Programs Student_Enrolment",
            "Departments Degree_Programs Students Student_Enrolment",
            "Sections Students Student_Enrolment",
            "Courses Degree_Programs Students Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which program has most people enrolled?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which program has most people enrolled?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_i",
        "prediction": "select t1.c1",
        "label": "select t3.c2",
        "score": false,
        "real_pred": "select Courses.course_name",
        "real_label": "select Degree_Programs.degree_summary_name",
        "topk_preds": [
            "select Courses.course_name",
            "select Degree_Programs.department_id",
            "select Departments.department_name",
            "select Courses.course_name, Departments.department_description",
            "select Departments.department_name, Student_Enrolment.semester_id",
            "select Departments.department_name, Degree_Programs.degree_summary_name",
            "select Degree_Programs.degree_summary_name",
            "select Departments.department_name, Departments.department_description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which program has most people enrolled?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c1",
        "prediction": "t1 t3 t7",
        "label": "t3 t7",
        "score": false,
        "real_pred": "Courses Degree_Programs Student_Enrolment",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Courses Degree_Programs Student_Enrolment",
            "Courses Student_Enrolment",
            "Courses Departments Degree_Programs Student_Enrolment",
            "Courses Students Student_Enrolment",
            "Courses Semesters Student_Enrolment",
            "Courses Semesters Degree_Programs Student_Enrolment",
            "Courses Semesters Students Student_Enrolment",
            "Courses Sections Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which program has most in enrollment?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c1",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which program has most in enrollment?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id",
        "prediction": "select t2.c1",
        "label": "select t3.c2",
        "score": false,
        "real_pred": "select Departments.department_name",
        "real_label": "select Degree_Programs.degree_summary_name",
        "topk_preds": [
            "select Departments.department_name",
            "select Degree_Programs.department_id",
            "select Degree_Programs.degree_summary_name",
            "select Departments.department_name, Student_Enrolment.semester_id",
            "select Departments.department_name, Degree_Programs.degree_summary_name",
            "select Departments.department_name, Student_Enrolment.degree_program_id",
            "select Departments.department_name, Departments.department_description",
            "select Degree_Programs.department_id, Student_Enrolment.semester_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which program has most in enrollment?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c1:",
        "prediction": "t1 t2 t3 t7",
        "label": "t3 t7",
        "score": false,
        "real_pred": "Courses Departments Degree_Programs Student_Enrolment",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Courses Departments Degree_Programs Student_Enrolment",
            "Departments Degree_Programs Student_Enrolment",
            "Courses Degree_Programs Student_Enrolment",
            "Addresses Courses Departments Degree_Programs Student_Enrolment",
            "",
            "",
            "Courses Departments Degree_Programs",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which program has most students enrolled in?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, ",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUPS-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which program has most students enrolled in?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "select t2.c1",
        "label": "select t3.c2",
        "score": false,
        "real_pred": "select Departments.department_name",
        "real_label": "select Degree_Programs.degree_summary_name",
        "topk_preds": [
            "select Departments.department_name",
            "select Degree_Programs.department_id",
            "select Degree_Programs.degree_summary_name",
            "select Departments.department_name, Student_Enrolment.semester_id",
            "select Departments.department_name, Student_Enrolment.degree_program_id",
            "select Departments.department_name, Degree_Programs.degree_summary_name",
            "select Degree_Programs.department_id, Student_Enrolment.semester_id",
            "select Departments.department_name, Departments.department_description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which program has most students enrolled in?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c",
        "prediction": "t1 t2 t3 t7",
        "label": "t3 t7",
        "score": false,
        "real_pred": "Courses Departments Degree_Programs Student_Enrolment",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Courses Departments Degree_Programs Student_Enrolment",
            "Courses Degree_Programs Student_Enrolment",
            "",
            "Addresses Courses Departments Degree_Programs Student_Enrolment",
            "Departments Degree_Programs Student_Enrolment",
            "Courses Semesters Degree_Programs Student_Enrolment",
            "Courses Semesters Student_Enrolment",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When was the earliest transcript released, and what Details?., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When was the earliest transcript released, and what Details?., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "select t8.c5, t8.c6",
        "label": "select t9.c1, t9.c2",
        "score": false,
        "real_pred": "select t8.c5, t8.c6",
        "real_label": "select Transcripts.transcript_date, Transcripts.other_details",
        "topk_preds": [
            "select t8.c5, t8.c6",
            "select t7.c9, Student_Enrolment.degree_program_id3",
            "select t7.c9, Student_Enrolment.degree_program_id2",
            "select t12.c5, t12.c6",
            "select t7.c9, Student_Enrolment.degree_program_id0",
            "select t7.c5, t7.c6",
            "select t7.c9, Student_Enrolment.degree_program_id1",
            "select t9.c5, t9.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When was the earliest transcript released, and what Details?., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_i",
        "prediction": "t9",
        "label": "t9",
        "score": true,
        "real_pred": "Transcripts",
        "real_label": "Transcripts",
        "topk_preds": [
            "Transcripts",
            "Transcript_Contents",
            "Student_Enrolment_Courses",
            "Courses Student_Enrolment_Courses",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When was the earliest transcript released, and what details can you tell me?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When was the earliest transcript released, and what details can you tell me?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0",
        "prediction": "select t8.c5, t8.c6",
        "label": "select t9.c1, t9.c2",
        "score": false,
        "real_pred": "select t8.c5, t8.c6",
        "real_label": "select Transcripts.transcript_date, Transcripts.other_details",
        "topk_preds": [
            "select t8.c5, t8.c6",
            "select t8.c5, t9.c6",
            "select t7.c9, Student_Enrolment.degree_program_id0",
            "select t12.c5, t12.c6",
            "select t11.c2, t11.c3",
            "select t10.c5, t10.c6",
            "select t9.c5, t9.c6",
            "select t8.c5, t8.c7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When was the earliest transcript released, and what details can you tell me?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "t9",
        "label": "t9",
        "score": true,
        "real_pred": "Transcripts",
        "real_label": "Transcripts",
        "topk_preds": [
            "Transcripts",
            "Transcript_Contents",
            "Student_Enrolment_Courses",
            "Courses Student_Enrolment_Courses",
            "Semesters Student_Enrolment",
            "Addresses Transcripts",
            "Semesters Student_Enrolment_Courses",
            "Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When was the earliest transcript Released, and what is Details could help me please?., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When was the earliest transcript Released, and what is Details could help me please?., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment",
        "prediction": "select t8.c5, t8.c6",
        "label": "select t9.c1, t9.c2",
        "score": false,
        "real_pred": "select t8.c5, t8.c6",
        "real_label": "select Transcripts.transcript_date, Transcripts.other_details",
        "topk_preds": [
            "select t8.c5, t8.c6",
            "select t9.c5, t9.c6",
            "select t7.c9, Student_Enrolment.degree_program_id2",
            "select t10.c5, t10.c6",
            "select t12.c5, t12.c6",
            "select t8.c5, t9.c6",
            "select t7.c9, Student_Enrolment.degree_program_id0",
            "select t7.c9, Student_Enrolment.degree_program_id3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When was the earliest transcript Released, and what is Details could help me please?., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "t9",
        "label": "t9",
        "score": true,
        "real_pred": "Transcripts",
        "real_label": "Transcripts",
        "topk_preds": [
            "Transcripts",
            "Transcript_Contents",
            "Student_Enrolment_Courses",
            "",
            "Courses Student_Enrolment_Courses",
            "",
            "Courses Student_Enrolment",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When was the earliest transcript released and what details can you tell me?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When was the earliest transcript released and what details can you tell me?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "select t8.c5, t8.c6",
        "label": "select t9.c1, t9.c2",
        "score": false,
        "real_pred": "select t8.c5, t8.c6",
        "real_label": "select Transcripts.transcript_date, Transcripts.other_details",
        "topk_preds": [
            "select t8.c5, t8.c6",
            "select t7.c9, Student_Enrolment.degree_program_id0",
            "select t8.c5, t9.c6",
            "select t12.c5, t12.c6",
            "select t11.c2, t11.c3",
            "select t10.c5, t10.c6",
            "select t9.c5, t9.c6",
            "select t8.c3, t8.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When was the earliest transcript released and what details can you tell me?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "t9",
        "label": "t9",
        "score": true,
        "real_pred": "Transcripts",
        "real_label": "Transcripts",
        "topk_preds": [
            "Transcripts",
            "Student_Enrolment_Courses",
            "Transcript_Contents",
            "Courses Student_Enrolment_Courses",
            "Addresses Transcripts",
            "Semesters Student_Enrolment_Courses",
            "Semesters Student_Enrolment",
            "Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When were transcripts released first time, and what details could I know?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When were transcripts released first time, and what details could I know?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "select t8.c5, t8.c6",
        "label": "select t9.c1, t9.c2",
        "score": false,
        "real_pred": "select t8.c5, t8.c6",
        "real_label": "select Transcripts.transcript_date, Transcripts.other_details",
        "topk_preds": [
            "select t8.c5, t8.c6",
            "select t8.c5, t9.c6",
            "select t7.c9, Student_Enrolment.degree_program_id0",
            "select t8.c5, t10.c6",
            "select t9.c5, t9.c6",
            "select t10.c5, t10.c6",
            "select t12.c5, t12.c6",
            "select t7.c5, t7.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When were transcripts released first time, and what details could I know?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "t9",
        "label": "t9",
        "score": true,
        "real_pred": "Transcripts",
        "real_label": "Transcripts",
        "topk_preds": [
            "Transcripts",
            "Transcript_Contents",
            "Student_Enrolment_Courses",
            "Addresses Transcripts",
            "Courses Student_Enrolment_Courses",
            "Semesters Student_Enrolment",
            "Student_Enrolment",
            "Semesters Student_Enrolment_Courses"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When was the earliest transcript released? and what details can you tell me?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When was the earliest transcript released? and what details can you tell me?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0",
        "prediction": "select t8.c5, t8.c6",
        "label": "select t9.c1, t9.c2",
        "score": false,
        "real_pred": "select t8.c5, t8.c6",
        "real_label": "select Transcripts.transcript_date, Transcripts.other_details",
        "topk_preds": [
            "select t8.c5, t8.c6",
            "select t8.c5, t9.c6",
            "select t7.c9, Student_Enrolment.degree_program_id0",
            "select t10.c5, t10.c6",
            "select t12.c5, t12.c6",
            "select t9.c5, t9.c6",
            "select t11.c2, t11.c3",
            "select t8.c5, t10.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When was the earliest transcript released? and what details can you tell me?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "t9",
        "label": "t9",
        "score": true,
        "real_pred": "Transcripts",
        "real_label": "Transcripts",
        "topk_preds": [
            "Transcripts",
            "Transcript_Contents",
            "Student_Enrolment_Courses",
            "Courses Student_Enrolment_Courses",
            "",
            "Student_Enrolment",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who is the eldest graduated student?., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id,",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who is the eldest graduated student?., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "select t8.c1",
        "label": "select t6.c3, t6.c4, t6.c5",
        "score": false,
        "real_pred": "select Student_Enrolment_Courses.course_id",
        "real_label": "select Students.first_name, Students.middle_name, Students.last_name",
        "topk_preds": [
            "select Student_Enrolment_Courses.course_id",
            "select Students.current_address_id3",
            "select Student_Enrolment_Courses.student_course_id",
            "select Students.current_address_id, Students.last_name",
            "select Students.last_name",
            "select Student_Enrolment_Courses.course_id, Students.last_name",
            "select t12.c3",
            "select Students.other_student_details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who is the eldest graduated student?., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, ",
        "prediction": "t6 t8",
        "label": "t6",
        "score": false,
        "real_pred": "Students Student_Enrolment_Courses",
        "real_label": "Students",
        "topk_preds": [
            "Students Student_Enrolment_Courses",
            "Students",
            "Semesters Students Student_Enrolment_Courses",
            "Students Student_Enrolment",
            "Sections Students Student_Enrolment_Courses",
            "Semesters Students Student_Enrolment",
            "Students Transcripts",
            "Student_Enrolment_Courses"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When was the latest transcript release?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c1",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM -ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM.ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When was the latest transcript release?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id",
        "prediction": "select max(t10.c6)",
        "label": "select t9.c1",
        "score": false,
        "real_pred": "select max(t10.c6)",
        "real_label": "select Transcripts.transcript_date",
        "topk_preds": [
            "select max(t10.c6)",
            "select t8.c5",
            "select max(t9.c6)",
            "select t9.c5",
            "select max(t8.c6)",
            "select max(t10.c5)",
            "select max(t10.c7)",
            "select t10.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When was the latest transcript release?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c1:",
        "prediction": "t9",
        "label": "t9",
        "score": true,
        "real_pred": "Transcripts",
        "real_label": "Transcripts",
        "topk_preds": [
            "Transcripts",
            "Transcript_Contents",
            "Student_Enrolment_Courses",
            "",
            "",
            "",
            "Student_Enrolment",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Summarize degrees that have the most enrollments., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-COURSE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Summarize degrees that have the most enrollments., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "select t3.c2",
        "label": "select t3.c2",
        "score": true,
        "real_pred": "select Degree_Programs.degree_summary_name",
        "real_label": "select Degree_Programs.degree_summary_name",
        "topk_preds": [
            "select Degree_Programs.degree_summary_name",
            "select Degree_Programs.degree_summary_name, Degree_Programs.degree_summary_description",
            "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name",
            "select Degree_Programs.department_id, Degree_Programs.degree_summary_description",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.student_id",
            "select Degree_Programs.department_id, Degree_Programs.degree_summary_name",
            "select Degree_Programs.degree_summary_description",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Summarize degrees that have the most enrollments., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id,",
        "prediction": "t3 t7",
        "label": "t3 t7",
        "score": true,
        "real_pred": "Degree_Programs Student_Enrolment",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Student_Enrolment",
            "Departments Degree_Programs Student_Enrolment",
            "Departments Student_Enrolment",
            "",
            "Courses Student_Enrolment",
            "",
            "Sections Student_Enrolment",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What degree summary is the one with most number of students enrolled?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What degree summary is the one with most number of students enrolled?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "select t3.c2",
        "label": "select t3.c2",
        "score": true,
        "real_pred": "select Degree_Programs.degree_summary_name",
        "real_label": "select Degree_Programs.degree_summary_name",
        "topk_preds": [
            "select Degree_Programs.degree_summary_name",
            "select Degree_Programs.degree_summary_name, Degree_Programs.degree_summary_description",
            "select Degree_Programs.degree_summary_description",
            "select Degree_Programs.degree_summary_name (or Degree_Programs.degree_summary_description)",
            "select Degree_Programs.degree_summary_name-description",
            "select Degree_Programs.degree_summary_name (Degree_Programs.degree_summary_description)",
            "select Degree_Programs.degree_summary_name (Student_Enrolment.degree_program_id)",
            "select Degree_Programs.degree_summary_name_description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What degree summary is the one with most number of students enrolled?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "t3 t7",
        "label": "t3 t7",
        "score": true,
        "real_pred": "Degree_Programs Student_Enrolment",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Student_Enrolment",
            "Departments Degree_Programs Student_Enrolment",
            "Courses Degree_Programs Student_Enrolment",
            "Departments Student_Enrolment",
            "Addresses Degree_Programs Student_Enrolment",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name of degree program with highest number of students., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id,",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name of degree program with highest number of students., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "select t3.c2",
        "label": "select t3.c2",
        "score": true,
        "real_pred": "select Degree_Programs.degree_summary_name",
        "real_label": "select Degree_Programs.degree_summary_name",
        "topk_preds": [
            "select Degree_Programs.degree_summary_name",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id",
            "select Degree_Programs.degree_summary_name, Students.current_address_id",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id3",
            "select Degree_Programs.degree_summary_name, Students.current_address_id3",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.semester_id",
            "select Degree_Programs.degree_summary_name, Students.other_student_details",
            "select Degree_Programs.degree_summary_name (Student_Enrolment.degree_program_id3)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name of degree program with highest number of students., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, ",
        "prediction": "t3 t6",
        "label": "t3 t7",
        "score": false,
        "real_pred": "Degree_Programs Students",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Students",
            "Degree_Programs Students Student_Enrolment_Courses",
            "Degree_Programs Student_Enrolment",
            "Degree_Programs Students Student_Enrolment",
            "Degree_Programs Student_Enrolment_Courses",
            "",
            "",
            "Degree_Programs Transcripts"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What course had the most number of enrollment?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, ",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What course had the most number of enrollment?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select Courses.course_name",
        "real_label": "select Courses.course_name",
        "topk_preds": [
            "select Courses.course_name",
            "select Courses.course_name, Student_Enrolment.semester_id",
            "select Courses.course_name, Student_Enrolment.degree_program_id",
            "select Courses.course_name, Student_Enrolment.student_id",
            "select Courses.course_name, Courses.course_description",
            "select Courses.course_name (Student_Enrolment.semester_id)",
            "select Courses.course_name(Student_Enrolment.semester_id)",
            "select Courses.course_name, Sections.section_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What course had the most number of enrollment?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c",
        "prediction": "t1 t7",
        "label": "t1 t8",
        "score": false,
        "real_pred": "Courses Student_Enrolment",
        "real_label": "Courses Student_Enrolment_Courses",
        "topk_preds": [
            "Courses Student_Enrolment",
            "Courses Sections Student_Enrolment",
            "Courses Students Student_Enrolment",
            "Addresses Courses Sections Student_Enrolment",
            "Addresses Courses Student_Enrolment",
            "Courses Departments Student_Enrolment",
            "Courses Semesters Student_Enrolment",
            "Courses Departments Sections Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What course has most number of enrollment?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What course has most number of enrollment?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_i",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select Courses.course_name",
        "real_label": "select Courses.course_name",
        "topk_preds": [
            "select Courses.course_name",
            "select Courses.course_name, Student_Enrolment.semester_id",
            "select Courses.course_name, Student_Enrolment.degree_program_id",
            "select Courses.course_name, Student_Enrolment.student_id",
            "select Courses.course_name (Student_Enrolment.semester_id)",
            "select Courses.course_name, Courses.course_description",
            "select Courses.course_name, Sections.section_name",
            "select Courses.course_name(Student_Enrolment.semester_id)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What course has most number of enrollment?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c1",
        "prediction": "t1 t7",
        "label": "t1 t8",
        "score": false,
        "real_pred": "Courses Student_Enrolment",
        "real_label": "Courses Student_Enrolment_Courses",
        "topk_preds": [
            "Courses Student_Enrolment",
            "Courses Sections Student_Enrolment",
            "Addresses Courses Student_Enrolment",
            "Courses Students Student_Enrolment",
            "Addresses Courses Sections Student_Enrolment",
            "",
            "Courses Student_Enrolment_Courses",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What courses have at most 2 sections? And What are their ids?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING-",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROMGROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What courses have at most 2 sections? And What are their ids?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "select t1.c1, t4.c1",
        "label": "select t1.c1, t1.c0",
        "score": false,
        "real_pred": "select Courses.course_name, Sections.course_id",
        "real_label": "select Courses.course_name, Courses.course_id",
        "topk_preds": [
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Courses.course_id",
            "select Sections.course_id, Sections.section_name",
            "select Sections.course_id, Courses.course_name",
            "select Courses.course_id, Courses.course_name",
            "select Sections.course_id, Courses.course_description",
            "select Courses.course_id, Sections.course_id",
            "select Courses.course_name, Sections.section_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What courses have at most 2 sections? And What are their ids?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "t1 t4",
        "label": "t1 t4",
        "score": true,
        "real_pred": "Courses Sections",
        "real_label": "Courses Sections",
        "topk_preds": [
            "Courses Sections",
            "Courses Departments Sections",
            "Courses Degree_Programs Sections",
            "Addresses Courses Sections",
            "Departments Sections",
            "Addresses Courses Departments Sections",
            "Courses Departments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the courses that have at most 2 sections? And their ID?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the courses that have at most 2 sections? And their ID?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "select t1.c1, t4.c1",
        "label": "select t1.c1, t1.c0",
        "score": false,
        "real_pred": "select Courses.course_name, Sections.course_id",
        "real_label": "select Courses.course_name, Courses.course_id",
        "topk_preds": [
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Courses.course_id",
            "select Sections.course_id, Courses.course_name",
            "select Sections.course_id, Courses.course_description",
            "select Courses.course_name, Sections.section_id",
            "select Courses.course_name, Departments.department_id",
            "select Sections.course_id, Sections.section_name",
            "select Courses.course_id, Courses.course_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the courses that have at most 2 sections? And their ID?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "t1 t4",
        "label": "t1 t4",
        "score": true,
        "real_pred": "Courses Sections",
        "real_label": "Courses Sections",
        "topk_preds": [
            "Courses Sections",
            "Courses Departments Sections",
            "",
            "Addresses Courses Sections",
            "",
            "",
            "Addresses Courses Departments Sections",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the semester without any students, which one?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id,",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the semester without any students, which one?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "select t5.c1",
        "label": "select t5.c1",
        "score": true,
        "real_pred": "select Semesters.semester_name",
        "real_label": "select Semesters.semester_name",
        "topk_preds": [
            "select Semesters.semester_name",
            "select Semesters.semester_name, Semesters.semester_description",
            "select Semesters.semester_name, Semesters.semester_description, Semesters.other_details",
            "select Semesters.semester_id, Semesters.semester_name",
            "select Semesters.semester_name, Semesters.other_details",
            "select Semesters.semester_name, Semesters.semester_description, t5.Semesters.other_details",
            "select Semesters.semester_name, Students.current_address_id, Semesters.semester_description",
            "select Semesters.semester_name, Students.current_address_id, Student_Enrolment.semester_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the semester without any students, which one?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, ",
        "prediction": "t5 t6",
        "label": "t5 t7",
        "score": false,
        "real_pred": "Semesters Students",
        "real_label": "Semesters Student_Enrolment",
        "topk_preds": [
            "Semesters Students",
            "Semesters Student_Enrolment",
            "Semesters",
            "Semesters Students Student_Enrolment",
            "Semesters Student_Enrolment_Courses",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all courses which ever have students enrolling., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id,",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ACT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all courses which ever have students enrolling., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "select t1.c1",
        "label": "select distinct t1.c1",
        "score": false,
        "real_pred": "select Courses.course_name",
        "real_label": "select distinct Courses.course_name",
        "topk_preds": [
            "select Courses.course_name",
            "select distinct Courses.course_name",
            "select Courses.course_name, Student_Enrolment.semester_id",
            "select distinct Courses.course_name, Student_Enrolment.semester_id",
            "select Courses.course_name, Student_Enrolment.degree_program_id",
            "select Departments.department_name, Student_Enrolment.semester_id",
            "select Sections.course_id, Student_Enrolment.semester_id",
            "select only Courses.course_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all courses which ever have students enrolling., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, ",
        "prediction": "t1 t7",
        "label": "t1 t8",
        "score": false,
        "real_pred": "Courses Student_Enrolment",
        "real_label": "Courses Student_Enrolment_Courses",
        "topk_preds": [
            "Courses Student_Enrolment",
            "Addresses Courses Student_Enrolment",
            "Courses Sections Student_Enrolment",
            "Addresses Courses Sections Student_Enrolment",
            "",
            "",
            "Sections Student_Enrolment",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the courses that have ever had students enrolled in?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the courses that have ever had students enrolled in?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "select t1.c1",
        "label": "select distinct t1.c1",
        "score": false,
        "real_pred": "select Courses.course_name",
        "real_label": "select distinct Courses.course_name",
        "topk_preds": [
            "select Courses.course_name",
            "select distinct Courses.course_name",
            "select Courses.course_name, Student_Enrolment.semester_id",
            "select distinct Courses.course_name, Student_Enrolment.semester_id",
            "select only Courses.course_name",
            "select Courses.course_name, Student_Enrolment.degree_program_id",
            "select only Courses.course_name, Student_Enrolment.semester_id",
            "select Courses.course_name, Student_Enrolment.student_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the courses that have ever had students enrolled in?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_i",
        "prediction": "t1 t7",
        "label": "t1 t8",
        "score": false,
        "real_pred": "Courses Student_Enrolment",
        "real_label": "Courses Student_Enrolment_Courses",
        "topk_preds": [
            "Courses Student_Enrolment",
            "Addresses Courses Student_Enrolment",
            "",
            "",
            "",
            "Sections Student_Enrolment",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List departments which offer the most number of degrees, and their ids., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT - SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List departments which offer the most number of degrees, and their ids., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "select t3.c1, t2.c1",
        "label": "select t2.c1, t3.c1",
        "score": false,
        "real_pred": "select Degree_Programs.department_id, Departments.department_name",
        "real_label": "select Departments.department_name, Degree_Programs.department_id",
        "topk_preds": [
            "select Degree_Programs.department_id, Departments.department_name",
            "select Degree_Programs.department_id, Departments.department_description",
            "select Degree_Programs.department_id, Degree_Programs.degree_summary_name",
            "select Departments.department_name, Degree_Programs.department_id",
            "select Degree_Programs.department_id, Departments.department_id",
            "select Degree_Programs.department_id, Departments.other_details",
            "select Degree_Programs.department_id, t2.c4",
            "select Degree_Programs.department_id, Sections.section_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List departments which offer the most number of degrees, and their ids., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "t3",
        "label": "t2 t3",
        "score": false,
        "real_pred": "Degree_Programs",
        "real_label": "Departments Degree_Programs",
        "topk_preds": [
            "Degree_Programs",
            "Departments Degree_Programs",
            "",
            "",
            "",
            "Addresses Departments Degree_Programs",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What's the course that has the most students?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What's the course that has the most students?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select Courses.course_name",
        "real_label": "select Courses.course_name",
        "topk_preds": [
            "select Courses.course_name",
            "select Courses.course_name, Student_Enrolment.semester_id",
            "select Courses.course_name, Student_Enrolment.degree_program_id",
            "select Courses.course_name, Student_Enrolment.student_id",
            "select Courses.course_name, Courses.course_description",
            "select Sections.course_id",
            "select Courses.course_name, Students.student_id",
            "select Courses.course_name, Sections.section_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What's the course that has the most students?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id,",
        "prediction": "t1 t7",
        "label": "t1 t8",
        "score": false,
        "real_pred": "Courses Student_Enrolment",
        "real_label": "Courses Student_Enrolment_Courses",
        "topk_preds": [
            "Courses Student_Enrolment",
            "Courses Sections Students",
            "Courses Sections Student_Enrolment",
            "Courses Sections Students Student_Enrolment",
            "Courses Students Student_Enrolment",
            "Courses Students",
            "Courses Semesters Students Student_Enrolment",
            "Courses Semesters Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What semester had no students enrolled?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-HOLD-EXCEPT-SELECT-FROM",
            "SELECT-FROM-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-SITUATION-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-DEFECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What semester had no students enrolled?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_i",
        "prediction": "select t5.c1",
        "label": "select t5.c1",
        "score": true,
        "real_pred": "select Semesters.semester_name",
        "real_label": "select Semesters.semester_name",
        "topk_preds": [
            "select Semesters.semester_name",
            "select Semesters.semester_name, Student_Enrolment.semester_id",
            "select Semesters.semester_name, Semesters.semester_description",
            "select Semesters.semester_name, Student_Enrolment.degree_program_id",
            "select Semesters.semester_name, Students.permanent_address_id",
            "select Semesters.semester_name, Semesters.other_details",
            "select Semesters.semester_id, Semesters.semester_name",
            "select Semesters.semester_name, Students.current_address_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What semester had no students enrolled?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c1",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Semesters Student_Enrolment",
        "real_label": "Semesters Student_Enrolment",
        "topk_preds": [
            "Semesters Student_Enrolment",
            "Courses Semesters Student_Enrolment",
            "Semesters Students Student_Enrolment",
            "Degree_Programs Semesters Student_Enrolment",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which semester had no student enrolled?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-HOLD-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-SIX-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which semester had no student enrolled?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_i",
        "prediction": "select t5.c1",
        "label": "select t5.c1",
        "score": true,
        "real_pred": "select Semesters.semester_name",
        "real_label": "select Semesters.semester_name",
        "topk_preds": [
            "select Semesters.semester_name",
            "select Semesters.semester_name, Student_Enrolment.semester_id",
            "select Semesters.semester_name, Semesters.semester_description",
            "select Semesters.semester_name, Student_Enrolment.degree_program_id",
            "select Semesters.semester_id, Semesters.semester_name",
            "select Semesters.semester_name, Semesters.other_details",
            "select Semesters.semester_name, Students.permanent_address_id",
            "select Semesters.semester_name, Students.current_address_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which semester had no student enrolled?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c1",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Semesters Student_Enrolment",
        "real_label": "Semesters Student_Enrolment",
        "topk_preds": [
            "Semesters Student_Enrolment",
            "Semesters Students Student_Enrolment",
            "Degree_Programs Semesters Student_Enrolment",
            "Courses Student_Enrolment",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name of the semester with no student?., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, ",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-HAVE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHAT-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name of the semester with no student?., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "select t5.c1",
        "label": "select t5.c1",
        "score": true,
        "real_pred": "select Semesters.semester_name",
        "real_label": "select Semesters.semester_name",
        "topk_preds": [
            "select Semesters.semester_name",
            "select Semesters.semester_name, Semesters.semester_description",
            "select Semesters.semester_name, Semesters.semester_description, Semesters.other_details",
            "select Semesters.semester_name, Students.current_address_id, Student_Enrolment.semester_id",
            "select Semesters.semester_name, Semesters.other_details",
            "select Semesters.semester_name, Semesters.semester_description, t5.Semesters.other_details",
            "select Semesters.semester_name, Students.current_address_id, Semesters.semester_description",
            "select Semesters.semester_name, Semesters.semester_description, t5.dept_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name of the semester with no student?., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c",
        "prediction": "t5 t6",
        "label": "t5 t7",
        "score": false,
        "real_pred": "Semesters Students",
        "real_label": "Semesters Student_Enrolment",
        "topk_preds": [
            "Semesters Students",
            "Semesters",
            "Semesters Student_Enrolment",
            "Semesters Students Student_Enrolment",
            "Semesters Student_Enrolment_Courses",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name the semester when nobody enrolled., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WEIGH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-HOLD-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WEIGH-UNION-SELECT-FROM",
            "SELECT-FROM-HOLD-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name the semester when nobody enrolled., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_i",
        "prediction": "select t5.c1",
        "label": "select t5.c1",
        "score": true,
        "real_pred": "select Semesters.semester_name",
        "real_label": "select Semesters.semester_name",
        "topk_preds": [
            "select Semesters.semester_name",
            "select Semesters.semester_name, Student_Enrolment.semester_id",
            "select Semesters.semester_name, Semesters.semester_description",
            "select Semesters.semester_name, Semesters.semester_description, Semesters.other_details",
            "select Semesters.semester_name, Student_Enrolment.degree_program_id",
            "select Semesters.semester_name, Students.current_address_id, Student_Enrolment.semester_id",
            "select Semesters.semester_name, Student_Enrolment.semester_id, Semesters.other_details",
            "select Semesters.semester_name, Students.permanent_address_id, Student_Enrolment.semester_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name the semester when nobody enrolled., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c1",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Semesters Student_Enrolment",
        "real_label": "Semesters Student_Enrolment",
        "topk_preds": [
            "Semesters Student_Enrolment",
            "Semesters Students Student_Enrolment",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all sections and descriptions., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c1:",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all sections and descriptions., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id,",
        "prediction": "select t4.c2, t4.c3",
        "label": "select t4.c2, t4.c3",
        "score": true,
        "real_pred": "select Sections.section_name, Sections.section_description",
        "real_label": "select Sections.section_name, Sections.section_description",
        "topk_preds": [
            "select Sections.section_name, Sections.section_description",
            "select Sections.section_id, Sections.section_description",
            "select Sections.section_id, Sections.section_name, Sections.section_description",
            "select Sections.section_id, Sections.course_id, Sections.section_description",
            "select Sections.course_id, Sections.section_description",
            "select Sections.other_details, Sections.section_name",
            "select Sections.section_name, Sections.section_description, Sections.section_id",
            "select Sections.section_name-, Sections.section_description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all sections and descriptions., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c1: degree",
        "prediction": "t4",
        "label": "t4",
        "score": true,
        "real_pred": "Sections",
        "real_label": "Sections",
        "topk_preds": [
            "Sections",
            "Departments Sections",
            "",
            "",
            "Degree_Programs Sections",
            "Courses Sections",
            "Addresses Sections",
            "Departments Degree_Programs Sections"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When did the transcript with the fewest results occur, and what is its ID?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT - SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, t8",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When did the transcript with the fewest results occur, and what is its ID?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "select t8.c5, t8.c0",
        "label": "select t9.c1, t10.c1",
        "score": false,
        "real_pred": "select t8.c5, Student_Enrolment_Courses.student_course_id",
        "real_label": "select Transcripts.transcript_date, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t8.c5, Student_Enrolment_Courses.student_course_id",
            "select t8.c5, t8.c6",
            "select t8.c3, t8.c4",
            "select t8.c5, Student_Enrolment.student_enrolment_id",
            "select t8.c5, Transcripts.transcript_id",
            "select t8.c3, Student_Enrolment_Courses.student_course_id",
            "select t8.c5, Student_Enrolment_Courses.course_id",
            "select t8.c5, t7.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When did the transcript with the fewest results occur, and what is its ID?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "t8",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Student_Enrolment_Courses",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Student_Enrolment_Courses",
            "Transcripts",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are all the courses in which students are enrolled?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_i",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM ACT-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM ACT-WHERE",
            "SELECT-FROM ACT-SELECT-FROM",
            "SELECT-FROM ACT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are all the courses in which students are enrolled?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "select t1.c1",
        "label": "select distinct t1.c1",
        "score": false,
        "real_pred": "select Courses.course_name",
        "real_label": "select distinct Courses.course_name",
        "topk_preds": [
            "select Courses.course_name",
            "select distinct Courses.course_name",
            "select Courses.course_name, Student_Enrolment.semester_id",
            "select Student_Enrolment.degree_program_id",
            "select distinct Courses.course_name, Student_Enrolment.semester_id",
            "select separate Courses.course_name, Student_Enrolment.semester_id",
            "select Departments.department_name, Student_Enrolment.semester_id",
            "select Sections.course_id, Student_Enrolment.semester_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are all the courses in which students are enrolled?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id",
        "prediction": "t1 t7",
        "label": "t1 t8",
        "score": false,
        "real_pred": "Courses Student_Enrolment",
        "real_label": "Courses Student_Enrolment_Courses",
        "topk_preds": [
            "Courses Student_Enrolment",
            "Addresses Courses Student_Enrolment",
            "Sections Student_Enrolment",
            "Semesters Student_Enrolment",
            "Departments Student_Enrolment",
            "Degree_Programs Student_Enrolment",
            "",
            "Addresses Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name all the courses that have some students enrolled, Please., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-ACT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM ACT-WHERE",
            "SELECT-FROM ACT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name all the courses that have some students enrolled, Please., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "select t1.c1",
        "label": "select distinct t1.c1",
        "score": false,
        "real_pred": "select Courses.course_name",
        "real_label": "select distinct Courses.course_name",
        "topk_preds": [
            "select Courses.course_name",
            "select Courses.course_name, Student_Enrolment.semester_id",
            "select distinct Courses.course_name",
            "select Courses.course_name, Student_Enrolment.semester_id, Courses.other_details",
            "select Courses.course_name, Student_Enrolment.semester_id, Student_Enrolment.student_id",
            "select distinct Courses.course_name, Student_Enrolment.semester_id",
            "select Courses.course_name, Student_Enrolment.degree_program_id",
            "select distinct Courses.course_name, Student_Enrolment.semester_id, Courses.other_details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name all the courses that have some students enrolled, Please., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_i",
        "prediction": "t1 t7",
        "label": "t1 t8",
        "score": false,
        "real_pred": "Courses Student_Enrolment",
        "real_label": "Courses Student_Enrolment_Courses",
        "topk_preds": [
            "Courses Student_Enrolment",
            "Addresses Courses Student_Enrolment",
            "Courses Sections Student_Enrolment",
            "",
            "",
            "",
            "",
            "Courses Student_Enrolment Sections"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which are the sections in reverse alphabetical order?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id,",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY (SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which are the sections in reverse alphabetical order?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "select t4.c2",
        "label": "select t4.c2",
        "score": true,
        "real_pred": "select Sections.section_name",
        "real_label": "select Sections.section_name",
        "topk_preds": [
            "select Sections.section_name",
            "select Sections.section_name, Sections.section_description",
            "select Sections.section_id, Sections.section_name",
            "select Sections.course_id, Sections.section_name",
            "select Sections.section_name, Sections.course_id",
            "select Sections.section_name, Sections.section_id",
            "select Sections.section_id, Sections.course_id",
            "select Sections.section_name, Sections.other_details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which are the sections in reverse alphabetical order?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, ",
        "prediction": "t4",
        "label": "t4",
        "score": true,
        "real_pred": "Sections",
        "real_label": "Sections",
        "topk_preds": [
            "Sections",
            "Departments Sections",
            "",
            "",
            "Degree_Programs Sections",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What semester is the highest percentage of students enrolled in? And show the ID., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT.",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What semester is the highest percentage of students enrolled in? And show the ID., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "select t5.c1, t7.c2",
        "label": "select t5.c1, t5.c0",
        "score": false,
        "real_pred": "select Semesters.semester_name, Student_Enrolment.semester_id",
        "real_label": "select Semesters.semester_name, Semesters.semester_id",
        "topk_preds": [
            "select Semesters.semester_name, Student_Enrolment.semester_id",
            "select Student_Enrolment.degree_program_id, Semesters.semester_name",
            "select Student_Enrolment.degree_program_id, Student_Enrolment.semester_id",
            "select Semesters.semester_name, Student_Enrolment.degree_program_id",
            "select Student_Enrolment.degree_program_id, Semesters.semester_description",
            "select Semesters.semester_name, Semesters.semester_id",
            "select Semesters.semester_name, Student_Enrolment.student_enrolment_id",
            "select Students.current_address_id, Student_Enrolment.semester_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What semester is the highest percentage of students enrolled in? And show the ID., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Semesters Student_Enrolment",
        "real_label": "Semesters Student_Enrolment",
        "topk_preds": [
            "Semesters Student_Enrolment",
            "Degree_Programs Semesters Student_Enrolment",
            "Departments Semesters Student_Enrolment",
            "",
            "Courses Student_Enrolment",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which semester did most students register in? And show me the id., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GEOGRAPHIE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which semester did most students register in? And show me the id., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0",
        "prediction": "select t5.c1, t7.c0",
        "label": "select t5.c1, t5.c0",
        "score": false,
        "real_pred": "select Semesters.semester_name, Student_Enrolment.student_enrolment_id",
        "real_label": "select Semesters.semester_name, Semesters.semester_id",
        "topk_preds": [
            "select Semesters.semester_name, Student_Enrolment.student_enrolment_id",
            "select Semesters.semester_name, Student_Enrolment.semester_id",
            "select Semesters.semester_name, Student_Enrolment.degree_program_id",
            "select Student_Enrolment.degree_program_id, Semesters.semester_description",
            "select Student_Enrolment.degree_program_id, Semesters.semester_name",
            "select Semesters.semester_name, Semesters.semester_id",
            "select Semesters.semester_name, Student_Enrolment.student_enrolment_id2",
            "select Student_Enrolment.degree_program_id, Semesters.semester_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which semester did most students register in? And show me the id., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Semesters Student_Enrolment",
        "real_label": "Semesters Student_Enrolment",
        "topk_preds": [
            "Semesters Student_Enrolment",
            "Degree_Programs Semesters Student_Enrolment",
            "Departments Semesters Student_Enrolment",
            "",
            "",
            "",
            "Courses Student_Enrolment",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What countries has the most TV channels and how many does it have?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, count(*)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What countries has the most TV channels and how many does it have?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c2, count(*)",
        "label": "select t0.c2, count(*)",
        "score": true,
        "real_pred": "select TV_Channel.Country, count(*)",
        "real_label": "select TV_Channel.Country, count(*)",
        "topk_preds": [
            "select TV_Channel.Country, count(*)",
            "select TV_Channel.Country, count(*), TV_Channel.Language",
            "select TV_Channel.series_name, count(*)",
            "select TV_Channel.Country.c2, count(*)",
            "select TV_Channel.Country.c0, count(*)",
            "select TV_Channel.Country, count(*), TV_Channel.series_name",
            "select TV_Channel.Country, count(*), http://TV_Channel.Language",
            "select TV_Channel.Country, count(**)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What countries has the most TV channels and how many does it have?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which series has the episode \"A Love of a Lifetime\"?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which series has the episode \"A Love of a Lifetime\"?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t1.c1",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select TV_series.Episode",
        "real_label": "select TV_Channel.series_name",
        "topk_preds": [
            "select TV_series.Episode",
            "select TV_series.id",
            "select TV_series.id, TV_series.Episode",
            "select TV_series.Episode, TV_Channel.series_name",
            "select TV_series.Episode, TV_series.Air_Date",
            "select TV_Channel.series_name, TV_series.Episode",
            "select TV_Channel.series_name",
            "select TV_series.id, TV_series.Air_Date"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which series has the episode \"A Love of a Lifetime\"?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t0 t1",
        "score": false,
        "real_pred": "TV_series",
        "real_label": "TV_Channel TV_series",
        "topk_preds": [
            "TV_series",
            "TV_Channel TV_series",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which series has the episode 'A Love of a lifetime'?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which series has the episode 'A Love of a lifetime'?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t1.c1",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select TV_series.Episode",
        "real_label": "select TV_Channel.series_name",
        "topk_preds": [
            "select TV_series.Episode",
            "select TV_series.id",
            "select TV_series.id, TV_series.Episode",
            "select TV_series.Episode, TV_Channel.series_name",
            "select TV_Channel.series_name, TV_series.Episode",
            "select TV_series.Episode, TV_series.Air_Date",
            "select TV_Channel.series_name",
            "select TV_Channel.series_name, TV_series.id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which series has the episode 'A Love of a lifetime'?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t0 t1",
        "score": false,
        "real_pred": "TV_series",
        "real_label": "TV_Channel TV_series",
        "topk_preds": [
            "TV_series",
            "TV_Channel TV_series",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name of the series which has the episode \"A Love of a Lifetime\"., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name of the series which has the episode \"A Love of a Lifetime\"., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select TV_Channel.series_name",
        "real_label": "select TV_Channel.series_name",
        "topk_preds": [
            "select TV_Channel.series_name",
            "select TV_series.Episode",
            "select TV_Channel.series_name, TV_series.Episode",
            "select TV_Channel.series_name, TV_series.Channel",
            "select TV_Channel.series_name, TV_series.Air_Date",
            "select TV_Channel.series_name, TV_series.Viewers_m",
            "select TV_series.Episode, TV_Channel.series_name",
            "select TV_Channel.series_name, TV_series.id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name of the series which has the episode \"A Love of a Lifetime\"., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "TV_Channel TV_series",
        "real_label": "TV_Channel TV_series",
        "topk_preds": [
            "TV_Channel TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What series had the episode \"A love of a lifetime\"?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What series had the episode \"A love of a lifetime\"?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t1.c1",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select TV_series.Episode",
        "real_label": "select TV_Channel.series_name",
        "topk_preds": [
            "select TV_series.Episode",
            "select TV_series.id",
            "select TV_series.id, TV_series.Episode",
            "select TV_series.id, TV_series.Channel",
            "select TV_series.Episode, TV_Channel.series_name",
            "select TV_series.Episode, TV_series.Air_Date",
            "select TV_series.id, TV_series.Weekly_Rank",
            "select TV_series.id, TV_series.18_49_Rating_Share"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What series had the episode \"A love of a lifetime\"?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t0 t1",
        "score": false,
        "real_pred": "TV_series",
        "real_label": "TV_Channel TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "TV_Channel TV_series",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which series has episode A love of a lifetime?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which series has episode A love of a lifetime?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t1.c1",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select TV_series.Episode",
        "real_label": "select TV_Channel.series_name",
        "topk_preds": [
            "select TV_series.Episode",
            "select TV_series.id",
            "select TV_series.id, TV_series.Episode",
            "select TV_series.Episode, TV_series.Air_Date",
            "select TV_series.Episode, TV_Channel.series_name",
            "select TV_series.id, TV_series.Air_Date",
            "select TV_series.Episode, TV_series.Channel",
            "select TV_series.id, TV_series.18_49_Rating_Share"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which series has episode A love of a lifetime?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t0 t1",
        "score": false,
        "real_pred": "TV_series",
        "real_label": "TV_Channel TV_series",
        "topk_preds": [
            "TV_series",
            "TV_Channel TV_series",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name of the TV series that have A love of a lifetime (episode)?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name of the TV series that have A love of a lifetime (episode)?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select TV_Channel.series_name",
        "real_label": "select TV_Channel.series_name",
        "topk_preds": [
            "select TV_Channel.series_name",
            "select TV_series.Episode",
            "select TV_Channel.series_name, TV_series.Episode",
            "select TV_Channel.series_name, TV_series.Air_Date",
            "select TV_Channel.series_name, TV_series.id",
            "select TV_series.Episode, TV_Channel.series_name",
            "select TV_Channel.series_name, TV_series.Viewers_m",
            "select TV_Channel.series_name, TV_series.Channel"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name of the TV series that have A love of a lifetime (episode)?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "TV_Channel TV_series",
        "real_label": "TV_Channel TV_series",
        "topk_preds": [
            "TV_Channel TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The cartoon called \"rise of blue beetle\" show in which channel?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The cartoon called \"rise of blue beetle\" show in which channel?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t2.c6",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select Cartoon.Channel",
        "real_label": "select TV_Channel.series_name",
        "topk_preds": [
            "select Cartoon.Channel",
            "select Cartoon.Channel, Cartoon.Production_code",
            "select Cartoon.Channel, t2.c7",
            "select Cartoon.Channel, t2.c8",
            "select Cartoon.Channel, t2.c9",
            "select Cartoon.Channel, TV_Channel.series_name",
            "select Cartoon.Channel, Cartoon.id",
            "select Cartoon.Channel, Cartoon.Title0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The cartoon called \"rise of blue beetle\" show in which channel?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "Cartoon",
            "TV_Channel TV_series Cartoon",
            "TV_Channel Cartoon",
            "TV_series Cartoon",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the channel that broadcasts cartoons directed by Ben Jones and Michael Chang? And where is it from?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Michael Chang, Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-SPLIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-JUST-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the channel that broadcasts cartoons directed by Ben Jones and Michael Chang? And where is it from?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Michael Chang, Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t2.c6, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": false,
        "real_pred": "select Cartoon.Channel, TV_Channel.Country",
        "real_label": "select TV_Channel.series_name, TV_Channel.Country",
        "topk_preds": [
            "select Cartoon.Channel, TV_Channel.Country",
            "select TV_Channel.Country, TV_Channel.Language",
            "select Cartoon.Channel, Cartoon.Directed_by",
            "select TV_Channel.Country, Cartoon.Channel",
            "select TV_Channel.Country, TV_Channel.series_name",
            "select TV_Channel.Country, TV_Channel.Content",
            "select TV_Channel.series_name, TV_Channel.Country",
            "select Cartoon.Channel, TV_Channel.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the channel that broadcasts cartoons directed by Ben Jones and Michael Chang? And where is it from?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Michael Chang, Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "TV_Channel TV_series Cartoon",
            "",
            "TV_series Cartoon",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the package choice of HD-TV, and which series does it belong to., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the package choice of HD-TV, and which series does it belong to., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c1, t0.c8",
        "label": "select t0.c8, t0.c1",
        "score": false,
        "real_pred": "select TV_Channel.series_name, TV_Channel.Package_Option",
        "real_label": "select TV_Channel.Package_Option, TV_Channel.series_name",
        "topk_preds": [
            "select TV_Channel.series_name, TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, TV_Channel.series_name",
            "select TV_Channel.series_name, TV_Channel.Country",
            "select TV_Channel.id, TV_Channel.series_name",
            "select TV_Channel.series_name, TV_Channel.Hight_definition_TV",
            "select TV_Channel.series_name, TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.series_name",
            "select TV_Channel.series_name, TV_Channel.Language"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the package choice of HD-TV, and which series does it belong to., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0 t1",
        "label": "t0",
        "score": false,
        "real_pred": "TV_Channel TV_series",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel TV_series",
            "TV_Channel",
            "",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is package selection and TV station for HDTV?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is package selection and TV station for HDTV?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c8, t0.c6",
        "label": "select t0.c8, t0.c1",
        "score": false,
        "real_pred": "select TV_Channel.Package_Option, TV_Channel.Hight_definition_TV",
        "real_label": "select TV_Channel.Package_Option, TV_Channel.series_name",
        "topk_preds": [
            "select TV_Channel.Package_Option, TV_Channel.Hight_definition_TV",
            "select TV_Channel.Hight_definition_TV, TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, t0.c9",
            "select TV_Channel.Pay_per_view_PPV, TV_Channel.Hight_definition_TV",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Hight_definition_TV",
            "select t0.c9, TV_Channel.Hight_definition_TV",
            "select TV_Channel.Package_Option, TV_Channel.Pay_per_view_PPV",
            "select TV_Channel.Package_Option, TV_Channel.Pixel_aspect_ratio_PAR"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is package selection and TV station for HDTV?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "TV_Channel TV_series Cartoon",
            "TV_Channel TV_series",
            "",
            "",
            "TV_Channel Cartoon",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which countries have the most tv channels? And how many?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT--INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which countries have the most tv channels? And how many?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c2, count(*)",
        "label": "select t0.c2, count(*)",
        "score": true,
        "real_pred": "select TV_Channel.Country, count(*)",
        "real_label": "select TV_Channel.Country, count(*)",
        "topk_preds": [
            "select TV_Channel.Country, count(*)",
            "select TV_Channel.Country, count(*), TV_Channel.Language",
            "select TV_Channel.Country., count(*)",
            "select TV_Channel.series_name, count(*)",
            "select TV_Channel.Country, count(TV_Channel.id)",
            "select TV_Channel.Country, count(TV_Channel.Content)",
            "select TV_Channel.Country, count(*), TV_Channel.Language.",
            "select TV_Channel.Country, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which countries have the most tv channels? And how many?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What countries and series have TV channels that play cartoons directed by Ben Jones and cartoons directed by Michael Chang?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Michael Chang, Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT-FROM-WHERE and-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What countries and series have TV channels that play cartoons directed by Ben Jones and cartoons directed by Michael Chang?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Michael Chang, Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c2, t0.c1",
        "label": "select t0.c1, t0.c2",
        "score": false,
        "real_pred": "select TV_Channel.Country, TV_Channel.series_name",
        "real_label": "select TV_Channel.series_name, TV_Channel.Country",
        "topk_preds": [
            "select TV_Channel.Country, TV_Channel.series_name",
            "select TV_Channel.series_name, TV_Channel.Country",
            "select TV_Channel.Country., TV_Channel.series_name",
            "select TV_Channel.Country, TV_Channel.series_name",
            "select t0.c 2, TV_Channel.series_name",
            "select TV_Channel.Country-, TV_Channel.series_name",
            "select TV_Channel.Country), TV_Channel.series_name",
            "select t3.c2, TV_Channel.series_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What countries and series have TV channels that play cartoons directed by Ben Jones and cartoons directed by Michael Chang?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Michael Chang, Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "TV_Channel TV_series Cartoon",
            "",
            "TV_Channel Cartoon TV_series Cartoon",
            "",
            "",
            "",
            "TV_Channel Cartoon TV_series"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When will tv show episode \"a love of a lifetime\" be aired?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When will tv show episode \"a love of a lifetime\" be aired?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select TV_series.Air_Date",
        "real_label": "select TV_series.Air_Date",
        "topk_preds": [
            "select TV_series.Air_Date",
            "select TV_series.id, TV_series.Air_Date",
            "select avg(TV_series.Air_Date)",
            "select TV_series.Air_Date, TV_series.Rating",
            "select TV_series.Air_Date (https://TV_series.Air_Date)",
            "select TV_series.Air_Date (http://TV_series.Air_Date)",
            "select TV_series.Air_Date, TV_series.Weekly_Rank",
            "select TV_series.Air_Date, TV_series.18_49_Rating_Share"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When will tv show episode \"a love of a lifetime\" be aired?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When is TV series with episode \"A love of a lifetime\" coming out?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When is TV series with episode \"A love of a lifetime\" coming out?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select TV_series.Air_Date",
        "real_label": "select TV_series.Air_Date",
        "topk_preds": [
            "select TV_series.Air_Date",
            "select TV_series.Air_Date, TV_series.Rating",
            "select TV_series.Air_Date (https://TV_series.Air_Date)",
            "select TV_series.Air_Date, TV_series.Weekly_Rank",
            "select TV_series.Air_Date (or TV_series.Rating)",
            "select TV_series.Air_Date (http://TV_series.Air_Date)",
            "select TV_series.Air_Date, TV_series.18_49_Rating_Share",
            "select TV_series.Air_Date, TV_series.Share"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When is TV series with episode \"A love of a lifetime\" coming out?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which channel series shows the cartoon The Rise of the Blue Beetle!?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title (The Rise of the Blue Beetle!), c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which channel series shows the cartoon The Rise of the Blue Beetle!?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title (The Rise of the Blue Beetle!), c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select TV_Channel.series_name",
        "real_label": "select TV_Channel.series_name",
        "topk_preds": [
            "select TV_Channel.series_name",
            "select TV_Channel.series_name, TV_series.Channel",
            "select TV_Channel.series_name, Cartoon.Channel",
            "select Cartoon.Title, TV_Channel.series_name",
            "select TV_Channel.id, TV_Channel.series_name",
            "select TV_Channel.series_name, TV_Channel.Country",
            "select TV_Channel.series_name, TV_Channel.Package_Option",
            "select TV_Channel.series_name, TV_Channel.series_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which channel series shows the cartoon The Rise of the Blue Beetle!?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title (The Rise of the Blue Beetle!), c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0 t1 t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "TV_Channel TV_series Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel TV_series Cartoon",
            "",
            "",
            "TV_Channel Cartoon",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which TV channel is series \" A love of a lifetime\" aired on?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which TV channel is series \" A love of a lifetime\" aired on?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t1.c8",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select TV_series.Channel",
        "real_label": "select TV_Channel.series_name",
        "topk_preds": [
            "select TV_series.Channel",
            "select TV_Channel.series_name",
            "select TV_Channel.series_name, TV_series.Channel",
            "select t2.c8",
            "select TV_Channel.series_name, TV_Channel.Country",
            "select TV_Channel.Country",
            "select TV_series.Channel",
            "select TV_Channel.series_name-, TV_series.Channel"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which TV channel is series \" A love of a lifetime\" aired on?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "TV_Channel TV_series",
        "real_label": "TV_Channel TV_series",
        "topk_preds": [
            "TV_Channel TV_series",
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the packages options and series of the TV channel that supports HDTV?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-C1, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the packages options and series of the TV channel that supports HDTV?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c8, t0.c1",
        "label": "select t0.c8, t0.c1",
        "score": true,
        "real_pred": "select TV_Channel.Package_Option, TV_Channel.series_name",
        "real_label": "select TV_Channel.Package_Option, TV_Channel.series_name",
        "topk_preds": [
            "select TV_Channel.Package_Option, TV_Channel.series_name",
            "select TV_Channel.series_name, TV_Channel.Package_Option",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.series_name",
            "select TV_Channel.Pay_per_view_PPV, TV_Channel.series_name",
            "select TV_Channel.id, TV_Channel.series_name",
            "select TV_Channel.Hight_definition_TV, TV_Channel.series_name",
            "select TV_Channel.Country, TV_Channel.Package_Option",
            "select t2.c8, TV_Channel.series_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the packages options and series of the TV channel that supports HDTV?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "",
            "",
            "TV_Channel TV_series",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who has earned more than 300000 in poker?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-RELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who has earned more than 300000 in poker?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select poker_player.People_ID",
            "select people.Name, people.Nationality",
            "select people.Name, people.People_ID",
            "select people.Nationality",
            "select people.Name, poker_player.Poker_Player_ID",
            "select people.Nationality, poker_player.Poker_Player_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who has earned more than 300000 in poker?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0 t1",
        "score": false,
        "real_pred": "poker_player",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player",
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the poker players whose earnings is over 300000?., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the poker players whose earnings is over 300000?., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c0",
        "label": "select t1.c2",
        "score": false,
        "real_pred": "select poker_player.Poker_Player_ID",
        "real_label": "select people.Name",
        "topk_preds": [
            "select poker_player.Poker_Player_ID",
            "select poker_player.Poker_Player_ID, poker_player.People_ID",
            "select poker_player.People_ID",
            "select poker_player.Poker_Player_ID, poker_player.Final_Table_Made",
            "select poker_player.Poker_Player_ID, poker_player.Earnings",
            "select poker_player.Poker_Player_ID, poker_player.Best_Finish",
            "select poker_player.People_ID, poker_player.Final_Table_Made",
            "select poker_player.People_ID, poker_player.Poker_Player_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the poker players whose earnings is over 300000?., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0 t1",
        "score": false,
        "real_pred": "poker_player",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the poker players whose revenue is over 300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the poker players whose revenue is over 300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c0",
        "label": "select t1.c2",
        "score": false,
        "real_pred": "select poker_player.Poker_Player_ID",
        "real_label": "select people.Name",
        "topk_preds": [
            "select poker_player.Poker_Player_ID",
            "select poker_player.People_ID",
            "select poker_player.Poker_Player_ID, poker_player.People_ID",
            "select poker_player.Poker_Player_ID, poker_player.Earnings",
            "select poker_player.Poker_Player_ID, poker_player.Final_Table_Made",
            "select poker_player.Poker_Player_ID, poker_player.Best_Finish",
            "select poker_player.People_ID, poker_player.Final_Table_Made",
            "select poker_player.People_ID, poker_player.Poker_Player_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the poker players whose revenue is over 300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0 t1",
        "score": false,
        "real_pred": "poker_player",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who has earned more than $300000 playing poker?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who has earned more than $300000 playing poker?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select poker_player.People_ID",
            "select people.Name, people.Birth_Date",
            "select poker_player.People_ID, people.Name",
            "select people.Name, people.Nationality",
            "select people.Name, people.People_ID",
            "select people.Nationality",
            "select people.Name, poker_player.Poker_Player_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who has earned more than $300000 playing poker?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0 t1",
        "score": false,
        "real_pred": "poker_player",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "poker_player people",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What poker player earn more than 300000?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What poker player earn more than 300000?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c0",
        "label": "select t1.c2",
        "score": false,
        "real_pred": "select poker_player.Poker_Player_ID",
        "real_label": "select people.Name",
        "topk_preds": [
            "select poker_player.Poker_Player_ID",
            "select poker_player.Poker_Player_ID, poker_player.Earnings",
            "select poker_player.Poker_Player_ID, poker_player.People_ID",
            "select poker_player.Poker_Player_ID, poker_player.Poker_Player_ID",
            "select poker_player.Poker_Player_ID, poker_player.Final_Table_Made",
            "select poker_player.Poker_Player_ID, poker_player.People_ID",
            "select poker_player.Poker_Player_ID, poker_player.Best_Finish",
            "select poker_player.Poker_Player_ID, poker_player.Earnings"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What poker player earn more than 300000?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0 t1",
        "score": false,
        "real_pred": "poker_player",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List poker players whose earnings are more than 30000, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List poker players whose earnings are more than 30000, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c0",
        "label": "select t1.c2",
        "score": false,
        "real_pred": "select poker_player.Poker_Player_ID",
        "real_label": "select people.Name",
        "topk_preds": [
            "select poker_player.Poker_Player_ID",
            "select poker_player.Poker_Player_ID, poker_player.Earnings",
            "select poker_player.Poker_Player_ID, poker_player.People_ID",
            "select poker_player.Poker_Player_ID, poker_player.Final_Table_Made",
            "select poker_player.Poker_Player_ID, poker_player.Best_Finish",
            "select poker_player.Poker_Player_ID, poker_player.Poker_Player_ID",
            "select poker_player.Poker_Player_ID, t0.c7",
            "select poker_player.Poker_Player_ID, poker_player.People_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List poker players whose earnings are more than 30000, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0 t1",
        "score": false,
        "real_pred": "poker_player",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name those poker players who have made over 300000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name those poker players who have made over 300000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select poker_player.People_ID",
            "select poker_player.People_ID, people.Name",
            "select people.Name, people.Birth_Date",
            "select poker_player.Poker_Player_ID",
            "select poker_player.People_ID, poker_player.Final_Table_Made",
            "select poker_player.Poker_Player_ID, people.Name",
            "select people.Name, poker_player.Poker_Player_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name those poker players who have made over 300000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "poker_player",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which poker players have earned more than 300000?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which poker players have earned more than 300000?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c0",
        "label": "select t1.c2",
        "score": false,
        "real_pred": "select poker_player.Poker_Player_ID",
        "real_label": "select people.Name",
        "topk_preds": [
            "select poker_player.Poker_Player_ID",
            "select poker_player.Poker_Player_ID, poker_player.People_ID",
            "select poker_player.People_ID",
            "select poker_player.Poker_Player_ID, poker_player.Final_Table_Made",
            "select poker_player.Poker_Player_ID, poker_player.Earnings",
            "select poker_player.Poker_Player_ID, poker_player.People_ID",
            "select poker_player.Poker_Player_ID, poker_player.Best_Finish",
            "select poker_player.Poker_Player_ID, poker_player.Poker_Player_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which poker players have earned more than 300000?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0 t1",
        "score": false,
        "real_pred": "poker_player",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What Poker players have earned more than $300000?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What Poker players have earned more than $300000?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c0",
        "label": "select t1.c2",
        "score": false,
        "real_pred": "select poker_player.Poker_Player_ID",
        "real_label": "select people.Name",
        "topk_preds": [
            "select poker_player.Poker_Player_ID",
            "select poker_player.Poker_Player_ID, poker_player.People_ID",
            "select poker_player.Poker_Player_ID, poker_player.Earnings",
            "select poker_player.Poker_Player_ID, poker_player.Final_Table_Made",
            "select poker_player.Poker_Player_ID, poker_player.Poker_Player_ID",
            "select poker_player.Poker_Player_ID, poker_player.Best_Finish",
            "select poker_player.People_ID",
            "select poker_player.Poker_Player_ID, poker_player.People_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What Poker players have earned more than $300000?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0 t1",
        "score": false,
        "real_pred": "poker_player",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show who's nationality is not Russia., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show who's nationality is not Russia., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.People_ID",
            "select people.Name, people.Birth_Date",
            "select people.People_ID, people.Name",
            "select people.Name, people.Height",
            "select people.Name, people.Nationality",
            "select people.Nationality",
            "select people.People_ID, people.Nationality"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show who's nationality is not Russia., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show people without Russian as their nationality., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-ELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE.",
            "SELECT-FROM-ELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show people without Russian as their nationality., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c0",
        "label": "select t1.c2",
        "score": false,
        "real_pred": "select people.People_ID",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.People_ID",
            "select people.Name",
            "select people.People_ID, people.Name",
            "select people.Nationality",
            "select people.Name, people.Birth_Date",
            "select people.Name, people.Nationality",
            "select people.Name, people.Height",
            "select people.People_ID, people.Nationality"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show people without Russian as their nationality., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When was the poker player born with the lowest earnings?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When was the poker player born with the lowest earnings?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select people.Birth_Date",
        "real_label": "select people.Birth_Date",
        "topk_preds": [
            "select people.Birth_Date",
            "select people.Birth_Date, people.Height",
            "select people.People_ID, people.Birth_Date",
            "select people.Birth_Date, people.Name",
            "select people.Nationality, people.Birth_Date",
            "select people.Birth_Date (or people.Height)",
            "select people.Birth_Date, t1.c5",
            "select people.Birth_Date, t1.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When was the poker player born with the lowest earnings?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When was the low-earning poker player born?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When was the low-earning poker player born?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select people.Birth_Date",
        "real_label": "select people.Birth_Date",
        "topk_preds": [
            "select people.Birth_Date",
            "select people.Birth_Date, people.Name",
            "select people.Birth_Date, people.Height",
            "select people.Nationality, people.Birth_Date",
            "select people.Birth_Date, poker_player.Earnings",
            "select people.Birth_Date, poker_player.Money_Rank",
            "select people.Birth_Date (or people.Height)",
            "select people.Birth_Date (or people.Name)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When was the low-earning poker player born?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are the poker players?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM",
            "SELECT-FROM SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are the poker players?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select distinct t1.c2",
        "label": "select t1.c2",
        "score": false,
        "real_pred": "select distinct people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select distinct people.Name",
            "select poker_player.People_ID",
            "select people.Name",
            "select distinct people.Name, people.Birth_Date",
            "select distinct people.Name, people.Height",
            "select people.Name, people.Birth_Date",
            "select poker_player.People_ID, people.Name",
            "select distinct people.Name, people.Nationality"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are the poker players?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are poker players?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-INTERSECT-SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are poker players?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select distinct t1.c2",
        "label": "select t1.c2",
        "score": false,
        "real_pred": "select distinct people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select distinct people.Name",
            "select distinct people.Name, people.Birth_Date",
            "select people.Name",
            "select distinct people.Name, people.Height",
            "select people.Name, people.Birth_Date",
            "select distinct people.Name, poker_player.People_ID",
            "select distinct people.Name, people.Nationality",
            "select distinct people.Name, people.People_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are poker players?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "people poker_player people",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name the poker players., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name the poker players., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select poker_player.People_ID",
            "select distinct people.Name",
            "select poker_player.Final_Table_Made",
            "select poker_player.Poker_Player_ID, people.Name",
            "select poker_player.Poker_Player_ID",
            "select people.Name, poker_player.People_ID",
            "select people.Name, poker_player.Poker_Player_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name the poker players., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are non-Russian people called., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are non-Russian people called., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Nationality",
            "select people.Name, people.Birth_Date",
            "select people.Name (or people.Birth_Date)",
            "select people.Name, people.Height",
            "select people.Name,",
            "select people.Name, t1.c5",
            "select people.Name, people.Nationality3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are non-Russian people called., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are people from that is not Russia?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are people from that is not Russia?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, people.Nationality",
            "select people.Name, people.Height",
            "select people.Name, t1.c6",
            "select people.Name, t1.c5",
            "select people.People_ID, people.Name",
            "select people.Name, people.People_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are people from that is not Russia?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When was the born of the poker player with the lowest earnings?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT.",
            "SELECT-FROM-orDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When was the born of the poker player with the lowest earnings?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select people.Birth_Date",
        "real_label": "select people.Birth_Date",
        "topk_preds": [
            "select people.Birth_Date",
            "select people.Birth_Date, people.Height",
            "select people.Nationality, people.Birth_Date",
            "select people.Birth_Date, people.Name",
            "select people.People_ID, people.Birth_Date",
            "select people.Name, people.Birth_Date",
            "select people.People_ID, people.Nationality",
            "select people.Birth_Date (or people.Height)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When was the born of the poker player with the lowest earnings?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name poker players, listed from most number of final table in descending order, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name poker players, listed from most number of final table in descending order, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, poker_player.Poker_Player_ID",
            "select people.Name, poker_player.People_ID",
            "select people.Name, poker_player.Best_Finish",
            "select people.People_ID, people.Name",
            "select people.Name, poker_player.Earnings",
            "select people.Name, people.Birth_Date",
            "select people.Name, t0.c7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name poker players, listed from most number of final table in descending order, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show list of people that are not poker players., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHAT-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EMPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show list of people that are not poker players., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select distinct people.Name",
            "select people.Name, people.Birth_Date",
            "select people.People_ID, people.Name",
            "select people.Name, people.Nationality",
            "select people.Name, people.Height",
            "select people.Nationality, people.Name",
            "select distinct people.Name, people.Birth_Date"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show list of people that are not poker players., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show list of non-poker people., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show list of non-poker people., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select distinct people.Name",
            "select people.Name, people.Nationality",
            "select non-poker people.Name",
            "select people.People_ID, people.Name",
            "select distinct people.Name, people.Nationality",
            "select non-poker people.Name, people.Nationality",
            "select people.Nationality, people.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show list of non-poker people., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: list people who do not play poker., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHAT-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHICH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: list people who do not play poker., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.People_ID, people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, people.Nationality",
            "select people.Name, people.Height",
            "select people.Nationality, people.Name",
            "select distinct people.Name",
            "select people.Name, people.People_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: list people who do not play poker., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "poker_player people",
            "",
            "",
            "",
            "",
            "people poker_player people",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are not Poker players!, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-ELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM -WHERE",
            "SELECT-FROM-EMPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are not Poker players!, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select distinct people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, people.Height",
            "select distinct people.Name, people.Birth_Date",
            "select distinct people.Name, people.Height",
            "select people.People_ID",
            "select people.Name, people.People_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are not Poker players!, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "poker_player people",
            "people poker_player people",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who don't play poker?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EMPT-SELECT-FROM-WHERE",
            "SELECT-FROM-HOLD-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who don't play poker?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, people.Height",
            "select people.People_ID, people.Name",
            "select people.Name, people.People_ID",
            "select people.Name, people.Nationality",
            "select people.Name, t1.c5",
            "select people.Nationality, people.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who don't play poker?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "poker_player people",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the list of poker players ranked by earnings descending., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t0.c5)",
            "SELECT-FROM-ORDER BY t0",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY t0.c5"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the list of poker players ranked by earnings descending., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c0",
        "label": "select t1.c2",
        "score": false,
        "real_pred": "select poker_player.Poker_Player_ID",
        "real_label": "select people.Name",
        "topk_preds": [
            "select poker_player.Poker_Player_ID",
            "select poker_player.Poker_Player_ID, poker_player.Earnings",
            "select poker_player.Poker_Player_ID, poker_player.Earnings, poker_player.Money_Rank",
            "select poker_player.Poker_Player_ID, sort(poker_player.Earnings)",
            "select poker_player.Earnings",
            "select poker_player.Poker_Player_ID, poker_player.Earnings, t0.c6",
            "select poker_player.Poker_Player_ID, ordered by poker_player.Earnings",
            "select poker_player.Poker_Player_ID, poker_player.Earnings - poker_player.Money_Rank"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the list of poker players ranked by earnings descending., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0 t1",
        "score": false,
        "real_pred": "poker_player",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who does not play poker?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM",
            "SELECT-FROM-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM- EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who does not play poker?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, people.Height",
            "select people.People_ID, people.Name",
            "select people.Name, people.People_ID",
            "select people.Name, people.Nationality",
            "select people.People_ID",
            "select people.Name, t1.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who does not play poker?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "poker_player people",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name all the poker players, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-INTERSECT-SELECT-FROM",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name all the poker players, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select distinct people.Name",
            "select people.Name, poker_player.People_ID",
            "select poker_player.Poker_Player_ID, people.Name",
            "select people.Name, poker_player.Poker_Player_ID",
            "select distinct people.Name, poker_player.People_ID",
            "select poker_player.People_ID",
            "select people.People_ID, people.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name all the poker players, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me list of people playing poker., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me list of people playing poker., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select distinct t0.c1",
        "label": "select t1.c2",
        "score": false,
        "real_pred": "select distinct poker_player.People_ID",
        "real_label": "select people.Name",
        "topk_preds": [
            "select distinct poker_player.People_ID",
            "select poker_player.People_ID",
            "select distinct poker_player.People_ID, people.Name",
            "select distinct people.Name",
            "select unique poker_player.People_ID",
            "select poker_player.Poker_Player_ID, people.Name",
            "select poker_player.People_ID, people.Name",
            "select distinct people.Name, people.Birth_Date"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me list of people playing poker., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the list of all the Poker players., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE",
            "SELECT-FROM SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the list of all the Poker players., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c1",
        "label": "select t1.c2",
        "score": false,
        "real_pred": "select poker_player.People_ID",
        "real_label": "select people.Name",
        "topk_preds": [
            "select poker_player.People_ID",
            "select distinct poker_player.People_ID",
            "select poker_player.Poker_Player_ID",
            "select distinct poker_player.Poker_Player_ID",
            "select poker_player.Poker_Player_ID, people.Name",
            "select distinct poker_player.People_ID, people.Name",
            "select poker_player.People_ID, people.Name",
            "select distinct people.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the list of all the Poker players., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0 t1",
        "score": false,
        "real_pred": "poker_player",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player",
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show list of poker players, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show list of poker players, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c1",
        "label": "select t1.c2",
        "score": false,
        "real_pred": "select poker_player.People_ID",
        "real_label": "select people.Name",
        "topk_preds": [
            "select poker_player.People_ID",
            "select poker_player.Poker_Player_ID",
            "select poker_player.Poker_Player_ID, poker_player.People_ID",
            "select poker_player.Poker_Player_ID, people.Name",
            "select distinct poker_player.People_ID",
            "select poker_player.People_ID, people.Name",
            "select poker_player.Poker_Player_ID, people.Height",
            "select poker_player.Poker_Player_ID, t2.c1"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show list of poker players, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0 t1",
        "score": false,
        "real_pred": "poker_player",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player",
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: list poker players that made final tables ranked from least to most., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY SELECT-FROM-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: list poker players that made final tables ranked from least to most., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c0",
        "label": "select t1.c2",
        "score": false,
        "real_pred": "select poker_player.Poker_Player_ID",
        "real_label": "select people.Name",
        "topk_preds": [
            "select poker_player.Poker_Player_ID",
            "select poker_player.Poker_Player_ID, poker_player.Final_Table_Made",
            "select poker_player.Poker_Player_ID, poker_player.Final_Table_Made, poker_player.Money_Rank",
            "select poker_player.Poker_Player_ID, poker_player.Final_Table_Made, poker_player.Best_Finish",
            "select poker_player.Poker_Player_ID, poker_player.Final_Table_Made, poker_player.Money_Rank",
            "select poker_player.Final_Table_Made",
            "select poker_player.Poker_Player_ID, poker_player.Final_Table_Made, poker_player.Best_Finish",
            "select poker_player.Poker_Player_ID, poker_player.Final_Table_Made - poker_player.Best_Finish"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: list poker players that made final tables ranked from least to most., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0 t1",
        "score": false,
        "real_pred": "poker_player",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show lists of poker players ranked according to the final table made in order, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show lists of poker players ranked according to the final table made in order, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c0, t0.c2",
        "label": "select t1.c2",
        "score": false,
        "real_pred": "select poker_player.Poker_Player_ID, poker_player.Final_Table_Made",
        "real_label": "select people.Name",
        "topk_preds": [
            "select poker_player.Poker_Player_ID, poker_player.Final_Table_Made",
            "select poker_player.Final_Table_Made",
            "select poker_player.People_ID, poker_player.Final_Table_Made",
            "select poker_player.Poker_Player_ID",
            "select poker_player.Poker_Player_ID, poker_player.Final_Table_Made, poker_player.Money_Rank",
            "select poker_player.Final_Table_Made, poker_player.Money_Rank",
            "select poker_player.Money_Rank",
            "select poker_player.Poker_Player_ID, poker_player.Final_Table_Made, poker_player.Money_Rank"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show lists of poker players ranked according to the final table made in order, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0 t1",
        "score": false,
        "real_pred": "poker_player",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which contestants do not have the name \"Jessie Alloway\"?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name (Jessie Alloway)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-A-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which contestants do not have the name \"Jessie Alloway\"?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name (Jessie Alloway)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select t1.c0",
        "label": "select t1.c1",
        "score": false,
        "real_pred": "select CONTESTANTS.contestant_number",
        "real_label": "select CONTESTANTS.contestant_name",
        "topk_preds": [
            "select CONTESTANTS.contestant_number",
            "select CONTESTANTS.contestant_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name",
            "select t1.c2",
            "select CONTESTANTS.contestant_number (CONTESTANTS.contestant_name)",
            "select CONTESTANTS.contestant_number, t1.c2",
            "select CONTESTANTS.contestant_number (no-execution)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which contestants do not have the name \"Jessie Alloway\"?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name (Jessie Alloway)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "CONTESTANTS",
        "real_label": "CONTESTANTS",
        "topk_preds": [
            "CONTESTANTS",
            "",
            "",
            "",
            "",
            "",
            "",
            "CONTESTANTS VOTES"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the contestants whose names are not 'Jessie Alloway'., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name (Jessie Alloway)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ANY-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the contestants whose names are not 'Jessie Alloway'., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name (Jessie Alloway)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select CONTESTANTS.contestant_name",
        "real_label": "select CONTESTANTS.contestant_name",
        "topk_preds": [
            "select CONTESTANTS.contestant_name",
            "select CONTESTANTS.contestant_number",
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name",
            "select distinct CONTESTANTS.contestant_name",
            "select CONTESTANTS.contestant_name, CONTESTANTS.contestant_number",
            "select CONTESTANTS.contestant_name, t1.c2",
            "select CONTESTANTS.contestant_name, t1.c3",
            "select the CONTESTANTS.contestant_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the contestants whose names are not 'Jessie Alloway'., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name (Jessie Alloway)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "CONTESTANTS",
        "real_label": "CONTESTANTS",
        "topk_preds": [
            "CONTESTANTS",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which contestants don't have the name Jessie Alloway, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name (Jessie Alloway)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-A-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which contestants don't have the name Jessie Alloway, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name (Jessie Alloway)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select t1.c0",
        "label": "select t1.c1",
        "score": false,
        "real_pred": "select CONTESTANTS.contestant_number",
        "real_label": "select CONTESTANTS.contestant_name",
        "topk_preds": [
            "select CONTESTANTS.contestant_number",
            "select CONTESTANTS.contestant_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name",
            "select t1.c2",
            "select t1.c3",
            "select t1.c4",
            "select CONTESTANTS.contestant_number (CONTESTANTS.contestant_name)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which contestants don't have the name Jessie Alloway, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name (Jessie Alloway)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "CONTESTANTS",
        "real_label": "CONTESTANTS",
        "topk_preds": [
            "CONTESTANTS",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are contestants whose names are not 'Jessie Alloway'?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name (Jessie Alloway)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are contestants whose names are not 'Jessie Alloway'?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name (Jessie Alloway)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select CONTESTANTS.contestant_name",
        "real_label": "select CONTESTANTS.contestant_name",
        "topk_preds": [
            "select CONTESTANTS.contestant_name",
            "select CONTESTANTS.contestant_number",
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name",
            "select distinct CONTESTANTS.contestant_name",
            "select CONTESTANTS.contestant_name, CONTESTANTS.contestant_number",
            "select CONTESTANTS.contestant_name, t1.c2",
            "select CONTESTANTS.contestant_name, t1.c3",
            "select CONTESTANTS.contestant_number, t1.c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are contestants whose names are not 'Jessie Alloway'?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name (Jessie Alloway)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "CONTESTANTS",
        "real_label": "CONTESTANTS",
        "topk_preds": [
            "CONTESTANTS",
            "",
            "",
            "",
            "CONTESTANTS VOTES",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return contestants names containing Al, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state (AL)). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)",
            "SELECT-FROM-WITH-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return contestants names containing Al, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state (AL)). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select CONTESTANTS.contestant_name",
        "real_label": "select CONTESTANTS.contestant_name",
        "topk_preds": [
            "select CONTESTANTS.contestant_name",
            "select CONTESTANTS.contestant_name, AREA_CODE_STATE.state",
            "select CONTESTANTS.contestant_name, t1.c2",
            "select CONTESTANTS.contestant_name, t0.c2",
            "select CONTESTANTS.contestant_name - AREA_CODE_STATE.state",
            "select distinct CONTESTANTS.contestant_name",
            "select Al, CONTESTANTS.contestant_name",
            "select CONTESTANTS.contestant_name, AREA_CODE_STATE.area_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return contestants names containing Al, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state (AL)). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t0 t1",
        "label": "t1",
        "score": false,
        "real_pred": "AREA_CODE_STATE CONTESTANTS",
        "real_label": "CONTESTANTS",
        "topk_preds": [
            "AREA_CODE_STATE CONTESTANTS",
            "",
            "",
            "AREA_CODE_STATE CONTESTANTS VOTES",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are the 5 largest countries and their sizes?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are the 5 largest countries and their sizes?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, t2.c4",
        "label": "select t2.c1, t2.c4",
        "score": true,
        "real_pred": "select country.Name, country.SurfaceArea",
        "real_label": "select country.Name, country.SurfaceArea",
        "topk_preds": [
            "select country.Name, country.SurfaceArea",
            "select country.Code, country.Name, country.SurfaceArea",
            "select country.Name, country.SurfaceArea, country.Population",
            "select country.Name, country.Region",
            "select country.Name, country.SurfaceArea, country.IndepYear",
            "select country.Code, country.Name, max(country.SurfaceArea)",
            "select country.Name, country.Continent",
            "select country.Name, country.SurfaceArea,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are the 5 largest countries and their sizes?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name countries speak both english and french?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-SWITCH-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-FLOSS-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name countries speak both english and french?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.Language",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, country.Code",
            "select countrylanguage.Language, country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Region",
            "select countrylanguage.CountryCode, countrylanguage.Language"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name countries speak both english and french?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "city country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What countries are there that speak both English and French?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE (GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROMWHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHITE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What countries are there that speak both English and French?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, country.Code",
            "select countrylanguage.Language, country.Name",
            "select country.Name, country.Continent",
            "select countrylanguage.CountryCode",
            "select country.Name, countrylanguage.Language",
            "select country.Name, country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What countries are there that speak both English and French?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t2 t3",
        "score": false,
        "real_pred": "countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "countrylanguage country countrylanguage",
            "city countrylanguage"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What countries have English and French as their languages?., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-COLOR-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-COMBINAT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-2-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What countries have English and French as their languages?., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, country.Continent",
            "select country.Name, country.Code",
            "select country.Name, country.Region",
            "select countrylanguage.CountryCode",
            "select country.Name, country.Name",
            "select country.Name, countrylanguage.Language"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What countries have English and French as their languages?., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name nations speaking both English and French., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-2-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROMWHERE",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name nations speaking both English and French., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.Language",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, country.Code",
            "select country.Name, country.Capital",
            "select country.Name, country.Continent",
            "select country.Name, country.Region",
            "select country.Name, country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name nations speaking both English and French., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name Nations that speak both English and French., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROMWHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE (GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHITE",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name Nations that speak both English and French., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.Language",
            "select country.Name, countrylanguage.CountryCode",
            "select countrylanguage.Language, country.Name",
            "select country.Name, country.Code",
            "select country.Name, country.Capital",
            "select country.Name, country.Continent",
            "select country.Name, country.Region"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name Nations that speak both English and French., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "",
            "",
            "sqlite_sequence countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How long do people live in countries where English is not the official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-INSERT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How long do people live in countries where English is not the official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c7",
        "label": "select avg(t2.c7)",
        "score": false,
        "real_pred": "select country.LifeExpectancy",
        "real_label": "select avg(country.LifeExpectancy)",
        "topk_preds": [
            "select country.LifeExpectancy",
            "select country.Code, country.LifeExpectancy",
            "select max(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy)",
            "select country.LifeExpectancy, countrylanguage.Language",
            "select country.Code, max(country.LifeExpectancy)",
            "select country.LifeExpectancy, countrylanguage.IsOfficial",
            "select country.LifeExpectancy, country.Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How long do people live in countries where English is not the official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence countrylanguage",
            "country",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How long do people live in countries where English isn't the official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-INSERT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How long do people live in countries where English isn't the official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c7",
        "label": "select avg(t2.c7)",
        "score": false,
        "real_pred": "select country.LifeExpectancy",
        "real_label": "select avg(country.LifeExpectancy)",
        "topk_preds": [
            "select country.LifeExpectancy",
            "select country.Code, country.LifeExpectancy",
            "select max(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy)",
            "select country.LifeExpectancy, countrylanguage.Language",
            "select country.Code, max(country.LifeExpectancy)",
            "select country.LifeExpectancy, countrylanguage.IsOfficial",
            "select country.LifeExpectancy, country.Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How long do people live in countries where English isn't the official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence countrylanguage",
            "",
            "",
            "country",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How long do people live in the countries where English isn't the official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-INSERT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How long do people live in the countries where English isn't the official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c7",
        "label": "select avg(t2.c7)",
        "score": false,
        "real_pred": "select country.LifeExpectancy",
        "real_label": "select avg(country.LifeExpectancy)",
        "topk_preds": [
            "select country.LifeExpectancy",
            "select max(country.LifeExpectancy)",
            "select country.Code, country.LifeExpectancy",
            "select avg(country.LifeExpectancy)",
            "select country.Code, max(country.LifeExpectancy)",
            "select country.LifeExpectancy, countrylanguage.Language",
            "select country.LifeExpectancy, countrylanguage.IsOfficial",
            "select country.LifeExpectancy, countrylanguage.CountryCode"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How long do people live in the countries where English isn't the official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "sqlite_sequence countrylanguage",
            "country",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the three most populous countries?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the three most populous countries?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Code",
            "select country.Name, country.Capital",
            "select country.Name, country.Population",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Region",
            "select country.Code, country.Name",
            "select country.Name, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the three most populous countries?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What nations are the three most populous, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What nations are the three most populous, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.HeadOfState",
            "select country.Code, country.Name",
            "select country.Name, country.Code",
            "select country.Name, country.Population",
            "select country.Name, country.Code2",
            "select country.Name, country.LocalName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What nations are the three most populous, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the 3 most populous countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the 3 most populous countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.Population",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Code",
            "select country.Code, country.Name",
            "select country.Name, country.Region",
            "select country.Name, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the 3 most populous countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Tell us how long is a persons life on avergae if they live in a country where English is not the official language,, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2 (US)). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE -GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Tell us how long is a persons life on avergae if they live in a country where English is not the official language,, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2 (US)). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c7)",
        "label": "select avg(t2.c7)",
        "score": true,
        "real_pred": "select avg(country.LifeExpectancy)",
        "real_label": "select avg(country.LifeExpectancy)",
        "topk_preds": [
            "select avg(country.LifeExpectancy)",
            "select avergae(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), countrylanguage.Language",
            "select avg(country.LifeExpectancy), country.Code",
            "select avg(country.LifeExpectancy), country.Population",
            "select an avg(country.LifeExpectancy)",
            "select lifeexpectancy(country.LifeExpectancy)",
            "select avge(country.LifeExpectancy)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Tell us how long is a persons life on avergae if they live in a country where English is not the official language,, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2 (US)). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "sqlite_sequence countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How long do people live in countries where English is not their official tongue?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How long do people live in countries where English is not their official tongue?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c7",
        "label": "select avg(t2.c7)",
        "score": false,
        "real_pred": "select country.LifeExpectancy",
        "real_label": "select avg(country.LifeExpectancy)",
        "topk_preds": [
            "select country.LifeExpectancy",
            "select country.Code, country.LifeExpectancy",
            "select max(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy)",
            "select country.Code, max(country.LifeExpectancy)",
            "select country.LifeExpectancy, countrylanguage.Language",
            "select country.LifeExpectancy, countrylanguage.IsOfficial",
            "select country.Code, country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How long do people live in countries where English is not their official tongue?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "sqlite_sequence countrylanguage",
            "",
            "",
            "country",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How long do people live in those places that English isn't the official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How long do people live in those places that English isn't the official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c7",
        "label": "select avg(t2.c7)",
        "score": false,
        "real_pred": "select country.LifeExpectancy",
        "real_label": "select avg(country.LifeExpectancy)",
        "topk_preds": [
            "select country.LifeExpectancy",
            "select country.Code, country.LifeExpectancy",
            "select max(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy)",
            "select country.Code, max(country.LifeExpectancy)",
            "select country.Code, country.Name",
            "select country.Code, sum(country.LifeExpectancy)",
            "select country.Code, country.IndepYear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How long do people live in those places that English isn't the official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "sqlite_sequence countrylanguage",
            "",
            "",
            "country"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name of the country that has the largest area? Population and head of state?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name of the country that has the largest area? Population and head of state?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, t2.c6, t2.c12",
        "label": "select t2.c1, t2.c6, t2.c12",
        "score": true,
        "real_pred": "select country.Name, country.Population, country.HeadOfState",
        "real_label": "select country.Name, country.Population, country.HeadOfState",
        "topk_preds": [
            "select country.Name, country.Population, country.HeadOfState",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Code6, country.HeadOfState",
            "select country.Name, country.IndepYear, country.HeadOfState",
            "select country.Name, country.GNP, country.HeadOfState",
            "select country.Name, country.GovernmentForm, country.HeadOfState",
            "select country.Name, country.Population, country.HeadOfState",
            "select country.Name, country.Continent, country.HeadOfState"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name of the country that has the largest area? Population and head of state?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Tell me the country with the lowest life expectancy in Asia., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Tell me the country with the lowest life expectancy in Asia., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Code",
            "select country.Name, country.LifeExpectancy",
            "select country.Name, country.Population",
            "select country.Name, country.Region",
            "select country.Code, country.Name",
            "select country.Name, country.LocalName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Tell me the country with the lowest life expectancy in Asia., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which country in Asia has the lowest life expectancy?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which country in Asia has the lowest life expectancy?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Name, country.Region",
            "select country.Name, country.LifeExpectancy",
            "select country.Code, country.Name",
            "select country.Name, country.Code",
            "select country.Name, country.Capital"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which country in Asia has the lowest life expectancy?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name the country in Asia with the lowest life expectancy., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name the country in Asia with the lowest life expectancy., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Name, country.Region",
            "select country.Name, country.LifeExpectancy",
            "select country.Code, country.Name",
            "select country.Name, country.Code",
            "select country.Name, country.IndepYear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name the country in Asia with the lowest life expectancy., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which country in asia has the lowest life expectancy?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which country in asia has the lowest life expectancy?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Code, country.Name",
            "select country.Name, country.Region",
            "select country.Name, country.LifeExpectancy",
            "select country.Name, country.Code",
            "select country.Name, country.IndepYear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which country in asia has the lowest life expectancy?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Tell the country in asia with the lowest life expectancy., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Tell the country in asia with the lowest life expectancy., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Code, country.Name",
            "select country.Name, country.Region",
            "select country.Name, country.LifeExpectancy",
            "select country.Name, country.Code",
            "select country.Name, country.IndepYear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Tell the country in asia with the lowest life expectancy., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which country has most language spoken?., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which country has most language spoken?., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, country.Capital",
            "select country.Name, country.Code",
            "select country.Name, country.Continent",
            "select country.Name, country.Code2",
            "select country.Name, countrylanguage.Language",
            "select country.Code, country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which country has most language spoken?., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which country speaks the most number of different language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which country speaks the most number of different language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, countrylanguage.Language",
            "select country.Name, country.Capital",
            "select country.Name, country.Continent",
            "select country.Name, country.Code",
            "select country.Name, country.Code2",
            "select country.Name, countrylanguage.IsOfficial"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which country speaks the most number of different language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            "city country countrylanguage",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What country has the largest number of languages as spoken?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What country has the largest number of languages as spoken?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, countrylanguage.Language",
            "select country.Name, country.Capital",
            "select country.Name, country.Continent",
            "select country.Name, country.Code",
            "select country.Name, country.Code2",
            "select country.Name, countrylanguage.IsOfficial"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What country has the largest number of languages as spoken?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name of country which speaks the most languages., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name of country which speaks the most languages., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, countrylanguage.Language",
            "select country.Name, country.Capital",
            "select country.Name, country.Code",
            "select country.Name, countrylanguage.IsOfficial",
            "select country.Name, country.Code2",
            "select country.Name (country.Code)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name of country which speaks the most languages., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which is the country that speaks the most langauges?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which is the country that speaks the most langauges?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, countrylanguage.Language",
            "select country.Name, country.Capital",
            "select country.Name, country.Continent",
            "select country.Name, country.Code",
            "select country.Name, countrylanguage.IsOfficial",
            "select country.Name, country.Code2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which is the country that speaks the most langauges?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "",
            "sqlite_sequence country countrylanguage",
            "",
            "city country countrylanguage",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which country has the most languages?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which country has the most languages?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, country.Capital",
            "select country.Name, country.Code",
            "select country.Name, countrylanguage.Language",
            "select country.Name, country.Code2",
            "select country.Name, country.Continent",
            "select country.Name, country.HeadOfState"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which country has the most languages?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "sqlite_sequence country countrylanguage",
            "",
            "city country countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The countries which became independent since 1950., database: Database: world_1. t0: city(c0: id, c1: name (Independence), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The countries which became independent since 1950., database: Database: world_1. t0: city(c0: id, c1: name (Independence), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select distinct country.Name",
            "select country.Name, country.Code",
            "select distinct country.Name, country.Code",
            "select country.Code, country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.Continent",
            "select country.Name, country.Region"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The countries which became independent since 1950., database: Database: world_1. t0: city(c0: id, c1: name (Independence), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name all countries which got independence after 1950., database: Database: world_1. t0: city(c0: id, c1: name (Independence), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name all countries which got independence after 1950., database: Database: world_1. t0: city(c0: id, c1: name (Independence), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select distinct country.Name",
            "select country.Name, country.Code",
            "select country.Name, country.Capital",
            "select country.Name, country.Region",
            "select country.Name, country.LocalName",
            "select country.Name, country.Continent",
            "select country.Name, country.Population"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name all countries which got independence after 1950., database: Database: world_1. t0: city(c0: id, c1: name (Independence), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name all countries that became independent after 1950., database: Database: world_1. t0: city(c0: id, c1: name (Independence), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name all countries that became independent after 1950., database: Database: world_1. t0: city(c0: id, c1: name (Independence), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select distinct country.Name",
            "select country.Name, country.Code",
            "select country.Name, country.Capital",
            "select country.Name, country.LocalName",
            "select country.Name, country.Region",
            "select country.Name, country.Continent",
            "select country.Name, country.Population"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name all countries that became independent after 1950., database: Database: world_1. t0: city(c0: id, c1: name (Independence), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the European cities that English is not their official language?., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE.EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2014EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the European cities that English is not their official language?., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select distinct t0.c1",
        "score": false,
        "real_pred": "select city.Name",
        "real_label": "select distinct city.Name",
        "topk_preds": [
            "select city.Name",
            "select distinct city.Name",
            "select city.ID, city.Name",
            "select city.Name, country.Continent",
            "select city.Name, country.Capital",
            "select distinct city.Name, country.Capital",
            "select city.Name, countrylanguage.CountryCode",
            "select distinct city.Name, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the European cities that English is not their official language?., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t0 t2 t3",
        "label": "t0 t2 t3",
        "score": true,
        "real_pred": "city country countrylanguage",
        "real_label": "city country countrylanguage",
        "topk_preds": [
            "city country countrylanguage",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which European cities do not speak English as their official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which European cities do not speak English as their official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select distinct t0.c1",
        "score": false,
        "real_pred": "select city.Name",
        "real_label": "select distinct city.Name",
        "topk_preds": [
            "select city.Name",
            "select distinct city.Name",
            "select city.ID, city.Name",
            "select city.Name, country.Continent",
            "select city.Name, country.Capital",
            "select city.Name, countrylanguage.Language",
            "select city.Name, countrylanguage.CountryCode",
            "select city.ID, country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which European cities do not speak English as their official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t0 t2 t3",
        "label": "t0 t2 t3",
        "score": true,
        "real_pred": "city country countrylanguage",
        "real_label": "city country countrylanguage",
        "topk_preds": [
            "city country countrylanguage",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the 3 countries with fewest people?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the 3 countries with fewest people?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Code",
            "select country.Name, country.Population",
            "select country.Code, country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Region",
            "select country.Name, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the 3 countries with fewest people?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the 3 countries with the least number of people., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the 3 countries with the least number of people., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Code",
            "select country.Name, country.Population",
            "select country.Code, country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Region",
            "select country.Name, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the 3 countries with the least number of people., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which 3 countries have the fewest people?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-THREE-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which 3 countries have the fewest people?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Code",
            "select country.Name, country.Population",
            "select country.Name, country.Capital",
            "select country.Code, country.Name",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Region",
            "select country.Name, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which 3 countries have the fewest people?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the three biggest countries in terms of population?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the three biggest countries in terms of population?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Population",
            "select country.Name, country.Code",
            "select country.Code, country.Name",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Capital",
            "select country.Name, country.Region",
            "select country.Name, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the three biggest countries in terms of population?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name the 3 largest country populations., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name the 3 largest country populations., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Population",
            "select country.Name, country.Code",
            "select country.Code, country.Name",
            "select country.Name, country.Region",
            "select country.Name, country.Code6",
            "select country.Name, country.Capital",
            "select country.Name, country.HeadOfState"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name the 3 largest country populations., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name the 3 biggest countries in population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name the 3 biggest countries in population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Code",
            "select country.Name, country.Population",
            "select country.Name, country.Capital",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Region",
            "select country.Name, country.Continent",
            "select country.Name, country.LocalName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name the 3 biggest countries in population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the three biggest countries in population?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the three biggest countries in population?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Code",
            "select country.Name, country.Population",
            "select country.Code, country.Name",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Capital",
            "select country.Name, country.Region",
            "select country.Name, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the three biggest countries in population?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which country uses the largest number of languages?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which country uses the largest number of languages?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, countrylanguage.Language",
            "select country.Name, country.Capital",
            "select country.Name, country.Continent",
            "select country.Name, country.Code2",
            "select country.Name, countrylanguage.IsOfficial",
            "select country.Name, country.Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which country uses the largest number of languages?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which nation use the most languages, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-MORE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which nation use the most languages, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, country.Capital",
            "select country.Name, countrylanguage.Language",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Code2",
            "select country.Name, country.Code",
            "select country.Code, country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which nation use the most languages, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "",
            "",
            "",
            "sqlite_sequence countrylanguage",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which nation uses the most languages, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GEOGRAPHY-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which nation uses the most languages, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, country.Capital",
            "select country.Name, countrylanguage.Language",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Code",
            "select country.Name, country.Code2",
            "select country.Code, country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which nation uses the most languages, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "",
            "",
            "",
            "sqlite_sequence countrylanguage",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List countries that speak more than two languages,and how many languages do they speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List countries that speak more than two languages,and how many languages do they speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, count(distinct t3.c1)",
        "label": "select count(t3.c1), t2.c1",
        "score": false,
        "real_pred": "select country.Name, count(distinct countrylanguage.Language)",
        "real_label": "select count(countrylanguage.Language), country.Name",
        "topk_preds": [
            "select country.Name, count(distinct countrylanguage.Language)",
            "select country.Name, count(countrylanguage.Language)",
            "select country.Name, country.Name, count(distinct countrylanguage.Language)",
            "select country.Name, count(distinct country.Name)",
            "select country.Code, count(distinct countrylanguage.Language)",
            "select country.Name, count(*)",
            "select country.Name, count(count(distinct countrylanguage.Language)",
            "select country.Name, count(distinct countrylanguage.IsOfficial)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List countries that speak more than two languages,and how many languages do they speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            "",
            "city country countrylanguage",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What country speak more than two languages? And what languages do they speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What country speak more than two languages? And what languages do they speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, t3.c1",
        "label": "select count(t3.c1), t2.c1",
        "score": false,
        "real_pred": "select country.Name, countrylanguage.Language",
        "real_label": "select count(countrylanguage.Language), country.Name",
        "topk_preds": [
            "select country.Name, countrylanguage.Language",
            "select country.Name, country.Name",
            "select countrylanguage.Language, country.Name",
            "select country.Name.c1, countrylanguage.CountryCode",
            "select country.Code, countrylanguage.Language",
            "select country.Name, countrylanguage.Language",
            "select sqlite_sequence.seq, countrylanguage.Language",
            "select country.Name.c1, countrylanguage.Language"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What country speak more than two languages? And what languages do they speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "city country countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: To which countries do language is spoken more than two, plus how many do each of them speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM per-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: To which countries do language is spoken more than two, plus how many do each of them speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, count(*)",
        "label": "select count(t3.c1), t2.c1",
        "score": false,
        "real_pred": "select country.Name, count(*)",
        "real_label": "select count(countrylanguage.Language), country.Name",
        "topk_preds": [
            "select country.Name, count(*)",
            "select country.Name, countrylanguage.Language",
            "select country.Name, countrylanguage.CountryCode, count(*)",
            "select countrylanguage.Language, count(*)",
            "select country.Name, countrylanguage.Language, countrylanguage.Percentage",
            "select country.Name, countrylanguage.Language, country.Region",
            "select country.Name, count(countrylanguage.Language)",
            "select country.Name, countrylanguage.Language, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: To which countries do language is spoken more than two, plus how many do each of them speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence countrylanguage",
            "",
            "countrylanguage",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What nations have official language of both French and English?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-FLOSS-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROMWHERE",
            "SELECT-FROM-SWITCH-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What nations have official language of both French and English?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, country.Code",
            "select country.Name, country.Continent",
            "select country.Name, country.Region",
            "select country.Name, country.Capital",
            "select country.Name, country.Name",
            "select country.Name, countrylanguage.Language"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What nations have official language of both French and English?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "countrylanguage",
            "sqlite_sequence country countrylanguage",
            "sqlite_sequence countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which nations have both English and French as official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE (GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROMWHERE",
            "SELECT-FROM BOTH-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which nations have both English and French as official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, country.Continent",
            "select country.Name, country.Code",
            "select country.Name, country.Region",
            "select country.Name, country.Capital",
            "select country.Name, country.Name",
            "select country.Name, country.Code2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which nations have both English and French as official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "sqlite_sequence countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: list all the cities with population in between160000 and 900000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: list all the cities with population in between160000 and 900000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select city.Name",
        "real_label": "select city.Name",
        "topk_preds": [
            "select city.Name",
            "select city.ID, city.Name",
            "select city.Name, city.District",
            "select city.Name, city.CountryCode",
            "select city.Name, city.ID",
            "select city.Name, city.Population",
            "select city.Name, t0.c6",
            "select city.Name, t0.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: list all the cities with population in between160000 and 900000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "city",
        "real_label": "city",
        "topk_preds": [
            "city",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which country, in Europe has a population of 80000?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which country, in Europe has a population of 80000?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Code, country.Name",
            "select country.Name, country.Continent, country.Population",
            "select country.Name, country.Continent, country.Region",
            "select country.Code, country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Name, country.Continent, min(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which country, in Europe has a population of 80000?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which european countries contain populations of 80000?., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INSERT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which european countries contain populations of 80000?., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Code, country.Name",
            "select distinct country.Name",
            "select european country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select distinct country.Name, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which european countries contain populations of 80000?., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Tell me all countries that are in Europe and have a population equal to 8000, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Tell me all countries that are in Europe and have a population equal to 8000, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Code, country.Name",
            "select country.Name, country.Region",
            "select country.Name (country.Code)",
            "select country.Name, country.SurfaceArea",
            "select country.Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Tell me all countries that are in Europe and have a population equal to 8000, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "city country",
            "sqlite_sequence country",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: list the different cities in Asia that are in Chinese and which the language is official., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Chinese), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: list the different cities in Asia that are in Chinese and which the language is official., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Chinese), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select distinct t0.c1",
        "label": "select distinct t0.c1",
        "score": true,
        "real_pred": "select distinct city.Name",
        "real_label": "select distinct city.Name",
        "topk_preds": [
            "select distinct city.Name",
            "select distinct city.Name, countrylanguage.Language",
            "select distinct city.Name, countrylanguage.IsOfficial",
            "select distinct city.ID, city.Name",
            "select distinct city.Name, countrylanguage.CountryCode",
            "select distinct city.Name, country.Capital",
            "select city.Name",
            "select distinct city.Name, city.CountryCode"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: list the different cities in Asia that are in Chinese and which the language is official., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Chinese), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t0 t2 t3",
        "label": "t0 t2 t3",
        "score": true,
        "real_pred": "city country countrylanguage",
        "real_label": "city country countrylanguage",
        "topk_preds": [
            "city country countrylanguage",
            "",
            "city sqlite_sequence country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: list the cities in Asia that use chinese as official language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Chinese), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: list the cities in Asia that use chinese as official language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Chinese), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select distinct t0.c1",
        "score": false,
        "real_pred": "select city.Name",
        "real_label": "select distinct city.Name",
        "topk_preds": [
            "select city.Name",
            "select city.ID, city.Name",
            "select city.Name, country.Capital",
            "select city.Name, city.CountryCode",
            "select city.Name, country.Continent",
            "select city.Name, country.Name",
            "select city.Name, country.Code2",
            "select city.Name, country.Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: list the cities in Asia that use chinese as official language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Chinese), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t0 t2 t3",
        "label": "t0 t2 t3",
        "score": true,
        "real_pred": "city country countrylanguage",
        "real_label": "city country countrylanguage",
        "topk_preds": [
            "city country countrylanguage",
            "",
            "city sqlite_sequence country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which countries are in the continent of Europe and have a population of 8000, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which countries are in the continent of Europe and have a population of 8000, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Code, country.Name",
            "select country.Name, country.Region",
            "select country.Name (country.Code)",
            "select country.Name, country.Code",
            "select country.Name, country.SurfaceArea"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which countries are in the continent of Europe and have a population of 8000, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "city country",
            "",
            "",
            "sqlite_sequence country",
            "",
            "city sqlite_sequence country",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name the countries in Europe with a population of 80000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INSERT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name the countries in Europe with a population of 80000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Continent, country.Region",
            "select country.Code, country.Name",
            "select country.Name, country.Continent, country.Population",
            "select country.Name, country.Population",
            "select country.Name, country.Continent, min(country.Population)",
            "select country.Name, country.Continent, country.Region"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name the countries in Europe with a population of 80000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which countries are in the continent of Europe with a population of 8000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INSERT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which countries are in the continent of Europe with a population of 8000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Code, country.Name",
            "select country.Name, country.Population",
            "select country.Name, country.Region",
            "select country.Name (country.Code)",
            "select country.Name, country.Code",
            "select country.Name, country.IndepYear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which countries are in the continent of Europe with a population of 8000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "city country",
            "sqlite_sequence country",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name the countries in the continental continent of Europe which have a population of 80000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name the countries in the continental continent of Europe which have a population of 80000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Code, country.Name",
            "select country.Name, country.Population",
            "select country.Name, country.Region",
            "select country.Name (country.Code)",
            "select country.Name, country.SurfaceArea",
            "select country.Name, country.Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name the countries in the continental continent of Europe which have a population of 80000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which country has the lowest lifespan in Asia?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which country has the lowest lifespan in Asia?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Code",
            "select country.Name, country.Continent",
            "select country.Code, country.Name",
            "select country.Name, country.LifeExpectancy",
            "select country.Name, country.Population",
            "select country.Name, country.Region",
            "select country.Name, country.Capital"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which country has the lowest lifespan in Asia?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which country in Asia has the least life expectancy?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which country in Asia has the least life expectancy?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Name, country.LifeExpectancy",
            "select country.Name, country.Region",
            "select country.Code, country.Name",
            "select country.Name, country.Code",
            "select country.Name, country.Capital"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which country in Asia has the least life expectancy?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name the country that has the shortest life expectancy in Asia., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE ORDER BY-LIMIT",
            "SELECT-FROM-WHEREORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-CLIMIT",
            "SELECT-FROM-WHERE orORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name the country that has the shortest life expectancy in Asia., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Code",
            "select country.Name, country.Population",
            "select country.Name, country.LifeExpectancy",
            "select country.Name, country.Region",
            "select country.Name, country.LocalName",
            "select country.Name, country.Capital"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name the country that has the shortest life expectancy in Asia., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which country has the shortest life expectancy in Asia?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-CLIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which country has the shortest life expectancy in Asia?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Code",
            "select country.Name, country.LifeExpectancy",
            "select country.Code, country.Name",
            "select country.Name, country.Population",
            "select country.Name, country.Region",
            "select country.Name, country.LocalName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which country has the shortest life expectancy in Asia?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which Asian country has the largest area? and what is its population? and what is its expected life length?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which Asian country has the largest area? and what is its population? and what is its expected life length?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, t2.c6, t2.c7",
        "label": "select t2.c1, t2.c6, t2.c7",
        "score": true,
        "real_pred": "select country.Name, country.Population, country.LifeExpectancy",
        "real_label": "select country.Name, country.Population, country.LifeExpectancy",
        "topk_preds": [
            "select country.Name, country.Population, country.LifeExpectancy",
            "select country.Name, country.IndepYear, country.Population, country.LifeExpectancy",
            "select country.Name, country.Continent, country.Population, country.LifeExpectancy",
            "select country.Code, country.Name, country.Population, country.LifeExpectancy",
            "select country.Name, country.SurfaceArea, country.Population, country.LifeExpectancy",
            "select country.Name, country.Population), country.LifeExpectancy",
            "select country.Name, country.Population, country.LifeExpectancy, country.GNP",
            "select country.Name, country.Population und country.LifeExpectancy"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which Asian country has the largest area? and what is its population? and what is its expected life length?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: which asian country has biggest area, and what is the population and expected live time of its citizens, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, t2.c1, t2.c6, t2.c7"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: which asian country has biggest area, and what is the population and expected live time of its citizens, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, t2.c6, t2.c7",
        "label": "select t2.c1, t2.c6, t2.c7",
        "score": true,
        "real_pred": "select country.Name, country.Population, country.LifeExpectancy",
        "real_label": "select country.Name, country.Population, country.LifeExpectancy",
        "topk_preds": [
            "select country.Name, country.Population, country.LifeExpectancy",
            "select country.Name, country.IndepYear, country.Population, country.LifeExpectancy",
            "select country.Name, country.Code, country.Population, country.LifeExpectancy",
            "select country.Name, country.Continent, country.Population, country.LifeExpectancy",
            "select country.Name, country.Population), country.LifeExpectancy",
            "select country.Name, country.Population, country.LifeExpectancy, country.Capital",
            "select country.Name, country.Population, country.LifeExpectancy",
            "select country.Name, country.LifeExpectancy, country.Population"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: which asian country has biggest area, and what is the population and expected live time of its citizens, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give nations that both speak English and French., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE (GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROMWHERE",
            "SELECT-FROM BOTH-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROMWHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give nations that both speak English and French., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, country.Code",
            "select country.Name, country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Capital",
            "select country.Name, country.Region",
            "select country.Name, countrylanguage.Language"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give nations that both speak English and French., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which countries speak both English and French?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-FLOSS-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM BOTH-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-SWITCH-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHITE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROMWHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which countries speak both English and French?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.CountryCode",
            "select countrylanguage.CountryCode",
            "select country.Name, country.Continent",
            "select country.Name, country.Code",
            "select countrylanguage.Language, country.Name",
            "select country.Name, countrylanguage.Language",
            "select country.Name, country.Region"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which countries speak both English and French?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t2 t3",
        "score": false,
        "real_pred": "countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which country has English and French as official langues?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-COLONIAL-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-COLONIAL-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-COMBINAT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-COLOR-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-COMBINED-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which country has English and French as official langues?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, country.Continent",
            "select country.Name, country.Code",
            "select countrylanguage.Language, countrylanguage.IsOfficial",
            "select country.Name, country.Region",
            "select country.Name, countrylanguage.Language",
            "select country.Name, country.Capital"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which country has English and French as official langues?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "",
            "sqlite_sequence countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which Countries have a Language that is English & french as official language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-COLOR-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-COMBINAT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which Countries have a Language that is English & french as official language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select countrylanguage.CountryCode",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, country.Continent",
            "select country.Name, country.Code",
            "select countrylanguage.Language, countrylanguage.IsOfficial",
            "select country.Name, countrylanguage.Language",
            "select countrylanguage.CountryCode, countrylanguage.Language"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which Countries have a Language that is English & french as official language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t2 t3",
        "score": false,
        "real_pred": "countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "country countrylanguage",
            "",
            "",
            "",
            "sqlite_sequence countrylanguage",
            "",
            "sqlite_sequence country countrylanguage"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Tell me all the countries that have English and French as official languages., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-COLLABORATION-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-COLOR-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROMWHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Tell me all the countries that have English and French as official languages., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c0",
        "label": "select t2.c1",
        "score": false,
        "real_pred": "select countrylanguage.CountryCode",
        "real_label": "select country.Name",
        "topk_preds": [
            "select countrylanguage.CountryCode",
            "select country.Name",
            "select countrylanguage.Language, countrylanguage.IsOfficial",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, country.Continent",
            "select country.Name, country.Code",
            "select country.Name, countrylanguage.Language",
            "select country.Name, country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Tell me all the countries that have English and French as official languages., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t2 t3",
        "score": false,
        "real_pred": "countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "country countrylanguage",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are countries with English and French as official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-COLLABORATION-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-COLOR-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-COLLABORATION-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROMWHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are countries with English and French as official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c0",
        "label": "select t2.c1",
        "score": false,
        "real_pred": "select countrylanguage.CountryCode",
        "real_label": "select country.Name",
        "topk_preds": [
            "select countrylanguage.CountryCode",
            "select country.Name",
            "select country.Name, countrylanguage.CountryCode",
            "select countrylanguage.Language, countrylanguage.IsOfficial",
            "select country.Name, country.Continent",
            "select country.Name, country.Code",
            "select country.Name, countrylanguage.Language",
            "select countrylanguage.CountryCode, countrylanguage.Language"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are countries with English and French as official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, French), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t2 t3",
        "score": false,
        "real_pred": "countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "country countrylanguage",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give the country and show its language spoken numbers for all countries that speak at least 3 languages., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give the country and show its language spoken numbers for all countries that speak at least 3 languages., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, t3.c1",
        "label": "select count(t3.c1), t2.c1",
        "score": false,
        "real_pred": "select country.Name, countrylanguage.Language",
        "real_label": "select count(countrylanguage.Language), country.Name",
        "topk_preds": [
            "select country.Name, countrylanguage.Language",
            "select country.Name, countrylanguage.CountryCode, count(distinct countrylanguage.Language)",
            "select country.Name, countrylanguage.CountryCode, count(*)",
            "select country.Name, countrylanguage.Language, countrylanguage.Percentage",
            "select country.Name, countrylanguage.CountryCode, countrylanguage.Language",
            "select country.Name, country.Name, countrylanguage.Language",
            "select country.Name, count(distinct countrylanguage.Language)",
            "select country.Name, countrylanguage.CountryCode"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give the country and show its language spoken numbers for all countries that speak at least 3 languages., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me countries and their #of languages spoken per country for those with 3 or more languages., database: Database: world_1. t0: city(c0: id, c1: name (Perm), c2: countrycode (PER), c3: district (Perm), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code (PER), c1: name (Peru), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode (PER), c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me countries and their #of languages spoken per country for those with 3 or more languages., database: Database: world_1. t0: city(c0: id, c1: name (Perm), c2: countrycode (PER), c3: district (Perm), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code (PER), c1: name (Peru), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode (PER), c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, count(distinct t3.c1)",
        "label": "select count(t3.c1), t2.c1",
        "score": false,
        "real_pred": "select country.Name, count(distinct countrylanguage.Language)",
        "real_label": "select count(countrylanguage.Language), country.Name",
        "topk_preds": [
            "select country.Name, count(distinct countrylanguage.Language)",
            "select country.Name, count(*)",
            "select count(distinct countrylanguage.Language), country.Name",
            "select country.Name, countrylanguage.CountryCode, count(distinct countrylanguage.Language)",
            "select count(distinct country.Name), country.Name",
            "select count(distinct country.Name), countrylanguage.CountryCode",
            "select country.Name, count(distinct country.Name)",
            "select country.Name, count(distinct countrylanguage.IsOfficial)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me countries and their #of languages spoken per country for those with 3 or more languages., database: Database: world_1. t0: city(c0: id, c1: name (Perm), c2: countrycode (PER), c3: district (Perm), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code (PER), c1: name (Peru), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode (PER), c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "countrylanguage",
            "sqlite_sequence countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which countries were founded after 1950, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INSERT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which countries were founded after 1950, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select distinct country.Name",
            "select country.Name, country.Code",
            "select country.Name, country.Capital",
            "select country.Code, country.Name",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Code2",
            "select country.Name, country.Region"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which countries were founded after 1950, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name countries founded after 1950., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name countries founded after 1950., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Code",
            "select distinct country.Name",
            "select country.Name, country.Code2",
            "select country.Name, country.LocalName",
            "select country.Name, country.Region"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name countries founded after 1950., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What countries has been founded after 1950?., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What countries has been founded after 1950?., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select distinct country.Name",
            "select country.Name, country.Capital",
            "select only country.Name",
            "select country.Name, country.Code",
            "select country.Code, country.Name",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Region"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What countries has been founded after 1950?., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List nations founded after 1950., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List nations founded after 1950., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select distinct country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.HeadOfState",
            "select country.Code, country.Name",
            "select distinct country.Name, country.Capital",
            "select new country.Name",
            "select only country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List nations founded after 1950., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which nations were established after 1950?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which nations were established after 1950?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select distinct country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.Code",
            "select distinct country.Name, country.Capital",
            "select only country.Name",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.LocalName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which nations were established after 1950?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What conductors don't have American nationality?., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHAT-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What conductors don't have American nationality?., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select conductor.Conductor_ID",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Conductor_ID",
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Conductor_ID, conductor.Nationality",
            "select distinct conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Nationality,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What conductors don't have American nationality?., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What conductors don't have the nationality\" USA\"?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WONT-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What conductors don't have the nationality\" USA\"?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select conductor.Conductor_ID",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Conductor_ID",
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Age, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Nationality",
            "select conductor.Name, conductor.Conductor_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What conductors don't have the nationality\" USA\"?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which Conductors have no nationality USA?., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-HAVE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which Conductors have no nationality USA?., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select conductor.Conductor_ID",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Conductor_ID",
            "select conductor.Name",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Conductor_ID, conductor.Name, conductor.Nationality"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which Conductors have no nationality USA?., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give the list of conductors without American nationality., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WITHOUT-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give the list of conductors without American nationality., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Conductor_ID",
            "select conductor.Conductor_ID, conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select distinct conductor.Name, conductor.Nationality"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give the list of conductors without American nationality., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which conductors does not have USA as their nationality?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which conductors does not have USA as their nationality?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select conductor.Conductor_ID",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Conductor_ID",
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Age, conductor.Nationality",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Name, conductor.Nationality,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which conductors does not have USA as their nationality?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show conductors without US citizenship., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show conductors without US citizenship., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select conductor.Conductor_ID",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Conductor_ID",
            "select conductor.Conductor_ID, conductor.Nationality",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Conductor_ID, conductor.Age",
            "select conductor.Name, conductor.Age",
            "select conductor.Conductor_ID - conductor.Nationality"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show conductors without US citizenship., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who conducts which Orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who conducts which Orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t1.c1",
        "label": "select t0.c1, t1.c1",
        "score": true,
        "real_pred": "select conductor.Name, orchestra.Orchestra",
        "real_label": "select conductor.Name, orchestra.Orchestra",
        "topk_preds": [
            "select conductor.Name, orchestra.Orchestra",
            "select orchestra.Orchestra, conductor.Name",
            "select orchestra.Conductor_ID, orchestra.Orchestra",
            "select conductor.Name, orchestra.Conductor_ID",
            "select orchestra.Conductor_ID, conductor.Name",
            "select show.Performance_ID, orchestra.Orchestra",
            "select performance.Type, orchestra.Orchestra",
            "select conductor.Name, orchestra.Orchestra_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who conducts which Orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who has been conducting which orchestra., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM.ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM -ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who has been conducting which orchestra., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t1.c1",
        "label": "select t0.c1, t1.c1",
        "score": true,
        "real_pred": "select conductor.Name, orchestra.Orchestra",
        "real_label": "select conductor.Name, orchestra.Orchestra",
        "topk_preds": [
            "select conductor.Name, orchestra.Orchestra",
            "select conductor.Name",
            "select orchestra.Orchestra, conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select orchestra.Conductor_ID, orchestra.Orchestra",
            "select performance.Performance_ID, conductor.Name",
            "select performance.Orchestra_ID, orchestra.Orchestra",
            "select show.Performance_ID, orchestra.Orchestra"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who has been conducting which orchestra., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name the conductors and the orchestras they directed., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT.C1, SELECT.C1",
            "SELECT.C1, SELECT-FROM",
            "SELECT-FROM SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name the conductors and the orchestras they directed., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t1.c1",
        "label": "select t0.c1, t1.c1",
        "score": true,
        "real_pred": "select conductor.Name, orchestra.Orchestra",
        "real_label": "select conductor.Name, orchestra.Orchestra",
        "topk_preds": [
            "select conductor.Name, orchestra.Orchestra",
            "select orchestra.Conductor_ID, orchestra.Orchestra",
            "select orchestra.Orchestra, conductor.Name",
            "select performance.Type, orchestra.Orchestra",
            "select performance.Orchestra_ID, orchestra.Orchestra",
            "select show.Performance_ID, orchestra.Orchestra",
            "select conductor.Name, orchestra.Conductor_ID",
            "select performance.Performance_ID, orchestra.Orchestra"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name the conductors and the orchestras they directed., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show list of conductors sorted descending by the number of years they have worked., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY t0",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM\u2013ORDER BY",
            "SELECT-FROM-ORDER BY (",
            "SELECT-FROM- ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show list of conductors sorted descending by the number of years they have worked., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select conductor.Conductor_ID",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Conductor_ID",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Conductor_ID, conductor.Name, conductor.Year_of_Work",
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Name, conductor.Age, conductor.Year_of_Work"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show list of conductors sorted descending by the number of years they have worked., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name Conductors, sorted descending by the year they have worked., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0",
            "SELECT-FROM-ORDER BY t0.c1",
            "SELECT-FROM-ORDER BY (CLIENT-WHERE-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (CLIENT-FROM-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name Conductors, sorted descending by the year they have worked., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Age, conductor.Nationality",
            "select conductor.Name (ordered conductor.Conductor_ID)",
            "select conductor.Name, conductor.Nationality"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name Conductors, sorted descending by the year they have worked., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List conductors who have worked with more then one orchestra., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GATHER-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List conductors who have worked with more then one orchestra., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Name, orchestra.Orchestra_ID",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Name, conductor.Age",
            "select conductor.Name the, orchestra.Conductor_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List conductors who have worked with more then one orchestra., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Mention the conductors that have performed more than one orchestra., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GEM-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAMMA-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Mention the conductors that have performed more than one orchestra., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select performance.Orchestra_ID, conductor.Name",
            "select conductor.Name, performance.Orchestra_ID",
            "select conductor.Name, conductor.Age",
            "select performance.Performance_ID, conductor.Name",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Name, conductor.Nationality"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Mention the conductors that have performed more than one orchestra., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1",
        "score": false,
        "real_pred": "conductor orchestra performance",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra performance",
            "",
            "",
            "conductor orchestra",
            "",
            "",
            "show orchestra performance",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which conductors has conducted multiple Orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which conductors has conducted multiple Orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Name, orchestra.Orchestra_ID",
            "select conductor.Name, orchestra.Conductor_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which conductors has conducted multiple Orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which conductors have conducted more than one orchestra?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which conductors have conducted more than one orchestra?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Name, orchestra.Orchestra_ID",
            "select conductor.Name the, orchestra.Conductor_ID",
            "select conductor.Name, conductor.Conductor_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which conductors have conducted more than one orchestra?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are the conductors whose nationality is not usa?., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are the conductors whose nationality is not usa?., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Conductor_ID, conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Name, conductor.Nationality, conductor.Age",
            "select conductor.Name, conductor.Nationality"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are the conductors whose nationality is not usa?., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are conductors that are not from America?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are conductors that are not from America?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Nationality, conductor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are conductors that are not from America?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List Conductors whose nationalities are not US (United States)., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List Conductors whose nationalities are not US (United States)., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select conductor.Conductor_ID",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Conductor_ID",
            "select conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Nationality",
            "select conductor.Name",
            "select distinct conductor.Conductor_ID",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID3",
            "select distinct conductor.Name, conductor.Nationality"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List Conductors whose nationalities are not US (United States)., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are conductors who do not belong to USA?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are conductors who do not belong to USA?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Name, conductor.Age",
            "select conductor.Conductor_ID, conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Name, conductor.Nationality, conductor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are conductors who do not belong to USA?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who has had the most experience as a conductor?., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who has had the most experience as a conductor?., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Name, t0.c6",
            "select conductor.Name, t0.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who has had the most experience as a conductor?., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "conductor orchestra",
            "",
            "conductor orchestra performance",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which conductor has done longest work?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which conductor has done longest work?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Conductor_ID, conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name, conductor.Year_of_Work",
            "select conductor.Conductor_ID, conductor.Name, conductor.Nationality"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which conductor has done longest work?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which conductor had more years of experience?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which conductor had more years of experience?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Name, t0.c6",
            "select conductor.Conductor_ID, conductor.Name,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which conductor had more years of experience?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which one did conduct the longest?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which one did conduct the longest?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Name, t0.c6",
            "select conductor.Name, t0.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which one did conduct the longest?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "conductor orchestra",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the conductor who has worked the most years., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the conductor who has worked the most years., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Conductor_ID, conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name, conductor.Year_of_Work",
            "select conductor.Name, conductor.Year_of_Work"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the conductor who has worked the most years., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who is the conductor who conducts most orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who is the conductor who conducts most orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, orchestra.Conductor_ID, conductor.Nationality",
            "select conductor.Name (orchestra.Conductor_ID)",
            "select conductor.Name (select orchestra.Conductor_ID)",
            "select conductor.Name (select conductor.Conductor_ID)",
            "select conductor.Name, orchestra.Conductor_ID, orchestra.Record_Company",
            "select conductor.Name, orchestra.Orchestra_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who is the conductor who conducts most orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which conductor has conducted the most orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which conductor has conducted the most orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Name, conductor.Age",
            "select conductor.Name (orchestra.Conductor_ID)",
            "select conductor.Name, orchestra.Orchestra_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which conductor has conducted the most orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who has led most orchestras as a conductor?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who has led most orchestras as a conductor?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name (orchestrator_orchestra.Conductor_ID)",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name (orchestra.Conductor_ID)",
            "select conductor.Name, orchestra.Orchestra_ID",
            "select conductor.Name (select orchestra.Conductor_ID)",
            "select conductor.Name, orchestra.Orchestra"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who has led most orchestras as a conductor?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What conductors were active or founded orchestras established after 2008?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNIT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What conductors were active or founded orchestras established after 2008?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select active conductor.Name",
            "select active conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, orchestra.Orchestra_ID",
            "select conductor.Name, conductor.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What conductors were active or founded orchestras established after 2008?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are conductors who conducted orchestras founded after the year 2008?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-CONDIT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-CONDUCTOR"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are conductors who conducted orchestras founded after the year 2008?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Name, conductor.Nationality",
            "select distinct conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are conductors who conducted orchestras founded after the year 2008?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who has conducted orchestras founded in 2008, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who has conducted orchestras founded in 2008, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select distinct conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, orchestra.Orchestra_ID",
            "select conductor.Name (conductor.Conductor_ID)",
            "select conductor.Name, conductor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who has conducted orchestras founded in 2008, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are conductors who have led orchestras established after the year 2008?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-CONDIT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are conductors who have led orchestras established after the year 2008?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, conductor.Age",
            "select distinct conductor.Name",
            "select distinct conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Name, conductor.Nationality",
            "select distinct conductor.Name, orchestra.Conductor_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are conductors who have led orchestras established after the year 2008?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What conductor have conducted orchestra founded after 2008?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-CONDIT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What conductor have conducted orchestra founded after 2008?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name (orchestrator_orchestra.Conductor_ID)",
            "select distinct conductor.Name",
            "select conductor.Name (orchestrator_id orchestra.Conductor_ID)",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, orchestra.Conductor_ID, orchestra.Record_Company"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What conductor have conducted orchestra founded after 2008?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who has worked the longest as conductor?., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who has worked the longest as conductor?., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Age",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Name, conductor.Age, conductor.Nationality",
            "select conductor.Name, conductor.Nationality, conductor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who has worked the longest as conductor?., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who is the conductor that has worked the longest?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who is the conductor that has worked the longest?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Name, conductor.Age, conductor.Nationality",
            "select conductor.Name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who is the conductor that has worked the longest?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who had the longest career as a conductor?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who had the longest career as a conductor?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, t0.c6",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Name, t0.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who had the longest career as a conductor?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "conductor orchestra",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which conductor has worked the longest time?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which conductor has worked the longest time?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Conductor_ID, conductor.Name, conductor.Year_of_Work",
            "select conductor.Conductor_ID, conductor.Name, conductor.Nationality"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which conductor has worked the longest time?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who conducts orchestras founded after 2008?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-CONDUCT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-CONDUCT-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who conducts orchestras founded after 2008?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, conductor.Age",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name (conductor.Conductor_ID)",
            "select conductor.Name, orchestra.Orchestra_ID",
            "select conductor.Name, orchestra.Year_of_Founded"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who conducts orchestras founded after 2008?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which one has conducted orchestra founded after 2008., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-CONDUCT-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which one has conducted orchestra founded after 2008., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name (orchestrator_orchestra.Conductor_ID)",
            "select distinct conductor.Name",
            "select orchestra.Conductor_ID",
            "select conductor.Name, conductor.Age",
            "select distinct conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, orchestra.Conductor_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which one has conducted orchestra founded after 2008., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Tell me about the conductor that has conducted orchestras founded after 2008., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Tell me about the conductor that has conducted orchestras founded after 2008., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, conductor.Age",
            "select distinct conductor.Name",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name, orchestra.Conductor_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Tell me about the conductor that has conducted orchestras founded after 2008., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who has conducted orchestras founded after 2008?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who has conducted orchestras founded after 2008?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select distinct conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select distinct conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, orchestra.Orchestra_ID",
            "select conductor.Name, conductor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who has conducted orchestras founded after 2008?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which conductors had conducted at more orchestras than one?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAMMA-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which conductors had conducted at more orchestras than one?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, orchestra.Orchestra_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which conductors had conducted at more orchestras than one?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What conductors have conducted at more than one orchestra?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What conductors have conducted at more than one orchestra?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, orchestra.Orchestra_ID",
            "select conductor.Name the, orchestra.Conductor_ID",
            "select conductor.Name, conductor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What conductors have conducted at more than one orchestra?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who were conductors that worked at more than one orchestra?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GEO-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-POP-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who were conductors that worked at more than one orchestra?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, orchestra.Orchestra",
            "select conductor.Name, orchestra.Orchestra_ID",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name (conductor.Conductor_ID)",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, conductor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who were conductors that worked at more than one orchestra?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name conductors who have conducted at more than one orchestra?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GATHER-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM.GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name conductors who have conducted at more than one orchestra?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, orchestra.Orchestra",
            "select conductor.Name, orchestra.Orchestra_ID",
            "select conductor.Name (conductor.Conductor_ID)",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name de, orchestra.Conductor_ID",
            "select conductor.Name, orchestra.Record_Company"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name conductors who have conducted at more than one orchestra?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which conductors has conducted at more than one orchestra?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GATHER-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which conductors has conducted at more than one orchestra?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, orchestra.Orchestra_ID",
            "select conductor.Name, orchestra.Conductor_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which conductors has conducted at more than one orchestra?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name conductors in increasing order of age., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY ",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY (t0.c1)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name conductors in increasing order of age., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name in conductor.Age",
            "select conductor.Name ou conductor.Age",
            "select conductor.Name dans conductor.Age",
            "select conductor.Name or conductor.Age",
            "select conductor.Name, conductor.Conductor_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name conductors in increasing order of age., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which conductor has done the most orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which conductor has done the most orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which conductor has done the most orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who has conducted the greatest number of orchestras, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who has conducted the greatest number of orchestras, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, orchestra.Orchestra_ID",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name (orchestra.Conductor_ID)",
            "select conductor.Name, orchestra.Orchestra"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who has conducted the greatest number of orchestras, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            "conductor orchestra performance"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: what conductor has conducted most orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: what conductor has conducted most orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name (orchestra.Conductor_ID)",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, conductor.Age",
            "select conductor.Name de orchestra.Conductor_ID",
            "select conductor.Name, orchestra.Orchestra_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: what conductor has conducted most orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which conductor has conducted the most orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which conductor has conducted the most orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Name, conductor.Age",
            "select conductor.Name (orchestra.Conductor_ID)",
            "select conductor.Name, orchestra.Orchestra_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which conductor has conducted the most orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Describe conductors in descending order of years of work., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (CLIENT-QUEST-SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY (CLOSE-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Describe conductors in descending order of years of work., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c4",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select conductor.Name, conductor.Year_of_Work",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Conductor_ID, conductor.Name, conductor.Year_of_Work",
            "select conductor.Name, conductor.Age, conductor.Nationality",
            "select conductor.Name, conductor.Age, conductor.Year_of_Work"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Describe conductors in descending order of years of work., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Describe conductors in descending years of work., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORSECT-SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM\u2013ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Describe conductors in descending years of work., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c4",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select conductor.Name, conductor.Year_of_Work",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name, conductor.Year_of_Work",
            "select conductor.Name, conductor.Age, conductor.Year_of_Work",
            "select conductor.Conductor_ID, conductor.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Describe conductors in descending years of work., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List conductors by their years of service in descending order., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (CLIENT-UNION-SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (CLIENT-QUEST-SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (CLIENT-WHERE-ORDER BY",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List conductors by their years of service in descending order., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select conductor.Conductor_ID",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Conductor_ID",
            "select conductor.Conductor_ID, conductor.Year_of_Work",
            "select conductor.Year_of_Work",
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Name, conductor.Age",
            "select conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Age, conductor.Year_of_Work",
            "select conductor.Conductor_ID, conductor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List conductors by their years of service in descending order., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List conductors in descending year of experience., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY (t0.c0)",
            "SELECT-FROM-ORDER BY (t0.c0"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List conductors in descending year of experience., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select conductor.Conductor_ID",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Conductor_ID",
            "select conductor.Conductor_ID, conductor.Name, conductor.Year_of_Work",
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Name, conductor.Age",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Conductor_ID, conductor.Name, conductor.Age",
            "select conductor.Age, conductor.Nationality, conductor.Year_of_Work"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List conductors in descending year of experience., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who were conductors as well as which orchestras did they lead?., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM t1.C1, SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM t1.C1, t0.c1",
            "SELECT-FROM t0 e SELECT-FROM",
            "SELECT-FROM t0 SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who were conductors as well as which orchestras did they lead?., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t1.c1",
        "label": "select t0.c1, t1.c1",
        "score": true,
        "real_pred": "select conductor.Name, orchestra.Orchestra",
        "real_label": "select conductor.Name, orchestra.Orchestra",
        "topk_preds": [
            "select conductor.Name, orchestra.Orchestra",
            "select orchestra.Orchestra, conductor.Name",
            "select performance.Orchestra_ID, orchestra.Orchestra",
            "select show.Performance_ID, orchestra.Orchestra",
            "select conductor.Name, orchestra.Conductor_ID",
            "select t0.1.c1, orchestra.Orchestra",
            "select t.c1, orchestra.Orchestra",
            "select orchestra.Orchestra, conductor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who were conductors as well as which orchestras did they lead?., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are conductors and which orchestra's have they worked for?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM t0.c1, t1.c1",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM t0 SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are conductors and which orchestra's have they worked for?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t1.c1",
        "label": "select t0.c1, t1.c1",
        "score": true,
        "real_pred": "select conductor.Name, orchestra.Orchestra",
        "real_label": "select conductor.Name, orchestra.Orchestra",
        "topk_preds": [
            "select conductor.Name, orchestra.Orchestra",
            "select orchestra.Orchestra, conductor.Name",
            "select performance.Orchestra_ID, conductor.Name",
            "select performance.Orchestra_ID, orchestra.Orchestra",
            "select show.Performance_ID, orchestra.Orchestra",
            "select conductor.Name, orchestra.Conductor_ID",
            "select performance.Orchestra_ID, conductor.Age",
            "select conductor.Name, orchestra.Orchestra,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are conductors and which orchestra's have they worked for?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What conductors have there been, and what orchestras have they conducted?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What conductors have there been, and what orchestras have they conducted?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t1.c1",
        "label": "select t0.c1, t1.c1",
        "score": true,
        "real_pred": "select conductor.Name, orchestra.Orchestra",
        "real_label": "select conductor.Name, orchestra.Orchestra",
        "topk_preds": [
            "select conductor.Name, orchestra.Orchestra",
            "select orchestra.Orchestra, conductor.Name",
            "select orchestra.Conductor_ID, orchestra.Orchestra",
            "select performance.Orchestra_ID, orchestra.Orchestra",
            "select conductor.Name, orchestra.Orchestra",
            "select show.Performance_ID, orchestra.Orchestra",
            "select conductor.Name, orchestra.Conductor_ID",
            "select performance.Performance_ID, orchestra.Orchestra"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What conductors have there been, and what orchestras have they conducted?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the students who had the most likes?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the students who had the most likes?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name, t0.c3",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, Likes.student_id",
            "select Highschooler.name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the students who had the most likes?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which student has the most likes, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which student has the most likes, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Likes.student_id",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.ID, Highschooler.name",
            "select Likes.student_id, Highschooler.name",
            "select Highschooler.name (Highschooler.ID)",
            "select Highschooler.name, t0.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which student has the most likes, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What student has the most likes?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What student has the most likes?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Likes.student_id",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name, t0.c3",
            "select Highschooler.name (Highschooler.ID)",
            "select Likes.student_id, Highschooler.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What student has the most likes?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            "Highschooler Friend Likes",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name one student who has the most likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name one student who has the most likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Likes.student_id",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.ID, Highschooler.name",
            "select Likes.student_id, Highschooler.name",
            "select Highschooler.name (Highschooler.ID)",
            "select Highschooler.name, t0.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name one student who has the most likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all students in grade 10., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all students in grade 10., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select distinct t0.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select distinct Highschooler.ID",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select distinct Highschooler.ID",
            "select distinct Highschooler.name, Highschooler.grade",
            "select Highschooler.ID",
            "select distinct Highschooler.ID, Highschooler.name",
            "select distinct Highschooler.name",
            "select Highschooler.ID, Highschooler.name",
            "select distinct Highschooler.name, Highschooler.ID",
            "select distinct Highschooler.name, t0.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all students in grade 10., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What high-school students have 3 or more friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What high-school students have 3 or more friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select distinct Highschooler.name",
            "select Highschooler.ID, Highschooler.name",
            "select distinct Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.ID",
            "select distinct Highschooler.ID",
            "select Highschooler.ID",
            "select distinct Highschooler.ID, Highschooler.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What high-school students have 3 or more friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "",
            "",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are all high school students that have at least 3 friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are all high school students that have at least 3 friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.grade",
            "select distinct Highschooler.name",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name, Friend.student_id",
            "select distinct Highschooler.name, Highschooler.ID",
            "select Highschooler.name, t0.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are all high school students that have at least 3 friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "",
            "",
            "",
            "",
            "Highschooler Friend Likes",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What high school students have like, and on which numbers do they have?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What high school students have like, and on which numbers do they have?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1, t2.c0",
        "label": "select t0.c1, count(*)",
        "score": false,
        "real_pred": "select Highschooler.name, Likes.student_id",
        "real_label": "select Highschooler.name, count(*)",
        "topk_preds": [
            "select Highschooler.name, Likes.student_id",
            "select count(*), Highschooler.name",
            "select distinct Likes.student_id, Likes.liked_id",
            "select Highschooler.name, Highschooler.grade",
            "select Likes.liked_id, Highschooler.name",
            "select distinct Likes.liked_id, Highschooler.grade",
            "select Highschooler.name, Likes.liked_id",
            "select count(*), Highschooler.ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What high school students have like, and on which numbers do they have?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show list of high schools students with likes, and how much they had per person., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GEOGRAPHIC-GROUP BY",
            "SELECT-FROM-GROUP BY ORDER BY",
            "SELECT-FROM-GEO-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show list of high schools students with likes, and how much they had per person., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1, sum(t2.c1)",
        "label": "select t0.c1, count(*)",
        "score": false,
        "real_pred": "select Highschooler.name, sum(Likes.liked_id)",
        "real_label": "select Highschooler.name, count(*)",
        "topk_preds": [
            "select Highschooler.name, sum(Likes.liked_id)",
            "select Highschooler.name, count(*)",
            "select Highschooler.ID, count(*)",
            "select Highschooler.ID, sum(Likes.liked_id)",
            "select Highschooler.name, sum(t2.c3)",
            "select Highschooler.name, sum(t2.c4)",
            "select sum(Likes.liked_id), Highschooler.name",
            "select Highschooler.name, sum(t2.c5)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show list of high schools students with likes, and how much they had per person., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who have likes in high school? And How many likes does each one has?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM",
            "SELECT-FROM-WHERE-GIRL-GROUP BY",
            "SELECT-FROM -WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GATHERING-GROUP BY",
            "SELECT-FROM in-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GIGROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who have likes in high school? And How many likes does each one has?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select count(*), t0.c1",
        "label": "select t0.c1, count(*)",
        "score": false,
        "real_pred": "select count(*), Highschooler.name",
        "real_label": "select Highschooler.name, count(*)",
        "topk_preds": [
            "select count(*), Highschooler.name",
            "select Highschooler.name, count(*)",
            "select distinct Highschooler.name, count(*)",
            "select top Highschooler.name, count(*)",
            "select two Highschooler.name, count(*)",
            "select Likes.liked_id, count(*)",
            "select counts(*), Highschooler.name",
            "select count(*), Highschooler.ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who have likes in high school? And How many likes does each one has?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: which has students who have grade point over 5 and have at least two friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUPS-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: which has students who have grade point over 5 and have at least two friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.ID",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, t0.c6",
            "select Highschooler.name, t0.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: which has students who have grade point over 5 and have at least two friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name some high schoolers who both have friends and are liked, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-INTERSECT-SELECT-FROM",
        "label": "SELECT-FROM-INTERSECT-SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM-INTERSECT-SELECT-FROM",
        "real_label": "SELECT-FROM-INTERSECT-SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-INTERSECT-SELECT-FROM",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM",
            "SELECT-FROM-BALANCED-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-HAVING-INTERSECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name some high schoolers who both have friends and are liked, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Likes.liked_id",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Likes.student_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name some high schoolers who both have friends and are liked, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Highschooler Friend Likes",
        "real_label": "Highschooler Friend Likes",
        "topk_preds": [
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What high school students have friends and are liked?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-UNION-SELECT-FROM",
        "label": "SELECT-FROM-INTERSECT-SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-UNION-SELECT-FROM",
        "real_label": "SELECT-FROM-INTERSECT-SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-INTERSECT-SELECT-FROM",
            "SELECT-FROM",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM",
            "SELECT-FROM-HAVING-INTERSECT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What high school students have friends and are liked?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select Highschooler.name, Highschooler.grade",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name, Highschooler.grade",
            "select distinct Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.ID",
            "select distinct Highschooler.name, Highschooler.grade",
            "select Highschooler.name",
            "select distinct Highschooler.name",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, Friend.student_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What high school students have friends and are liked?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Highschooler Friend Likes",
        "real_label": "Highschooler Friend Likes",
        "topk_preds": [
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "Highschooler Friend",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who has the most friends in High School., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who has the most friends in High School., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, t1.c3",
            "select Highschooler.name (Friend.friend_id)",
            "select Highschooler.name, Highschooler.ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who has the most friends in High School., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For which high school student are the most friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For which high school student are the most friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name (Friend.student_id)",
            "select Highschooler.name de, Friend.student_id",
            "select Highschooler.name, Friend.student_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For which high school student are the most friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who were friends of highschool Kyle., database: Database: network_1. t0: highschooler(c0: id, c1: name (Kyle), c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who were friends of highschool Kyle., database: Database: network_1. t0: highschooler(c0: id, c1: name (Kyle), c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t1.c1",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select Friend.friend_id",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Friend.friend_id",
            "select distinct Friend.friend_id",
            "select Friend.friend_id, Highschooler.name",
            "select list(Friend.friend_id)",
            "select distinct Friend.friend_id, Highschooler.name",
            "select count(Friend.friend_id)",
            "select Friend.friend_id, Highschooler.grade",
            "select t1.c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who were friends of highschool Kyle., database: Database: network_1. t0: highschooler(c0: id, c1: name (Kyle), c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are friends of the high school student Kyle?., database: Database: network_1. t0: highschooler(c0: id, c1: name (Kyle), c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are friends of the high school student Kyle?., database: Database: network_1. t0: highschooler(c0: id, c1: name (Kyle), c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t1.c1",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select Friend.friend_id",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Friend.friend_id",
            "select distinct Friend.friend_id",
            "select Friend.friend_id, Highschooler.name",
            "select list(Friend.friend_id)",
            "select count(Friend.friend_id)",
            "select distinct Friend.friend_id, Highschooler.name",
            "select Friend.friend_id, Highschooler.grade",
            "select t1.c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are friends of the high school student Kyle?., database: Database: network_1. t0: highschooler(c0: id, c1: name (Kyle), c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the high schoolers and grades of each student., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM (GROUP BY-HAVING",
            "SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the high schoolers and grades of each student., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select Highschooler.name, Highschooler.grade",
        "real_label": "select Highschooler.name, Highschooler.grade",
        "topk_preds": [
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.ID, Highschooler.name, Highschooler.grade",
            "select distinct Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.grade, Highschooler.ID",
            "select Highschooler.ID, Highschooler.name, t0.c 2",
            "select sum(Highschooler.grade), Highschooler.name",
            "select Highschooler.ID, Highschooler.name, Highschooler.grade,",
            "select Highschooler.name., Highschooler.grade"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the high schoolers and grades of each student., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Mention students who have a grade higher than 5 and have at least two friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-CONSISTENT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Mention students who have a grade higher than 5 and have at least two friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, t0.c6",
            "select Highschooler.name, t0.c3",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name, t0.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Mention students who have a grade higher than 5 and have at least two friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who has grades higher than 5, and have at least 2 friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUPS BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who has grades higher than 5, and have at least 2 friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, t0.c5",
            "select Highschooler.name, Highschooler.grade.c0",
            "select Highschooler.name, t0.c6",
            "select Highschooler.name, Highschooler.grade,",
            "select Highschooler.name, Highschooler.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who has grades higher than 5, and have at least 2 friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the students who have a grade above five and at least two friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GEOLOGICAL-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GEO-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the students who have a grade above five and at least two friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.ID",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, t0.c6",
            "select Highschooler.name, t0.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the students who have a grade above five and at least two friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who have grades higher than five and have at least two friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GEOLOGICAL-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GEO-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who have grades higher than five and have at least two friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, t0.c6",
            "select Highschooler.name, Highschooler.grade,",
            "select Highschooler.name, t0.c5",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, t0.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who have grades higher than five and have at least two friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which students have at least two likes, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which students have at least two likes, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Likes.student_id",
            "select Likes.student_id",
            "select Highschooler.name, t0.c3",
            "select Highschooler.name, Highschooler.ID2",
            "select Highschooler.name, Highschooler.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which students have at least two likes, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which student has at least two likes?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which student has at least two likes?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Likes.student_id",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, t0.c3",
            "select Highschooler.name si, Highschooler.ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which student has at least two likes?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show students whose are at least two persons or people like, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING/UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING\u2013UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING or LIKE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show students whose are at least two persons or people like, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Likes.student_id",
            "select Highschooler.ID",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name, t0.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show students whose are at least two persons or people like, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1 t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "Highschooler Friend Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Friend Likes",
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            "Friend Likes"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I want to see which students have 2 Likes or more, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I want to see which students have 2 Likes or more, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t2.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select Likes.student_id",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Likes.student_id",
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Likes.student_id",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.ID",
            "select Highschooler.name, t0.c3",
            "select Likes.student_id, Likes.liked_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I want to see which students have 2 Likes or more, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Likes",
            "Highschooler Likes",
            "Friend Likes",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are the high schoolers and how many friends do they have?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE",
            "SELECT-FROM t0 t1"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are the high schoolers and how many friends do they have?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1, count(t1.c1)",
        "label": "select t0.c1, count(*)",
        "score": false,
        "real_pred": "select Highschooler.name, count(Friend.friend_id)",
        "real_label": "select Highschooler.name, count(*)",
        "topk_preds": [
            "select Highschooler.name, count(Friend.friend_id)",
            "select count(Friend.friend_id), Highschooler.name",
            "select Highschooler.name, count(*)",
            "select count(*), Highschooler.name",
            "select Highschooler.name, count(t1.c2)",
            "select count(Highschooler.name), Highschooler.name",
            "select count(t1.c2), Highschooler.name",
            "select Highschooler.name, count(distinct Friend.friend_id)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are the high schoolers and how many friends do they have?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which high schooler has the most friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which high schooler has the most friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name (Friend.student_id)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which high schooler has the most friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name the students that have two or more likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name the students that have two or more likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name, Likes.student_id",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, t0.c3",
            "select Highschooler.name (Highschooler.ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name the students that have two or more likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are students who like two or more students?., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are students who like two or more students?., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Likes.student_id",
            "select Highschooler.name, Highschooler.ID",
            "select Likes.liked_id",
            "select Highschooler.name, Likes.student_id",
            "select Highschooler.name, Highschooler.grade",
            "select Likes.student_id, Highschooler.name",
            "select Likes.liked_id, Highschooler.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are students who like two or more students?., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Likes",
            "Highschooler Likes",
            "Highschooler Friend Likes",
            "Friend Likes",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What students have 2 or more likes?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What students have 2 or more likes?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t2.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select Likes.student_id",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Likes.student_id",
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Likes.student_id",
            "select Highschooler.name, t0.c3",
            "select Highschooler.ID",
            "select Highschooler.name, Highschooler.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What students have 2 or more likes?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "Likes",
            "Friend Likes",
            "",
            "Highschooler Friend Likes",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show who's in high school and friend count., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM INTERSECT-SELECT-FROM",
            "SELECT-FROM-INTERSECT-SELECT-FROM",
            "SELECT-FROM-WHERE - COUNT(*)",
            "SELECT-FROM-WHERE t1.c1"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show who's in high school and friend count., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1, count(*)",
        "label": "select t0.c1, count(*)",
        "score": true,
        "real_pred": "select Highschooler.name, count(*)",
        "real_label": "select Highschooler.name, count(*)",
        "topk_preds": [
            "select Highschooler.name, count(*)",
            "select Highschooler.name, count(Friend.friend_id)",
            "select Highschooler.name, count(distinct Friend.friend_id)",
            "select distinct Highschooler.name, count(*)",
            "select distinct Highschooler.name, count(Friend.friend_id)",
            "select Friend.friend_id, Highschooler.name",
            "select Highschooler.name, count(t1.c2)",
            "select Highschooler.name, Friend.friend_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show who's in high school and friend count., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which students (without friends)?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which students (without friends)?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select Highschooler.ID",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.ID",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name",
            "select distinct Highschooler.ID",
            "select distinct Highschooler.ID, Highschooler.name",
            "select distinct Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select distinct Highschooler.name, Highschooler.ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which students (without friends)?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0 t1",
        "score": false,
        "real_pred": "Highschooler",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler",
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are the students without friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are the students without friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select distinct t0.c1",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select distinct Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select distinct Highschooler.name",
            "select Highschooler.name",
            "select Highschooler.ID, Highschooler.name",
            "select distinct Highschooler.ID, Highschooler.name",
            "select distinct Highschooler.name, Highschooler.ID",
            "select distinct Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are the students without friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "Highschooler",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which students don't have any friend?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EN-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which students don't have any friend?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c0, t0.c1",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select Highschooler.ID, Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name",
            "select Highschooler.ID",
            "select distinct Highschooler.ID, Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select distinct Highschooler.name",
            "select distinct Highschooler.ID",
            "select distinct Highschooler.name, Highschooler.ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which students don't have any friend?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are the students that have no friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-HAVE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-FROM-EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are the students that have no friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.grade",
            "select distinct Highschooler.name",
            "select Highschooler.ID, Highschooler.name, Highschooler.grade",
            "select distinct Highschooler.ID, Highschooler.name",
            "select distinct Highschooler.name, Highschooler.ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are the students that have no friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "Highschooler Friend Likes",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are all high school students that don't have friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are all high school students that don't have friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select distinct t0.c1",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select distinct Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select distinct Highschooler.name",
            "select Highschooler.name",
            "select distinct Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.ID, Highschooler.name",
            "select distinct Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.ID",
            "select distinct Highschooler.ID, Highschooler.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are all high school students that don't have friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are all students currently in grade ten?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are all students currently in grade ten?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select distinct t0.c1",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select distinct Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select distinct Highschooler.name",
            "select Highschooler.name",
            "select distinct Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.grade",
            "select distinct Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.ID, Highschooler.name",
            "select distinct Highschooler.name, t0.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are all students currently in grade ten?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name all high schoolers in Grade 10, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE.",
            "SELECT SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION/SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name all high schoolers in Grade 10, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select distinct Highschooler.name",
            "select Highschooler.ID, Highschooler.name",
            "select distinct Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name (or Highschooler.grade)",
            "select Highschooler.name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name all high schoolers in Grade 10, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who has 3 or more friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who has 3 or more friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, t1.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who has 3 or more friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old are the dogs that have been treated on average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM",
            "SELECT-FROM GROUPS-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM_GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old are the dogs that have been treated on average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select avg(t5.c6)",
        "label": "select avg(t5.c6)",
        "score": true,
        "real_pred": "select avg(Dogs.age)",
        "real_label": "select avg(Dogs.age)",
        "topk_preds": [
            "select avg(Dogs.age)",
            "select an avg(Dogs.age)",
            "select the avg(Dogs.age)",
            "select avg(Dogs.date_of_birth)",
            "select avg(Dogs.age)",
            "select avg(Dogs.age",
            "select avg(Dogs.age).",
            "select age(avg(Dogs.age)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old are the dogs that have been treated on average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "",
            "",
            "",
            "",
            "",
            "Dogs Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old on average are these dogs that have gone through some treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM",
            "SELECT-FROM-INTERSECT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old on average are these dogs that have gone through some treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select avg(t5.c6)",
        "label": "select avg(t5.c6)",
        "score": true,
        "real_pred": "select avg(Dogs.age)",
        "real_label": "select avg(Dogs.age)",
        "topk_preds": [
            "select avg(Dogs.age)",
            "select an avg(Dogs.age)",
            "select avg(Dogs.age)",
            "select the avg(Dogs.age)",
            "select avg(Dogs.age",
            "select avg(Dogs.date_of_birth)",
            "select  avg(Dogs.age)",
            "select Avg(Dogs.age)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old on average are these dogs that have gone through some treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Dogs Professionals Treatments",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Of dogs that have had treatment, how old are they on avergae?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Of dogs that have had treatment, how old are they on avergae?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t7.c1, avg(t5.c6)",
        "label": "select avg(t5.c6)",
        "score": false,
        "real_pred": "select Treatments.dog_id, avg(Dogs.age)",
        "real_label": "select avg(Dogs.age)",
        "topk_preds": [
            "select Treatments.dog_id, avg(Dogs.age)",
            "select Dogs.age, avg(Dogs.age)",
            "select Treatments.date_of_treatment, avg(Dogs.age)",
            "select Treatments.date_of_treatment",
            "select Dogs.dog_id, avg(Dogs.age)",
            "select Treatments.cost_of_treatment, avg(Dogs.age)",
            "select Treatments.treatment_type_code, avg(Dogs.age)",
            "select avg(Dogs.age)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Of dogs that have had treatment, how old are they on avergae?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Dogs Professionals Treatments",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The most uncommon dog of breeds and their treatments times of each., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The most uncommon dog of breeds and their treatments times of each., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c3, t7.c4",
        "label": "select t5.c5, t7.c4",
        "score": false,
        "real_pred": "select Dogs.breed_code, Treatments.date_of_treatment",
        "real_label": "select Dogs.name, Treatments.date_of_treatment",
        "topk_preds": [
            "select Dogs.breed_code, Treatments.date_of_treatment",
            "select Treatments.dog_id, Treatments.date_of_treatment",
            "select Dogs.breed_code, avg(Treatments.date_of_treatment)",
            "select Dogs.dog_id, Treatments.date_of_treatment",
            "select Dogs.breed_code, max(Treatments.date_of_treatment)",
            "select Dogs.owner_id, Treatments.date_of_treatment",
            "select Dogs.breed_code, min(Treatments.date_of_treatment)",
            "select Dogs.breed_code, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The most uncommon dog of breeds and their treatments times of each., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Breeds Dogs Treatments",
            "Charges Dogs Treatments",
            "Treatment_Types Dogs Treatments",
            "Sizes Dogs Treatments",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give us list of rarest breed of dogs which received treatment and their dates, too., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give us list of rarest breed of dogs which received treatment and their dates, too., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c3, t7.c4",
        "label": "select t5.c5, t7.c4",
        "score": false,
        "real_pred": "select Dogs.breed_code, Treatments.date_of_treatment",
        "real_label": "select Dogs.name, Treatments.date_of_treatment",
        "topk_preds": [
            "select Dogs.breed_code, Treatments.date_of_treatment",
            "select Dogs.dog_id, Dogs.breed_code, Treatments.date_of_treatment",
            "select Dogs.dog_id, Dogs.owner_id, Treatments.date_of_treatment",
            "select Dogs.owner_id, Treatments.date_of_treatment",
            "select rarest Dogs.breed_code, Treatments.date_of_treatment",
            "select t5.cbreed, Treatments.date_of_treatment",
            "select distinct Dogs.breed_code, Treatments.date_of_treatment",
            "select Dogs.dog_id, Treatments.date_of_treatment"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give us list of rarest breed of dogs which received treatment and their dates, too., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Breeds Dogs Treatments",
            "Charges Dogs Treatments",
            "Sizes Dogs Treatments",
            "Treatment_Types Dogs Treatments",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When did the dogs arrive and when did they leave for receiving treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-PROCESS-UNION-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-PROCESS-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When did the dogs arrive and when did they leave for receiving treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c10, t5.c12",
        "label": "select distinct t5.c10, t5.c12",
        "score": false,
        "real_pred": "select Dogs.date_arrived, Dogs.date_departed",
        "real_label": "select distinct Dogs.date_arrived, Dogs.date_departed",
        "topk_preds": [
            "select Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.date_departed",
            "select Treatments.cost_of_treatment, t7.c6",
            "select Treatments.date_of_treatment, Treatments.cost_of_treatment",
            "select Dogs.dog_id, Dogs.date_adopted",
            "select Dogs.weight, Dogs.date_departed",
            "select Dogs.owner_id, Dogs.date_departed",
            "select Treatments.cost_of_treatment, Treatments.dog_id2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When did the dogs arrive and when did they leave for receiving treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Dogs Professionals Treatments",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old are dogs that underwent treatment averagely?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM GROUPS-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old are dogs that underwent treatment averagely?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select avg(t5.c6)",
        "label": "select avg(t5.c6)",
        "score": true,
        "real_pred": "select avg(Dogs.age)",
        "real_label": "select avg(Dogs.age)",
        "topk_preds": [
            "select avg(Dogs.age)",
            "select an avg(Dogs.age)",
            "select avg(Dogs.age), Treatments.dog_id",
            "select avg(Dogs.age), Treatments.date_of_treatment",
            "select avg(Dogs.age), Treatments.professional_id",
            "select avg(Dogs.age), Treatments.treatment_type_code",
            "select the avg(Dogs.age)",
            "select avg(Dogs.age), t7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old are dogs that underwent treatment averagely?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Dogs Professionals Treatments",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old were dogs from which went through treatments on average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old were dogs from which went through treatments on average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select avg(t5.c6)",
        "label": "select avg(t5.c6)",
        "score": true,
        "real_pred": "select avg(Dogs.age)",
        "real_label": "select avg(Dogs.age)",
        "topk_preds": [
            "select avg(Dogs.age)",
            "select an avg(Dogs.age)",
            "select the avg(Dogs.age)",
            "select avg(Dogs.date_of_birth)",
            "select avg(Dogs.age",
            "select avg(Dogs.age)",
            "select avg(Dogs.age).",
            "select avg(Dogs.age),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old were dogs from which went through treatments on average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "",
            "",
            "",
            "",
            "",
            "Dogs Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old are dogs that go through treatment on average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM GROUPE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM GROUPS-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM/GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old are dogs that go through treatment on average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select avg(t5.c6)",
        "label": "select avg(t5.c6)",
        "score": true,
        "real_pred": "select avg(Dogs.age)",
        "real_label": "select avg(Dogs.age)",
        "topk_preds": [
            "select avg(Dogs.age)",
            "select an avg(Dogs.age)",
            "select the avg(Dogs.age)",
            "select avg(Dogs.date_of_birth)",
            "select avg(Dogs.age)",
            "select avg(Dogs.age",
            "select avg(Dogs.age),",
            "select avg(Dogs.age)."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old are dogs that go through treatment on average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Dogs Professionals Treatments",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the owner names and their emails in a state that starts containing North., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the owner names and their emails in a state that starts containing North., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t4.c1, t4.c2, t4.c7",
        "label": "select t4.c1, t4.c2, t4.c7",
        "score": true,
        "real_pred": "select Owners.first_name, Owners.last_name, Owners.email_address",
        "real_label": "select Owners.first_name, Owners.last_name, Owners.email_address",
        "topk_preds": [
            "select Owners.first_name, Owners.last_name, Owners.email_address",
            "select Owners.first_name, Owners.last_name, t4.c 7",
            "select Owners.first_name, Owners.last_name, t4.c-7",
            "select Owners.first_name, Owners.last_name, t4c7",
            "select Owners.first_name, Owners.last_name and Owners.email_address",
            "select Owners.first_name, Owners.last_name, c7",
            "select Owners.first_name, Owners.last_name, Owners.email_address",
            "select Owners.first_name, Owners.last_name, Owners.email_address."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the owner names and their emails in a state that starts containing North., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t4",
        "label": "t4",
        "score": true,
        "real_pred": "Owners",
        "real_label": "Owners",
        "topk_preds": [
            "Owners",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who has more dogs than anyone else, list their names and ids., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who has more dogs than anyone else, list their names and ids., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t4.c1, t4.c2, t5.c0",
        "label": "select t5.c1, t4.c1, t4.c2",
        "score": false,
        "real_pred": "select Owners.first_name, Owners.last_name, Dogs.dog_id",
        "real_label": "select Dogs.owner_id, Owners.first_name, Owners.last_name",
        "topk_preds": [
            "select Owners.first_name, Owners.last_name, Dogs.dog_id",
            "select Dogs.owner_id, Dogs.dog_id",
            "select Owners.first_name, Owners.last_name, Owners.owner_id",
            "select Dogs.abandoned_yn, Dogs.dog_id",
            "select Owners.first_name, Owners.last_name, Dogs.owner_id",
            "select Sizes.size_description, t2.c2, Dogs.dog_id",
            "select Owners.first_name, Owners.last_name, t5_c0",
            "select Dogs.abandoned_yn, Dogs.owner_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who has more dogs than anyone else, list their names and ids., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "Owners Dogs",
        "real_label": "Owners Dogs",
        "topk_preds": [
            "Owners Dogs",
            "Dogs",
            "Treatment_Types Owners Dogs",
            "Sizes Dogs",
            "Treatment_Types Dogs",
            "Breeds Owners Dogs",
            "Charges Dogs",
            "Sizes Owners Dogs"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When were dogs received, and when did they depart after treatment, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When were dogs received, and when did they depart after treatment, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t7.c4, t5.c12",
        "label": "select distinct t5.c10, t5.c12",
        "score": false,
        "real_pred": "select Treatments.date_of_treatment, Dogs.date_departed",
        "real_label": "select distinct Dogs.date_arrived, Dogs.date_departed",
        "topk_preds": [
            "select Treatments.date_of_treatment, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.date_departed",
            "select Treatments.treatment_id, Dogs.date_arrived, Dogs.date_departed",
            "select Treatments.cost_of_treatment, Treatments.dog_id2",
            "select Dogs.date_arrived, Dogs.date_departed",
            "select Treatments.treatment_type_code, Treatments.date_of_treatment",
            "select Treatments.dog_id, Treatments.professional_id",
            "select Treatments.treatment_id, Treatments.date_of_treatment"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When were dogs received, and when did they depart after treatment, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Dogs Professionals Treatments",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many years old are dogs on average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM INTERSECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many years old are dogs on average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select avg(t5.c6)",
        "label": "select avg(t5.c6)",
        "score": true,
        "real_pred": "select avg(Dogs.age)",
        "real_label": "select avg(Dogs.age)",
        "topk_preds": [
            "select avg(Dogs.age)",
            "select an avg(Dogs.age)",
            "select Avg(Dogs.age)",
            "select  avg(Dogs.age)",
            "select avg(Dogs.age)",
            "select avg(Dogs.date_of_birth)",
            "select \u0430vg(Dogs.age)",
            "select avg(Dogs.age)."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many years old are dogs on average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old are the dogs on average, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM.GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM INTERSECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old are the dogs on average, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select avg(t5.c6)",
        "label": "select avg(t5.c6)",
        "score": true,
        "real_pred": "select avg(Dogs.age)",
        "real_label": "select avg(Dogs.age)",
        "topk_preds": [
            "select avg(Dogs.age)",
            "select an avg(Dogs.age)",
            "select  avg(Dogs.age)",
            "select Avg(Dogs.age)",
            "select avg(Dogs.date_of_birth)",
            "select avg(Dogs.age).",
            "select avg(Dogs.age)",
            "select avg(Dogs.age),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old are the dogs on average, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: On average how old are the dogs?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM (GROUP BY-HAVING",
            "SELECT-FROM (Avg(t5.c6)",
            "SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: On average how old are the dogs?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select avg(t5.c6)",
        "label": "select avg(t5.c6)",
        "score": true,
        "real_pred": "select avg(Dogs.age)",
        "real_label": "select avg(Dogs.age)",
        "topk_preds": [
            "select avg(Dogs.age)",
            "select an avg(Dogs.age)",
            "select Avg(Dogs.age)",
            "select  avg(Dogs.age)",
            "select avg(Dogs.age)",
            "select avg(Dogs.date_of_birth)",
            "select avg(Dogs.age).",
            "select avg(Dogs.age),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: On average how old are the dogs?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When did dogs arrive and depart?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT.C10, SELECT.C12"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When did dogs arrive and depart?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c10, t5.c12",
        "label": "select t5.c10, t5.c12",
        "score": true,
        "real_pred": "select Dogs.date_arrived, Dogs.date_departed",
        "real_label": "select Dogs.date_arrived, Dogs.date_departed",
        "topk_preds": [
            "select Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.date_departed",
            "select Dogs.owner_id, Dogs.date_departed",
            "select Dogs.weight, Dogs.date_departed",
            "select Dogs.owner_id, Dogs.abandoned_yn",
            "select Dogs.age, Dogs.date_departed",
            "select Dogs.name, Dogs.date_departed",
            "select Dogs.date_of_birth, Dogs.date_departed"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When did dogs arrive and depart?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When all the dogs left and arrived., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When all the dogs left and arrived., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c12, t5.c10",
        "label": "select t5.c10, t5.c12",
        "score": false,
        "real_pred": "select Dogs.date_departed, Dogs.date_arrived",
        "real_label": "select Dogs.date_arrived, Dogs.date_departed",
        "topk_preds": [
            "select Dogs.date_departed, Dogs.date_arrived",
            "select Dogs.dog_id, Dogs.date_departed",
            "select Dogs.owner_id, Dogs.date_arrived",
            "select Dogs.date_adopted, Dogs.date_departed",
            "select Dogs.age, Dogs.date_arrived",
            "select Dogs.owner_id3, Dogs.date_arrived",
            "select Dogs.name, Dogs.date_arrived",
            "select Dogs.abandoned_yn, Dogs.date_arrived"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When all the dogs left and arrived., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old is the oldest dog?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old is the oldest dog?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select max(t5.c6)",
        "label": "select max(t5.c6)",
        "score": true,
        "real_pred": "select max(Dogs.age)",
        "real_label": "select max(Dogs.age)",
        "topk_preds": [
            "select max(Dogs.age)",
            "select Dogs.age",
            "select Dogs.dog_id, Dogs.age",
            "select Dogs.dog_id, max(Dogs.age)",
            "select Dogs.dog_id",
            "select Dogs.dog_id, Dogs.owner_id",
            "select Dogs.dog_id, Dogs.breed_code",
            "select Dogs.dog_id, Dogs.abandoned_yn"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old is the oldest dog?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When do dogs arrive and depart?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When do dogs arrive and depart?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c10, t5.c12",
        "label": "select t5.c10, t5.c12",
        "score": true,
        "real_pred": "select Dogs.date_arrived, Dogs.date_departed",
        "real_label": "select Dogs.date_arrived, Dogs.date_departed",
        "topk_preds": [
            "select Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.date_departed",
            "select Dogs.owner_id, Dogs.date_departed",
            "select Dogs.weight, Dogs.date_departed",
            "select Dogs.owner_id, Dogs.abandoned_yn",
            "select Dogs.age, Dogs.date_departed",
            "select Dogs.name, Dogs.date_departed",
            "select Dogs.date_of_birth, Dogs.date_departed"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When do dogs arrive and depart?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Tell me when were dogs came and left, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM t5.c10, SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM t5.c10, SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Tell me when were dogs came and left, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c10, t5.c12",
        "label": "select t5.c10, t5.c12",
        "score": true,
        "real_pred": "select Dogs.date_arrived, Dogs.date_departed",
        "real_label": "select Dogs.date_arrived, Dogs.date_departed",
        "topk_preds": [
            "select Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.date_departed",
            "select Dogs.weight, Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.weight, Dogs.date_departed",
            "select Dogs.owner_id, Dogs.date_departed",
            "select Dogs.date_arrived, Dogs.date_departed, Dogs.dog_id",
            "select Dogs.owner_id, Dogs.abandoned_yn",
            "select Dogs.gender, Dogs.weight"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Tell me when were dogs came and left, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When did dogs arrive and depart?., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT.C10, SELECT.C12"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When did dogs arrive and depart?., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c10, t5.c12",
        "label": "select t5.c10, t5.c12",
        "score": true,
        "real_pred": "select Dogs.date_arrived, Dogs.date_departed",
        "real_label": "select Dogs.date_arrived, Dogs.date_departed",
        "topk_preds": [
            "select Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.date_departed",
            "select Dogs.owner_id, Dogs.date_departed",
            "select Dogs.weight, Dogs.date_departed",
            "select Dogs.owner_id, Dogs.abandoned_yn",
            "select Dogs.age, Dogs.date_departed",
            "select t5.c 10, Dogs.date_departed",
            "select Dogs.name, Dogs.date_departed"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When did dogs arrive and depart?., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What day came and left each dog?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What day came and left each dog?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c10, t5.c12",
        "label": "select t5.c10, t5.c12",
        "score": true,
        "real_pred": "select Dogs.date_arrived, Dogs.date_departed",
        "real_label": "select Dogs.date_arrived, Dogs.date_departed",
        "topk_preds": [
            "select Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.date_adopted, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.owner_id, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.owner_id, Dogs.abandoned_yn",
            "select Dogs.dog_id, Dogs.owner_id3",
            "select Dogs.weight, Dogs.date_departed"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What day came and left each dog?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When did each dog arrive and depart?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-C10, SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When did each dog arrive and depart?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c10, t5.c12",
        "label": "select t5.c10, t5.c12",
        "score": true,
        "real_pred": "select Dogs.date_arrived, Dogs.date_departed",
        "real_label": "select Dogs.date_arrived, Dogs.date_departed",
        "topk_preds": [
            "select Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.date_adopted, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.owner_id, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.owner_id, Dogs.abandoned_yn",
            "select Dogs.owner_id, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.owner_id3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When did each dog arrive and depart?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old are dogs average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, avg(t5.c6)",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old are dogs average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select avg(t5.c6)",
        "label": "select avg(t5.c6)",
        "score": true,
        "real_pred": "select avg(Dogs.age)",
        "real_label": "select avg(Dogs.age)",
        "topk_preds": [
            "select avg(Dogs.age)",
            "select an avg(Dogs.age)",
            "select Avg(Dogs.age)",
            "select avg(Dogs.age)",
            "select  avg(Dogs.age)",
            "select avg(Dogs.date_of_birth)",
            "select avg(Dogs.age),",
            "select avg(Dogs.age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old are dogs average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old do dogs get on average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old do dogs get on average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select avg(t5.c6)",
        "label": "select avg(t5.c6)",
        "score": true,
        "real_pred": "select avg(Dogs.age)",
        "real_label": "select avg(Dogs.age)",
        "topk_preds": [
            "select avg(Dogs.age)",
            "select an avg(Dogs.age)",
            "select Avg(Dogs.age)",
            "select avg(Dogs.age).",
            "select  avg(Dogs.age)",
            "select avg(Dogs.age)",
            "select the avg(Dogs.age)",
            "select avg(Dogs.date_of_birth)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old do dogs get on average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old are dogs on average, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM.GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORSDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old are dogs on average, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select avg(t5.c6)",
        "label": "select avg(t5.c6)",
        "score": true,
        "real_pred": "select avg(Dogs.age)",
        "real_label": "select avg(Dogs.age)",
        "topk_preds": [
            "select avg(Dogs.age)",
            "select an avg(Dogs.age)",
            "select Avg(Dogs.age)",
            "select  avg(Dogs.age)",
            "select avg(Dogs.age)",
            "select avg(Dogs.date_of_birth)",
            "select avg(Dogs.age).",
            "select avg(Dogs.age),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old are dogs on average, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who operated a treatment that cost less than the average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who operated a treatment that cost less than the average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t7.c2",
        "label": "select distinct t6.c2, t6.c7",
        "score": false,
        "real_pred": "select Treatments.professional_id",
        "real_label": "select distinct Professionals.first_name, Professionals.last_name",
        "topk_preds": [
            "select Treatments.professional_id",
            "select Treatments.dog_id, Treatments.professional_id",
            "select Treatments.professional_id, Treatments.treatment_type_code",
            "select Owners.first_name, Owners.last_name",
            "select Charges.charge_type, Owners.last_name",
            "select t9.c1, t9.c2",
            "select t2.c2, t2.c3",
            "select t2.c2, t2.c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who operated a treatment that cost less than the average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t7",
        "label": "t6 t7",
        "score": false,
        "real_pred": "Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Treatments",
            "Owners Professionals Treatments",
            "Owners Treatments",
            "Dogs Professionals Treatments",
            "Breeds Owners Professionals Treatments",
            "Professionals Treatments",
            "Treatment_Types Owners Treatments",
            "Dogs Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who have operated treatments that cost less than the average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who have operated treatments that cost less than the average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t7.c2",
        "label": "select distinct t6.c2, t6.c7",
        "score": false,
        "real_pred": "select Treatments.professional_id",
        "real_label": "select distinct Professionals.first_name, Professionals.last_name",
        "topk_preds": [
            "select Treatments.professional_id",
            "select Treatments.professional_id, Treatments.treatment_type_code",
            "select Professionals.first_name, Professionals.street",
            "select Professionals.role_code, Professionals.first_name",
            "select Professionals.first_name, Professionals.first_name",
            "select professionals Treatments.professional_id, Treatments.treatment_type_code",
            "select t8.c2, t8.c3",
            "select Owners.first_name, Owners.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who have operated treatments that cost less than the average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t7",
        "label": "t6 t7",
        "score": false,
        "real_pred": "Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Treatments",
            "Dogs Professionals Treatments",
            "Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Breeds Professionals Treatments",
            "Dogs Treatments",
            "Charges Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What operators have operated a treatment that cost less than the average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What operators have operated a treatment that cost less than the average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t7.c2",
        "label": "select distinct t6.c2, t6.c7",
        "score": false,
        "real_pred": "select Treatments.professional_id",
        "real_label": "select distinct Professionals.first_name, Professionals.last_name",
        "topk_preds": [
            "select Treatments.professional_id",
            "select Treatments.professional_id, Treatments.treatment_type_code",
            "select Treatments.dog_id, Treatments.professional_id",
            "select t8.c2",
            "select t8.c2, Treatments.treatment_type_code",
            "select Treatments.professional_id, Treatments.dog_id",
            "select Treatments.dog_id",
            "select Treatments.professional_id (or Treatments.treatment_type_code)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What operators have operated a treatment that cost less than the average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t7",
        "label": "t6 t7",
        "score": false,
        "real_pred": "Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Treatments",
            "Dogs Professionals Treatments",
            "Dogs Treatments",
            "Breeds Treatments",
            "Professionals Treatments",
            "Charges Treatments",
            "",
            "Sizes Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old is the oldest dog?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old is the oldest dog?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select max(t5.c6)",
        "label": "select max(t5.c6)",
        "score": true,
        "real_pred": "select max(Dogs.age)",
        "real_label": "select max(Dogs.age)",
        "topk_preds": [
            "select max(Dogs.age)",
            "select Dogs.age",
            "select Dogs.dog_id, Dogs.age",
            "select Dogs.dog_id, max(Dogs.age)",
            "select Dogs.dog_id",
            "select Dogs.dog_id, Dogs.owner_id",
            "select Dogs.dog_id, Dogs.breed_code",
            "select Dogs.dog_id, Dogs.abandoned_yn"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old is the oldest dog?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What professionals have treated patients with costs that were below average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What professionals have treated patients with costs that were below average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c2",
        "label": "select distinct t6.c2, t6.c7",
        "score": false,
        "real_pred": "select Professionals.first_name",
        "real_label": "select distinct Professionals.first_name, Professionals.last_name",
        "topk_preds": [
            "select Professionals.first_name",
            "select Professionals.first_name, Professionals.last_name",
            "select distinct Professionals.first_name, Professionals.last_name",
            "select distinct Professionals.first_name",
            "select Professionals.role_code, Professionals.first_name",
            "select Professionals.role_code, Professionals.last_name",
            "select distinct Professionals.first_name, Professionals.street",
            "select Professionals.first_name, Professionals.street"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What professionals have treated patients with costs that were below average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Charges Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Breeds Professionals Treatments",
            "Sizes Treatments",
            "Charges Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who has treated with costs below average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who has treated with costs below average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select distinct t7.c2",
        "label": "select distinct t6.c2, t6.c7",
        "score": false,
        "real_pred": "select distinct Treatments.professional_id",
        "real_label": "select distinct Professionals.first_name, Professionals.last_name",
        "topk_preds": [
            "select distinct Treatments.professional_id",
            "select Treatments.professional_id",
            "select Treatments.professional_id, Treatments.treatment_type_code",
            "select distinct Treatments.professional_id, Treatments.treatment_type_code",
            "select t8.c1, t8.c2",
            "select Treatments.dog_id, Treatments.professional_id",
            "select distinct Treatments.dog_id, Treatments.professional_id",
            "select Professionals.role_code, Professionals.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who has treated with costs below average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t6 t7",
        "label": "t6 t7",
        "score": false,
        "real_pred": "Dogs Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Dogs Professionals Treatments",
            "Owners Dogs Professionals Treatments",
            "Owners Treatments",
            "Owners Professionals Treatments",
            "Professionals Treatments",
            "Dogs Treatments",
            "Owners Dogs Treatments",
            "Charges Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What breed have the most dogs, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What breed have the most dogs, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Breeds.breed_name",
        "real_label": "select Breeds.breed_name",
        "topk_preds": [
            "select Breeds.breed_name",
            "select Breeds.breed_name, Dogs.breed_code",
            "select Breeds.breed_code, Breeds.breed_name",
            "select Breeds.breed_name, Dogs.breed_code",
            "select Breeds.breed_name pour Dogs.breed_code",
            "select Breeds.breed_name (Dogs.breed_code)",
            "select Breeds.breed_name the Dogs.breed_code",
            "select Breeds.breed_name de Dogs.breed_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What breed have the most dogs, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t0 t5",
        "label": "t0 t5",
        "score": true,
        "real_pred": "Breeds Dogs",
        "real_label": "Breeds Dogs",
        "topk_preds": [
            "Breeds Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the most popular dog breed?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the most popular dog breed?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Breeds.breed_name",
        "real_label": "select Breeds.breed_name",
        "topk_preds": [
            "select Breeds.breed_name",
            "select Breeds.breed_name, Dogs.breed_code",
            "select Breeds.breed_code, Breeds.breed_name",
            "select Breeds.breed_name (Dogs.breed_code)",
            "select Breeds.breed_name, Dogs.breed_code",
            "select Breeds.breed_name, Dogs.abandoned_yn",
            "select Breeds.breed_name, Dogs.owner_id",
            "select Breeds.breed_name(Dogs.breed_code)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the most popular dog breed?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t0 t5",
        "label": "t0 t5",
        "score": true,
        "real_pred": "Breeds Dogs",
        "real_label": "Breeds Dogs",
        "topk_preds": [
            "Breeds Dogs",
            "Breeds Charges Dogs",
            "",
            "",
            "",
            "",
            "",
            "Charges Dogs"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For what breed most dogs have?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For what breed most dogs have?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Breeds.breed_name",
        "real_label": "select Breeds.breed_name",
        "topk_preds": [
            "select Breeds.breed_name",
            "select Breeds.breed_name, Dogs.breed_code",
            "select Breeds.breed_code, Breeds.breed_name",
            "select Breeds.breed_name, Dogs.breed_code, Dogs.size_code",
            "select Breeds.breed_name (synonymous Dogs.breed_code)",
            "select Breeds.breed_name (Dogs.breed_code)",
            "select Breeds.breed_name pour Dogs.breed_code",
            "select Breeds.breed_name, Dogs.breed_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For what breed most dogs have?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t0 t5",
        "label": "t0 t5",
        "score": true,
        "real_pred": "Breeds Dogs",
        "real_label": "Breeds Dogs",
        "topk_preds": [
            "Breeds Dogs",
            "Breeds Charges Dogs",
            "Breeds Treatment_Types Dogs",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show singers and the sales of songs belonging to each singer., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY TI1.C2, sum(t1.c3)",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY (ordinal-c2), sum(t1.c3)",
            "SELECT-FROM-GROUP BY."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show singers and the sales of songs belonging to each singer., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t1.c2, sum(t1.c3)",
        "label": "select t0.c1, sum(t1.c3)",
        "score": false,
        "real_pred": "select song.Singer_ID, sum(song.Sales)",
        "real_label": "select singer.Name, sum(song.Sales)",
        "topk_preds": [
            "select song.Singer_ID, sum(song.Sales)",
            "select singer.Name, sum(song.Sales)",
            "select song.Singer_ID, song.Sales",
            "select t2.c2, sum(song.Sales)",
            "select song.Singer_ID, summ(song.Sales)",
            "select song.Singer_ID, max(song.Sales)",
            "select t1.c 2, sum(song.Sales)",
            "select song.Singer_ID, sum(song.Sales),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show singers and the sales of songs belonging to each singer., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t0 t1",
        "score": false,
        "real_pred": "song",
        "real_label": "singer song",
        "topk_preds": [
            "song",
            "singer song",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How much did songs sell for singers?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-PUNION-SELECT-FROM",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How much did songs sell for singers?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select sum(t1.c3), t1.c2",
        "label": "select t0.c1, sum(t1.c3)",
        "score": false,
        "real_pred": "select sum(song.Sales), song.Singer_ID",
        "real_label": "select singer.Name, sum(song.Sales)",
        "topk_preds": [
            "select sum(song.Sales), song.Singer_ID",
            "select sum(song.Sales)",
            "select song.Sales",
            "select amount(song.Sales), song.Singer_ID",
            "select sum(song.Sales), singer.Name",
            "select sum(song.Sales), t2.c2",
            "select sum(song.Sales), song.Singer_ID.",
            "select sum(song.Sales), song.Singer_ID,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How much did songs sell for singers?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t0 t1",
        "score": false,
        "real_pred": "song",
        "real_label": "singer song",
        "topk_preds": [
            "song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which songs and singers are?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM/UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM (UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which songs and singers are?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t0.c1",
        "score": false,
        "real_pred": "select song.Title, song.Singer_ID",
        "real_label": "select song.Title, singer.Name",
        "topk_preds": [
            "select song.Title, song.Singer_ID",
            "select song.Title, singer.Name",
            "select song.Title, t01.c2",
            "select song.Title, song.Singer_ID",
            "select song.Title, t2.c2",
            "select song.Title, t1.c 2",
            "select t2.c1, song.Singer_ID",
            "select song.Title, song.Singer_ID."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which songs and singers are?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "song singer",
            "song",
            "",
            "",
            "",
            "song singer song"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What songs do they sing, and who are they?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What songs do they sing, and who are they?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t1.c1, t0.c1",
        "label": "select t1.c1, t0.c1",
        "score": true,
        "real_pred": "select song.Title, singer.Name",
        "real_label": "select song.Title, singer.Name",
        "topk_preds": [
            "select song.Title, singer.Name",
            "select t2.c1, singer.Name",
            "select song.Title, singer.Name",
            "select t01.c1, singer.Name",
            "select song.Title, song.Title",
            "select t3.c1, singer.Name",
            "select song.Title, t 0.c1",
            "select song.Title, singer.Birth_Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What songs do they sing, and who are they?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "song singer song",
            "",
            "",
            "song singer",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What song titles and singers are there?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM (UNION-SELECT-FROM",
            "SELECT.c1, SELECT.c2",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT.c1, SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What song titles and singers are there?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t0.c1",
        "score": false,
        "real_pred": "select song.Title, song.Singer_ID",
        "real_label": "select song.Title, singer.Name",
        "topk_preds": [
            "select song.Title, song.Singer_ID",
            "select song.Title, song.Singer_ID, song.Sales",
            "select song.Title, song.Singer_ID, song.Song_ID",
            "select distinct song.Title, song.Singer_ID",
            "select song.Title, t1.c 2",
            "select song.Title, t1.1.c2",
            "select song.Title, t01.c2",
            "select song.Title, song.Singer_ID, max(song.Sales)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What song titles and singers are there?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t0 t1",
        "score": false,
        "real_pred": "song",
        "real_label": "singer song",
        "topk_preds": [
            "song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the songs titles and singers?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM (UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the songs titles and singers?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t0.c1",
        "score": false,
        "real_pred": "select song.Title, song.Singer_ID",
        "real_label": "select song.Title, singer.Name",
        "topk_preds": [
            "select song.Title, song.Singer_ID",
            "select song.Title, song.Singer_ID, song.Sales",
            "select song.Title, song.Singer_ID, song.Song_ID",
            "select song.Title.c1, song.Singer_ID",
            "select song.Title, song.Singer_ID,",
            "select song.Title, t1.1.c2",
            "select song.Title, t01.c2",
            "select song.Title, t1.c 2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the songs titles and singers?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t0 t1",
        "score": false,
        "real_pred": "song",
        "real_label": "singer song",
        "topk_preds": [
            "song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are songs' titles and singers?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM (UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM (SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are songs' titles and singers?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t0.c1",
        "score": false,
        "real_pred": "select song.Title, song.Singer_ID",
        "real_label": "select song.Title, singer.Name",
        "topk_preds": [
            "select song.Title, song.Singer_ID",
            "select song.Title, song.Singer_ID, song.Sales",
            "select song.Title, song.Singer_ID, song.Song_ID",
            "select song.Title, song.Singer_ID (refers to song.Song_ID)",
            "select song.Title, t01.c2",
            "select song.Title, t1.1.c2",
            "select song.Title, song.Singer_ID (single-song.Song_ID)",
            "select song.Title, song.Singer_ID,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are songs' titles and singers?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t0 t1",
        "score": false,
        "real_pred": "song",
        "real_label": "singer song",
        "topk_preds": [
            "song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show singers list in increasing order of net work., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY t0",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY (t0.c1)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show singers list in increasing order of net work., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c3",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select singer.Name, singer.Net_Worth_Millions",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name",
            "select singer.Singer_ID, singer.Name",
            "select singer.Singer_ID, singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, singer.Net_Worth_Millions, singer.Citizenship",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name and singer.Net_Worth_Millions",
            "select singer.Name, singer.Net_Worth_Millions,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show singers list in increasing order of net work., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are the singers that are not french citizens?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are the singers that are not french citizens?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select distinct singer.Name",
            "select singer.Name, singer.Citizenship",
            "select singer.Singer_ID, singer.Name",
            "select distinct singer.Name, singer.Citizenship",
            "select singer.Name, singer.Birth_Year",
            "select distinct singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Net_Worth_Millions"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are the singers that are not french citizens?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What non-French citizens were singers, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What non-French citizens were singers, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select distinct t0.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select distinct singer.Singer_ID",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select distinct singer.Singer_ID",
            "select distinct singer.Name",
            "select distinct singer.Name, singer.Birth_Year",
            "select count(*)",
            "select distinct singer.Name, singer.Citizenship",
            "select distinct singer.Citizenship",
            "select singer.Citizenship",
            "select distinct singer.Name, singer.Net_Worth_Millions"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What non-French citizens were singers, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which singers don\u2019t have French citizenship?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE.",
            "SELECT-FROM-EXCEPT-SELECT-FROM -WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which singers don\u2019t have French citizenship?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Singer_ID",
            "select distinct singer.Name",
            "select singer.Name, singer.Citizenship",
            "select singer.Name, singer.Birth_Year",
            "select distinct singer.Name, singer.Birth_Year",
            "select distinct singer.Name, singer.Citizenship",
            "select singer.Name, singer.Net_Worth_Millions"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which singers don\u2019t have French citizenship?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What singers are known as \"sellers more than 300000\"?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What singers are known as \"sellers more than 300000\"?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select distinct t0.c1",
        "score": false,
        "real_pred": "select singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Singer_ID",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, t0.c6",
            "select singer.Name, song.Singer_ID",
            "select singer.Name, t0.c7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What singers are known as \"sellers more than 300000\"?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "singer",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: list singers whose songs have sold more than 300000., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: list singers whose songs have sold more than 300000., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t1.c2",
        "label": "select distinct t0.c1",
        "score": false,
        "real_pred": "select song.Singer_ID",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select song.Singer_ID",
            "select singer.Name",
            "select song.Singer_ID, singer.Name",
            "select singer.Name, song.Singer_ID",
            "select singer.Name, singer.Birth_Year",
            "select song.Singer_ID, song.Title",
            "select t2.c2",
            "select singer.Name, singer.Net_Worth_Millions"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: list singers whose songs have sold more than 300000., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t0 t1",
        "score": false,
        "real_pred": "song",
        "real_label": "singer song",
        "topk_preds": [
            "song",
            "singer song",
            "",
            "",
            "",
            "",
            "song singer song",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which singers have songs with sales more than 300000?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which singers have songs with sales more than 300000?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select distinct t0.c1",
        "score": false,
        "real_pred": "select singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select song.Singer_ID",
            "select singer.Name, song.Singer_ID",
            "select singer.Name, singer.Birth_Year",
            "select t2.c2",
            "select singer.Name, singer.Singer_ID",
            "select distinct song.Singer_ID",
            "select distinct singer.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which singers have songs with sales more than 300000?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "song",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What singer has songs sold more than 300000?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What singer has songs sold more than 300000?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select distinct t0.c1",
        "score": false,
        "real_pred": "select singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select song.Singer_ID",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Singer_ID",
            "select singer.Name song.Singer_ID",
            "select singer.Name de song.Singer_ID",
            "select singer.Name, singer.Net_Worth_Millions"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What singer has songs sold more than 300000?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which singer has the most money?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which singer has the most money?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, singer.Birth_Year",
            "select singer.Singer_ID, t0.c 1",
            "select singer.Singer_ID, singer.Name,",
            "select singer.Name (singer.Singer_ID)",
            "select singer.Name [singer.Singer_ID]"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which singer has the most money?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which singer has the highest net worth, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which singer has the highest net worth, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Singer_ID, singer.Name, singer.Net_Worth_Millions",
            "select singer.Singer_ID, singer.Name - singer.Net_Worth_Millions",
            "select singer.Name, singer.Net_Worth_Millions, singer.Citizenship",
            "select singer.Singer_ID, singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, singer.Birth_Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which singer has the highest net worth, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which singer has the highest net worth?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which singer has the highest net worth?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Singer_ID, singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, singer.Net_Worth_Millions, singer.Citizenship",
            "select singer.Name, singer.Birth_Year",
            "select singer.Singer_ID, singer.Name (ORDER BY-LIMIT)",
            "select singer.Singer_ID, singer.Name - singer.Net_Worth_Millions"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which singer has the highest net worth?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which is the singer with the most money?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which is the singer with the most money?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name (singer.Net_Worth_Millions)",
            "select singer.Name [singer.Singer_ID]",
            "select singer.Singer_ID, t0.c 1",
            "select singer.Name (singer.Singer_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which is the singer with the most money?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What singers were born in the year 1948 or 1949?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What singers were born in the year 1948 or 1949?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Birth_Year",
            "select singer.Singer_ID",
            "select distinct singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select distinct singer.Name, singer.Birth_Year",
            "select singer.Name ou singer.Birth_Year",
            "select singer.Name or singer.Birth_Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What singers were born in the year 1948 or 1949?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What singers were born in 1948 or 1949?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What singers were born in 1948 or 1949?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Birth_Year",
            "select singer.Singer_ID",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, singer.Singer_ID",
            "select singer.Name, t0.c6",
            "select distinct singer.Name",
            "select singer.Name ou singer.Birth_Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What singers were born in 1948 or 1949?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Of which singers were born either 1948 or 1949?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Of which singers were born either 1948 or 1949?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select count(*)",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select count(*)",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select count(*)",
            "select singer.Name",
            "select singer.Singer_ID",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Singer_ID",
            "select distinct singer.Name",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Net_Worth_Millions"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Of which singers were born either 1948 or 1949?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which singers were born in 1948 or 1949?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which singers were born in 1948 or 1949?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Birth_Year",
            "select singer.Singer_ID",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, singer.Singer_ID",
            "select singer.Name, t0.c6",
            "select distinct singer.Name",
            "select singer.Name ou singer.Birth_Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which singers were born in 1948 or 1949?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show singers whose country isn't France, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show singers whose country isn't France, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Singer_ID",
            "select singer.Name, singer.Citizenship",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Singer_ID",
            "select singer.Name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show singers whose country isn't France, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are singers that do not have French citizenship?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are singers that do not have French citizenship?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Citizenship",
            "select distinct singer.Name",
            "select singer.Singer_ID, singer.Name",
            "select distinct singer.Name, singer.Citizenship",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Net_Worth_Millions",
            "select distinct singer.Name, singer.Birth_Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are singers that do not have French citizenship?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all the singers who are not French., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all the singers who are not French., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select distinct t0.c1",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select distinct singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select distinct singer.Name",
            "select singer.Name",
            "select distinct singer.Name, singer.Citizenship",
            "select distinct singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Citizenship",
            "select distinct singer.Name, singer.Net_Worth_Millions",
            "select distinct singer.Name, t0.c6",
            "select distinct singer.Name, t0.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all the singers who are not French., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List singers from whose citizenship is not France, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List singers from whose citizenship is not France, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Singer_ID",
            "select singer.Name, singer.Citizenship",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Net_Worth_Millions",
            "select distinct singer.Name, singer.Birth_Year",
            "select singer.Singer_ID, singer.Name",
            "select distinct singer.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List singers from whose citizenship is not France, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who sings? Their nationality is not France., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who sings? Their nationality is not France., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Citizenship",
            "select singer.Singer_ID, singer.Name",
            "select distinct singer.Name",
            "select distinct singer.Name, singer.Citizenship",
            "select singer.Name (not singer.Citizenship)",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name ou singer.Birth_Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who sings? Their nationality is not France., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List singers who have no songs., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List singers who have no songs., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Singer_ID",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, song.Singer_ID",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name (singer.Singer_ID)",
            "select singer.Name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List singers who have no songs., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "singer song",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List singers who don't have any songs., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List singers who don't have any songs., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Singer_ID",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, song.Singer_ID",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, t0.c6",
            "select singer.Name (singer.Singer_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List singers who don't have any songs., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "singer song",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What singer does not have any song?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHICH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What singer does not have any song?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Singer_ID",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name (singer.Singer_ID)",
            "select singer.Name, song.Title",
            "select singer.Name, t2.c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What singer does not have any song?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "singer song",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which singer have no songs., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-BY-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which singer have no songs., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Singer_ID",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, song.Title",
            "select singer.Name (singer.Singer_ID)",
            "select singer.Name, t2.c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which singer have no songs., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "singer song",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which singers were born in either 1949 or 1948?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which singers were born in either 1949 or 1948?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Birth_Year",
            "select singer.Singer_ID",
            "select singer.Name, singer.Singer_ID",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name ou singer.Birth_Year",
            "select singer.Name, t0.c6",
            "select singer.Name or singer.Birth_Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which singers were born in either 1949 or 1948?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which singers were born in 1948 or 1949?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which singers were born in 1948 or 1949?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Birth_Year",
            "select singer.Singer_ID",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, singer.Singer_ID",
            "select singer.Name, t0.c6",
            "select distinct singer.Name",
            "select singer.Name ou singer.Birth_Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which singers were born in 1948 or 1949?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who were the singers whose birthyear is either 1948 or 1949?., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who were the singers whose birthyear is either 1948 or 1949?., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Birth_Year",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Singer_ID",
            "select singer.Name, singer.Net_Worth_Millions",
            "select distinct singer.Name",
            "select singer.Name, t0.c6",
            "select singer.Name, singer.Citizenship"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who were the singers whose birthyear is either 1948 or 1949?., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which singers have more than one song?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which singers have more than one song?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select singer.Singer_ID, singer.Name",
            "select song.Title, singer.Name",
            "select singer.Name, max(song.Singer_ID)",
            "select song.Singer_ID, singer.Name",
            "select singer.Name, count(*)",
            "select singer.Name, song.Title"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which singers have more than one song?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are singers that have more than one song?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are singers that have more than one song?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select singer.Name, singer.Singer_ID",
            "select singer.Name, song.Title",
            "select singer.Name, singer.Birth_Year",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name (singer.Singer_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are singers that have more than one song?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which singer is the most valuable?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which singer is the most valuable?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, singer.Birth_Year",
            "select singer.Singer_ID, singer.Name,",
            "select singer.Singer_ID, t0.c 1",
            "select singer.Name (singer.Net_Worth_Millions)",
            "select singer.Name, singer.Net_Worth_Millions"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which singer is the most valuable?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who is the most valuable singer?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who is the most valuable singer?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Net_Worth_Millions, singer.Citizenship",
            "select singer.Singer_ID, singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, singer.Net_Worth_Millions, singer.Citizenship",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name the, singer.Net_Worth_Millions"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who is the most valuable singer?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "singer song",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What houses or apartments are there with more than one room?, database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What houses or apartments are there with more than one room?, database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "select t3.c4",
        "label": "select t3.c4",
        "score": true,
        "real_pred": "select Properties.property_name",
        "real_label": "select Properties.property_name",
        "topk_preds": [
            "select Properties.property_name",
            "select Properties.property_name, Properties.property_address",
            "select Properties.property_name ou Properties.property_address",
            "select Properties.property_address, Properties.room_count",
            "select Properties.property_name, Properties.room_count",
            "select Properties.property_name or Properties.property_address",
            "select Properties.property_name oder Properties.property_address",
            "select Properties.property_name (or Properties.property_address)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What houses or apartments are there with more than one room?, database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Properties",
        "real_label": "Properties",
        "topk_preds": [
            "Properties",
            "",
            "",
            "",
            "",
            "",
            "Other_Available_Features Properties",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What properties are houses or apartments with more than 1 room?., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What properties are houses or apartments with more than 1 room?., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "select t3.c4",
        "label": "select t3.c4",
        "score": true,
        "real_pred": "select Properties.property_name",
        "real_label": "select Properties.property_name",
        "topk_preds": [
            "select Properties.property_name",
            "select Properties.property_name, Properties.property_address",
            "select Properties.property_name, Properties.room_count",
            "select Properties.property_name, Properties.property_address, Properties.room_count",
            "select Properties.property_name, Properties.property_address.c5",
            "select Properties.property_name, Properties.property_address.c6",
            "select Properties.property_name, Properties.room_count, Properties.property_id",
            "select Properties.property_name, Properties.buyer_offered_price"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What properties are houses or apartments with more than 1 room?., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Properties",
        "real_label": "Properties",
        "topk_preds": [
            "Properties",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Feature Name of what is AirCon?, database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code, c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name (AirCon), c3: feature_description). t3: properties(c0: property_id, c1: property_type_code, c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Feature Name of what is AirCon?, database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code, c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name (AirCon), c3: feature_description). t3: properties(c0: property_id, c1: property_type_code, c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "select t2.c2",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select Other_Available_Features.feature_name",
        "real_label": "select Ref_Feature_Types.feature_type_name",
        "topk_preds": [
            "select Other_Available_Features.feature_name",
            "select Other_Available_Features.feature_id, Other_Available_Features.feature_name",
            "select Other_Available_Features.feature_name, Other_Available_Features.feature_description",
            "select Other_Available_Features.feature_name, Other_Available_Features.feature_type_code",
            "select Other_Available_Features.feature_id, Other_Available_Features.feature_type_code",
            "select Other_Available_Features.feature_name(Other_Available_Features.feature_description)",
            "select Other_Available_Features.feature_name (Other_Available_Features.feature_description)",
            "select Other_Available_Features.feature_name, Other_Available_Features.feature_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Feature Name of what is AirCon?, database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code, c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name (AirCon), c3: feature_description). t3: properties(c0: property_id, c1: property_type_code, c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "Other_Available_Features",
        "real_label": "Ref_Feature_Types Other_Available_Features",
        "topk_preds": [
            "Other_Available_Features",
            "Ref_Feature_Types Other_Available_Features",
            "Ref_Feature_Types Ref_Property_Types Other_Available_Features",
            "Ref_Property_Types Other_Available_Features",
            "",
            "",
            "Other_Available_Features Properties",
            ""
        ]
    }
]