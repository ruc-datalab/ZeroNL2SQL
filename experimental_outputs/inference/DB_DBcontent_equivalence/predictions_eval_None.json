[
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show name, country, age for all singers ordered by age from the oldest to the youngest., database: Database: concert_singer_0. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: age, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2, t1.c3",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2, t1.c3, t1.c6",
            "SELECT-FROM-ORDER BY t1.c1, t1.c3, t1.c6",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2, t1.c3, t1.c6",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2, t1.c3, t1.c6",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2, t1.c3 and t1.c6",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2, t1.c3 - t1.c6"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show name, country, age for all singers ordered by age from the oldest to the youngest., database: Database: concert_singer_0. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: age, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2, t1.c3, t1.c6",
        "label": "select t1.c1, t1.c2, t1.c3, t1.c6",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name, singer.Country, singer.Age",
        "real_label": "select singer.first_name, singer.last_name, singer.Country, singer.Age",
        "topk_preds": [
            "select singer.first_name, singer.last_name, singer.Country, singer.Age",
            "select singer.first_name, singer.Country, singer.Age",
            "select singer.first_name, singer.last_name, singer.Country",
            "select singer.first_name, singer.last_name, singer.Country, singer.Age",
            "select singer.first_name, singer.last_name., singer.Country, singer.Age",
            "select singer.first_name, singer.last_name, singer.Country, singer.Age",
            "select singer.first_name, singer.last_name, singer.Country, singer.Age",
            "select singer.first_name, singer.last_name, singer.Country, singer.Age)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show name, country, age for all singers ordered by age from the oldest to the youngest., database: Database: concert_singer_0. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: age, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names, countries, and ages for every singer in descending order of age?, database: Database: concert_singer_0. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: age, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2, t1.c3, t1.c6",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2, t1.c3",
            "SELECT-FROM-ORDER BY (t1.c1, t1.c2, t1.c3, t1.c6",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2, t1.c3 and t1.c6",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2, t1.c3, t1.c6",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2, t1.c3 und t1.c6",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names, countries, and ages for every singer in descending order of age?, database: Database: concert_singer_0. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: age, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2, t1.c3, t1.c6",
        "label": "select t1.c1, t1.c2, t1.c3, t1.c6",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name, singer.Country, singer.Age",
        "real_label": "select singer.first_name, singer.last_name, singer.Country, singer.Age",
        "topk_preds": [
            "select singer.first_name, singer.last_name, singer.Country, singer.Age",
            "select singer.first_name, singer.last_name, singer.Country, singer.Age",
            "select singer.first_name, singer.last_name, singer.Country, singer.Age",
            "select singer.first_name, singer.last_name, singer.Country, singer.Age",
            "select singer.first_name.c1, singer.last_name, singer.Country, singer.Age",
            "select singer.first_name, singer.last_name, singer.Country",
            "select singer.first_name, singer.last_name., singer.Country, singer.Age",
            "select singer.first_name, singer.last_name, singer.Country & singer.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names, countries, and ages for every singer in descending order of age?, database: Database: concert_singer_0. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: age, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List singer names and number of concerts for each singer., database: Database: concert_singer_0. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: age, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY t1.c1, t1.c2, count(*)",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY t1. C1, t1.c2, count(*)",
            "SELECT-FROM-GROUP BY t1.C1, t1.c2, count(*)",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-GROUP BY t1.c1, t1.c2, counts(*)",
            "SELECT-FROM-GAGGER-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List singer names and number of concerts for each singer., database: Database: concert_singer_0. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: age, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2, count(*)",
        "label": "select t1.c1, t1.c2, count(*)",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name, count(*)",
        "real_label": "select singer.first_name, singer.last_name, count(*)",
        "topk_preds": [
            "select singer.first_name, singer.last_name, count(*)",
            "select singer.first_name, singer.last_name, count(*), singer.Singer_ID",
            "select singer.first_name, singer.last_name, count(*),",
            "select singer.first_name, singer.last_name, count(*), concert.concert_ID",
            "select singer.first_name, singer.last_name, count(*), concert.Stadium_ID",
            "select singer.first_name, singer.last_name, count(*), concert.concert_Name",
            "select singer.first_name, singer.last_name, count(*), singer_in_concert.Singer_ID",
            "select singer.first_name, singer.last_name, counts(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List singer names and number of concerts for each singer., database: Database: concert_singer_0. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: age, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1 t3",
        "label": "t1 t3",
        "score": true,
        "real_pred": "singer singer_in_concert",
        "real_label": "singer singer_in_concert",
        "topk_preds": [
            "singer singer_in_concert",
            "singer concert singer_in_concert",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the singers and number of concerts for each person?, database: Database: concert_singer_0. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: age, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY (t1.c1, t1.c2, count(*)",
            "SELECT-FROM-GROUP BY (t1.c1), count(*)",
            "SELECT-FROM-GEOGRAPHY-GROUP BY",
            "SELECT-FROM-GROUP BY (t1.c1) et count(*)",
            "SELECT-FROM-GAGGER-GROUP BY",
            "SELECT-FROM-GROUPS-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the singers and number of concerts for each person?, database: Database: concert_singer_0. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: age, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2, count(*)",
        "label": "select t1.c1, t1.c2, count(*)",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name, count(*)",
        "real_label": "select singer.first_name, singer.last_name, count(*)",
        "topk_preds": [
            "select singer.first_name, singer.last_name, count(*)",
            "select singer.first_name, singer.last_name, count(*), singer.Singer_ID",
            "select singer.first_name, singer.last_name, count(*),",
            "select singer.first_name, singer.last_name, count(*), concert.Stadium_ID",
            "select singer.first_name, singer.last_name, count(*), singer.gender",
            "select singer.first_name, singer.last_name, count(*), concert.concert_ID",
            "select singer.first_name, singer.last_name, count(*), singer.Country",
            "select singer.first_name, singer.last_name, counts(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the singers and number of concerts for each person?, database: Database: concert_singer_0. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: age, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1 t2 t3",
        "label": "t1 t3",
        "score": false,
        "real_pred": "singer concert singer_in_concert",
        "real_label": "singer singer_in_concert",
        "topk_preds": [
            "singer concert singer_in_concert",
            "singer singer_in_concert",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all singer names in concerts in year 2014., database: Database: concert_singer_0. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: age, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all singer names in concerts in year 2014., database: Database: concert_singer_0. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: age, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name",
        "real_label": "select singer.first_name, singer.last_name",
        "topk_preds": [
            "select singer.first_name, singer.last_name",
            "select singer.first_name, singer.last_name, singer.gender",
            "select singer.first_name, singer.last_name, singer.Singer_ID",
            "select singer.first_name, singer.last_name, singer.Age",
            "select singer.first_name, singer.last_name, singer.Country",
            "select singer.first_name, singer.last_name, singer.Song_release_year",
            "select distinct singer.first_name, singer.last_name",
            "select singer.first_name, singer.last_name, singer.Song_Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all singer names in concerts in year 2014., database: Database: concert_singer_0. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: age, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1 t2 t3",
        "label": "t1 t2 t3",
        "score": true,
        "real_pred": "singer concert singer_in_concert",
        "real_label": "singer concert singer_in_concert",
        "topk_preds": [
            "singer concert singer_in_concert",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the singers who performed in a concert in 2014?, database: Database: concert_singer_0. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: age, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-C1, t1.c2",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the singers who performed in a concert in 2014?, database: Database: concert_singer_0. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: age, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name",
        "real_label": "select singer.first_name, singer.last_name",
        "topk_preds": [
            "select singer.first_name, singer.last_name",
            "select distinct singer.first_name, singer.last_name",
            "select singer.first_name, singer.last_name, singer.Age",
            "select singer.first_name, singer.last_name, singer.gender",
            "select singer_in_concert.Singer_ID, singer.last_name",
            "select the singer.first_name, singer.last_name",
            "select singer.first_name, singer.last_name, singer.Song_release_year",
            "select singer.first_name, singer.last_name, singer.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the singers who performed in a concert in 2014?, database: Database: concert_singer_0. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: age, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1 t2 t3",
        "label": "t1 t2 t3",
        "score": true,
        "real_pred": "singer concert singer_in_concert",
        "real_label": "singer concert singer_in_concert",
        "topk_preds": [
            "singer concert singer_in_concert",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: what is the name and nation of the singer who have a song having 'Hey' in its name?, database: Database: concert_singer_0. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: age, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C1, t1.c2, t1.c3",
            "SELECT-FROM-WHERE-C1, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: what is the name and nation of the singer who have a song having 'Hey' in its name?, database: Database: concert_singer_0. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: age, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2, t1.c3",
        "label": "select t1.c1, t1.c2, t1.c3",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name, singer.Country",
        "real_label": "select singer.first_name, singer.last_name, singer.Country",
        "topk_preds": [
            "select singer.first_name, singer.last_name, singer.Country",
            "select singer.first_name, singer.last_name, singer.Country, singer.Song_Name",
            "select singer.first_name, singer.last_name, singer.first_name, singer.Country",
            "select singer.first_name, singer.last_name",
            "select singer.first_name, singer.last_name, t1.c 3",
            "select singer.first_name, singer.last_name, singer.Country, singer.gender",
            "select singer.first_name, singer.last_name, singer.Country, singer.Singer_ID",
            "select singer.first_name, singer.last_name & singer.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: what is the name and nation of the singer who have a song having 'Hey' in its name?, database: Database: concert_singer_0. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: age, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name and country of origin of every singer who has a song with the word 'Hey' in its title?, database: Database: concert_singer_0. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: age, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C1, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name and country of origin of every singer who has a song with the word 'Hey' in its title?, database: Database: concert_singer_0. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: age, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2, t1.c3",
        "label": "select t1.c1, t1.c2, t1.c3",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name, singer.Country",
        "real_label": "select singer.first_name, singer.last_name, singer.Country",
        "topk_preds": [
            "select singer.first_name, singer.last_name, singer.Country",
            "select singer.first_name, singer.last_name",
            "select singer.first_name, singer.last_name, singer.Country, singer.Singer_ID",
            "select distinct singer.first_name, singer.last_name, singer.Country",
            "select singer.first_name, singer.last_name, t1.c 3",
            "select singer.first_name, singer.last_name, singer.Country, singer.Song_Name",
            "select singer.first_name, singer.last_name & singer.Country",
            "select singer.first_name, singer.last_name, singer.Country,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name and country of origin of every singer who has a song with the word 'Hey' in its title?, database: Database: concert_singer_0. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: age, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the name and the release year of the song by the youngest singer., database: Database: concert_singer_1. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: birthyear, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the name and the release year of the song by the youngest singer., database: Database: concert_singer_1. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: birthyear, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c3, t1.c4",
        "label": "select t1.c3, t1.c4",
        "score": true,
        "real_pred": "select singer.Song_Name, singer.Song_release_year",
        "real_label": "select singer.Song_Name, singer.Song_release_year",
        "topk_preds": [
            "select singer.Song_Name, singer.Song_release_year",
            "select singer.Country, singer.Song_release_year",
            "select singer.Song_Name, t1.1.c4",
            "select singer.Name, singer.Song_release_year",
            "select singer.Song_Name), singer.Song_release_year",
            "select singer.Song_Name, singer.Song_release_year.",
            "select singer.Song_Name, t01.c4",
            "select singer.Song_Name, singer.Song_release_year,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the name and the release year of the song by the youngest singer., database: Database: concert_singer_1. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: birthyear, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names and release years for all the songs of the youngest singer?, database: Database: concert_singer_1. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: birthyear, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names and release years for all the songs of the youngest singer?, database: Database: concert_singer_1. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: birthyear, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c3, t1.c4",
        "label": "select t1.c3, t1.c4",
        "score": true,
        "real_pred": "select singer.Song_Name, singer.Song_release_year",
        "real_label": "select singer.Song_Name, singer.Song_release_year",
        "topk_preds": [
            "select singer.Song_Name, singer.Song_release_year",
            "select singer.Country, singer.Song_release_year",
            "select singer.Song_Name, t1.1.c4",
            "select singer.Song_Name), singer.Song_release_year",
            "select singer.Song_Name, singer.Country",
            "select singer.Song_Name, singer.Song_release_year.",
            "select singer.Song_Name, singer.Song_release_year,",
            "select singer.Song_Name, singer.Song_release_year,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names and release years for all the songs of the youngest singer?, database: Database: concert_singer_1. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: birthyear, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all song names by singers above the average age., database: Database: concert_singer_1. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: birthyear, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SQL-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all song names by singers above the average age., database: Database: concert_singer_1. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: birthyear, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select singer.Song_Name",
        "real_label": "select singer.Song_Name",
        "topk_preds": [
            "select singer.Song_Name",
            "select singer.Song_Name, singer.Song_release_year",
            "select singer.Song_Name, singer.Is_male",
            "select singer.Song_Name, singer.birthyear",
            "select singer.Song_Name, singer.Country",
            "select singer.Song_Name, t1.c7",
            "select singer.Song_Name (singer.Song_release_year)",
            "select singer.Song_Name del.icio.us"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all song names by singers above the average age., database: Database: concert_singer_1. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: birthyear, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are all the song names by singers who are older than average?, database: Database: concert_singer_1. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: birthyear, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are all the song names by singers who are older than average?, database: Database: concert_singer_1. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: birthyear, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select singer.Song_Name",
        "real_label": "select singer.Song_Name",
        "topk_preds": [
            "select singer.Song_Name",
            "select singer.Song_Name, singer.Is_male",
            "select singer.Song_Name, singer.Song_release_year",
            "select singer.Song_Name, singer.birthyear",
            "select singer.Song_Name, singer.Country",
            "select distinct singer.Song_Name",
            "select singer.Song_Name, t1.c7",
            "select singer.Song_Name (singer.Song_release_year)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are all the song names by singers who are older than average?, database: Database: concert_singer_1. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: birthyear, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the name and the release year of the song by the youngest singer., database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the name and the release year of the song by the youngest singer., database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c4, t1.c5",
        "label": "select t1.c4, t1.c5",
        "score": true,
        "real_pred": "select singer.Song_Name, singer.Song_release_year",
        "real_label": "select singer.Song_Name, singer.Song_release_year",
        "topk_preds": [
            "select singer.Song_Name, singer.Song_release_year",
            "select singer.Song_Name, singer.Song_release_year, singer.birthyear",
            "select singer.last_name, singer.Song_release_year",
            "select singer.Song_Name, singer.Song_release_year.",
            "select singer.Song_Name, t1.1.c5",
            "select singer.Song_Name, singer.Song_release_year,",
            "select singer.Song_Name, singer.Song_release_year, singer.gender",
            "select singer.Song_Name, t01.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the name and the release year of the song by the youngest singer., database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names and release years for all the songs of the youngest singer?, database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names and release years for all the songs of the youngest singer?, database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c4, t1.c5",
        "label": "select t1.c4, t1.c5",
        "score": true,
        "real_pred": "select singer.Song_Name, singer.Song_release_year",
        "real_label": "select singer.Song_Name, singer.Song_release_year",
        "topk_preds": [
            "select singer.Song_Name, singer.Song_release_year",
            "select singer.last_name, singer.Song_Name, singer.Song_release_year",
            "select singer.Song_Name, singer.Song_release_year, singer.birthyear",
            "select singer.Song_Name, t1.1.c5",
            "select singer.Song_Name, singer.Song_release_year.",
            "select singer.last_name, singer.Song_Name",
            "select singer.last_name, singer.Song_release_year",
            "select singer.Song_Name, singer.Song_release_year,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names and release years for all the songs of the youngest singer?, database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all song names by singers above the average age., database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all song names by singers above the average age., database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c4",
        "label": "select t1.c4",
        "score": true,
        "real_pred": "select singer.Song_Name",
        "real_label": "select singer.Song_Name",
        "topk_preds": [
            "select singer.Song_Name",
            "select singer.Song_Name, singer.gender",
            "select singer.Song_Name, singer.birthyear",
            "select singer.first_name, singer.last_name",
            "select singer.Song_Name, singer.Song_release_year",
            "select singer.first_name, singer.Song_Name",
            "select singer.Song_Name, singer.Country",
            "select singer.Song_Name (singer.Song_release_year)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all song names by singers above the average age., database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "singer singer_in_concert",
            "",
            "",
            "",
            "",
            "singer concert singer_in_concert"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are all the song names by singers who are older than average?, database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are all the song names by singers who are older than average?, database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c4",
        "label": "select t1.c4",
        "score": true,
        "real_pred": "select singer.Song_Name",
        "real_label": "select singer.Song_Name",
        "topk_preds": [
            "select singer.Song_Name",
            "select singer.Song_Name, singer.birthyear",
            "select singer.first_name, singer.last_name",
            "select singer.Song_Name, singer.gender",
            "select singer.Song_Name, singer.Song_release_year",
            "select singer.Song_Name, singer.Country",
            "select singer.first_name, singer.Song_Name",
            "select distinct singer.Song_Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are all the song names by singers who are older than average?, database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List singer names and number of concerts for each singer., database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY t1.c1, t1.c2, count(*)",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY (t1.c1), count(*)",
            "SELECT-FROM-GROUP BY (t1.c1, t1.c2, count(*)",
            "SELECT-FROM-GROUP BY (t1.c1) et count(*)",
            "SELECT-FROM-GROUP BY t1.c1, t1.c2, counts(*)",
            "SELECT-FROM-GROUP BY -ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List singer names and number of concerts for each singer., database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2, count(*)",
        "label": "select t1.c1, t1.c2, count(*)",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name, count(*)",
        "real_label": "select singer.first_name, singer.last_name, count(*)",
        "topk_preds": [
            "select singer.first_name, singer.last_name, count(*)",
            "select singer.first_name, singer.last_name, count(*),",
            "select singer.first_name, singer.last_name, count(*), singer.Singer_ID",
            "select singer.first_name, singer.last_name, count(*), concert.concert_ID",
            "select singer.first_name, singer.last_name, count(*), concert.Stadium_ID",
            "select singer.first_name, singer.last_name, count(*), concert.concert_Name",
            "select singer.first_name, singer.last_name, count(*), singer_in_concert.Singer_ID",
            "select singer.first_name, singer.last_name, counts(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List singer names and number of concerts for each singer., database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1 t2 t3",
        "label": "t1 t3",
        "score": false,
        "real_pred": "singer concert singer_in_concert",
        "real_label": "singer singer_in_concert",
        "topk_preds": [
            "singer concert singer_in_concert",
            "singer singer_in_concert",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the singers and number of concerts for each person?, database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY (t1.c1, t1.c2, count(*)",
            "SELECT-FROM-GROUP BY (t1.c1), count(*)",
            "SELECT-FROM-GEOGRAPHY-GROUP BY",
            "SELECT-FROM-GROUP BY (t1.c1) et count(*)",
            "SELECT-FROM-GAGGER-GROUP BY",
            "SELECT-FROM-GROUPS-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the singers and number of concerts for each person?, database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2, count(*)",
        "label": "select t1.c1, t1.c2, count(*)",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name, count(*)",
        "real_label": "select singer.first_name, singer.last_name, count(*)",
        "topk_preds": [
            "select singer.first_name, singer.last_name, count(*)",
            "select singer.first_name, singer.last_name, count(*), singer.Singer_ID",
            "select singer.first_name, singer.last_name, count(*),",
            "select singer.first_name, singer.last_name, count(*), concert.Stadium_ID",
            "select singer.first_name, singer.last_name, count(*), singer.gender",
            "select singer.first_name, singer.last_name, count(*), concert.concert_ID",
            "select singer.first_name, singer.last_name, counts(*)",
            "select singer.first_name, singer.last_name, count(*), singer_in_concert.Singer_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the singers and number of concerts for each person?, database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1 t2 t3",
        "label": "t1 t3",
        "score": false,
        "real_pred": "singer concert singer_in_concert",
        "real_label": "singer singer_in_concert",
        "topk_preds": [
            "singer concert singer_in_concert",
            "singer singer_in_concert",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all singer names in concerts in year 2014., database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all singer names in concerts in year 2014., database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name",
        "real_label": "select singer.first_name, singer.last_name",
        "topk_preds": [
            "select singer.first_name, singer.last_name",
            "select singer.first_name, singer.last_name, singer.Singer_ID",
            "select singer.first_name, singer.last_name, singer.gender",
            "select distinct singer.first_name, singer.last_name",
            "select singer.first_name, singer.last_name, singer.Country",
            "select singer.first_name, singer.last_name, singer.Singer_ID",
            "select singer_in_concert.Singer_ID, singer.last_name",
            "select singer.first_name, singer.last_name, singer.gender"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all singer names in concerts in year 2014., database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1 t2 t3",
        "label": "t1 t2 t3",
        "score": true,
        "real_pred": "singer concert singer_in_concert",
        "real_label": "singer concert singer_in_concert",
        "topk_preds": [
            "singer concert singer_in_concert",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the singers who performed in a concert in 2014?, database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-C1, t1.c2",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the singers who performed in a concert in 2014?, database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name",
        "real_label": "select singer.first_name, singer.last_name",
        "topk_preds": [
            "select singer.first_name, singer.last_name",
            "select distinct singer.first_name, singer.last_name",
            "select singer.first_name, singer.last_name, singer.gender",
            "select singer_in_concert.Singer_ID, singer.last_name",
            "select the singer.first_name, singer.last_name",
            "select concert.concert_Name, singer.last_name",
            "select all singer.first_name, singer.last_name",
            "select singer_in_concert.Singer_ID, t3.c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the singers who performed in a concert in 2014?, database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1 t2 t3",
        "label": "t1 t2 t3",
        "score": true,
        "real_pred": "singer concert singer_in_concert",
        "real_label": "singer concert singer_in_concert",
        "topk_preds": [
            "singer concert singer_in_concert",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: what is the name and nation of the singer who have a song having 'Hey' in its name?, database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C1, t1.c2, t1.c3",
            "SELECT-FROM-WHERE-C1, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: what is the name and nation of the singer who have a song having 'Hey' in its name?, database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2, t1.c3",
        "label": "select t1.c1, t1.c2, t1.c3",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name, singer.Country",
        "real_label": "select singer.first_name, singer.last_name, singer.Country",
        "topk_preds": [
            "select singer.first_name, singer.last_name, singer.Country",
            "select singer.first_name, singer.last_name, singer.Country, singer.gender",
            "select singer.first_name, singer.last_name, singer.first_name, singer.Country",
            "select singer.first_name, singer.last_name",
            "select singer.first_name, singer.last_name, singer.Country, singer.Song_Name",
            "select singer.first_name, singer.last_name, t1.c 3",
            "select the singer.first_name, singer.last_name, singer.Country",
            "select singer.first_name, singer.last_name & singer.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: what is the name and nation of the singer who have a song having 'Hey' in its name?, database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name and country of origin of every singer who has a song with the word 'Hey' in its title?, database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-C1, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name and country of origin of every singer who has a song with the word 'Hey' in its title?, database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2, t1.c3",
        "label": "select t1.c1, t1.c2, t1.c3",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name, singer.Country",
        "real_label": "select singer.first_name, singer.last_name, singer.Country",
        "topk_preds": [
            "select singer.first_name, singer.last_name, singer.Country",
            "select singer.first_name, singer.last_name",
            "select distinct singer.first_name, singer.last_name, singer.Country",
            "select the singer.first_name, singer.last_name, singer.Country",
            "select singer.first_name, singer.last_name, t1.c 3",
            "select singer.first_name, singer.last_name & singer.Country",
            "select selc1, singer.last_name, singer.Country",
            "select singer.first_name, singer.last_name, singer.Country,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name and country of origin of every singer who has a song with the word 'Hey' in its title?, database: Database: concert_singer_5. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: first_name, c2: last_name, c3: country, c4: song_name, c5: song_release_year, c6: birthyear, c7: gender). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the weight of the youngest dog., database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the weight of the youngest dog., database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "select t2.c4",
        "label": "select t2.c4",
        "score": true,
        "real_pred": "select Pets.weight",
        "real_label": "select Pets.weight",
        "topk_preds": [
            "select Pets.weight",
            "select Pets.weight, Pets.birthyear",
            "select min(Pets.weight)",
            "select Pets.weight)",
            "select Pets.weight.c4",
            "select Pets.weight (Pets.birthyear)",
            "select max(Pets.weight)",
            "select Pets.weight,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the weight of the youngest dog., database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How much does the youngest dog weigh?, database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How much does the youngest dog weigh?, database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "select t2.c4",
        "label": "select t2.c4",
        "score": true,
        "real_pred": "select Pets.weight",
        "real_label": "select Pets.weight",
        "topk_preds": [
            "select Pets.weight",
            "select min(Pets.weight)",
            "select max(Pets.weight)",
            "select Pets.birthyear, Pets.weight",
            "select Pets.weight, Pets.birthyear",
            "select max(Pets.weight), Pets.birthyear",
            "select min(Pets.weight), Pets.birthyear",
            "select Pets.weight, max(Pets.weight)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How much does the youngest dog weigh?, database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the number of dog pets that are raised by female students (with sex F)., database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM when t0.c0 SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the number of dog pets that are raised by female students (with sex F)., database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.Fname",
            "select count(*), Student.LName, Student.Fname",
            "select count(*), Student.LName, Pets.is_dog",
            "select count(*), Student.is_male",
            "select count(*), Student.LName",
            "select count(*), Student.StuID",
            "select count(*), Student.LName, Student.Fname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the number of dog pets that are raised by female students (with sex F)., database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many dog pets are raised by female students?, database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/GROUP BY-HAVING",
            "SELECT-FROM-WHERE/GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many dog pets are raised by female students?, database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.is_male",
            "select count(*), Student.Fname",
            "select count(distinct Pets.is_dog)",
            "select count(*), Student.is_male",
            "select count(*), Student.LName",
            "select count(*), Student.StuID",
            "select count(distinct Pets.PetID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many dog pets are raised by female students?, database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "",
            "Student Has_Pet",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the first name of students who have cat or dog pet., database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WITH-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the first name of students who have cat or dog pet., database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "select t0.c2",
        "label": "select distinct t0.c2",
        "score": false,
        "real_pred": "select Student.Fname",
        "real_label": "select distinct Student.Fname",
        "topk_preds": [
            "select Student.Fname",
            "select distinct Student.Fname",
            "select Student.StuID, Student.Fname",
            "select distinct Student.Fname, Student.LName",
            "select distinct Student.LName, Student.Fname",
            "select distinct Student.Fname, Has_Pet.StuID",
            "select Student.LName",
            "select distinct Student.Fname, Student.StuID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the first name of students who have cat or dog pet., database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "",
            "",
            "Student Has_Pet",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the first names of every student who has a cat or dog as a pet?, database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the first names of every student who has a cat or dog as a pet?, database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "select t0.c2",
        "label": "select distinct t0.c2",
        "score": false,
        "real_pred": "select Student.Fname",
        "real_label": "select distinct Student.Fname",
        "topk_preds": [
            "select Student.Fname",
            "select distinct Student.Fname",
            "select Student.StuID, Student.Fname",
            "select distinct Student.Fname, Student.LName",
            "select distinct Student.LName, Student.Fname",
            "select distinct Student.Fname, Student.StuID",
            "select unique Student.Fname",
            "select Student.LName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the first names of every student who has a cat or dog as a pet?, database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "",
            "Student Has_Pet",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the first name of students who have both cat and dog pets., database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WITH-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE -INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the first name of students who have both cat and dog pets., database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select Student.Fname",
        "real_label": "select Student.Fname",
        "topk_preds": [
            "select Student.Fname",
            "select Student.StuID, Student.Fname",
            "select Student.Fname, Student.LName",
            "select Student.LName, Student.Fname",
            "select Student.Fname, Has_Pet.StuID",
            "select Student.LName",
            "select Student.StuID, Student.LName",
            "select Student.Fname, Student.LName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the first name of students who have both cat and dog pets., database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "",
            "Student Has_Pet",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the students' first names who have both cats and dogs as pets?, database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WITH-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM BOTH-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROMWHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WAIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the students' first names who have both cats and dogs as pets?, database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select Student.Fname",
        "real_label": "select Student.Fname",
        "topk_preds": [
            "select Student.Fname",
            "select Student.StuID, Student.Fname",
            "select Student.Fname, Student.LName",
            "select Student.StuID, Student.LName",
            "select Student.LName, Student.Fname",
            "select Student.LName",
            "select Student.Fname, Has_Pet.StuID",
            "select Student.Fname, Student.LName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the students' first names who have both cats and dogs as pets?, database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "",
            "Student Has_Pet",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the id of students who do not have a cat pet., database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-A-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the id of students who do not have a cat pet., database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "select t1.c0",
        "label": "select t0.c0",
        "score": false,
        "real_pred": "select Has_Pet.StuID",
        "real_label": "select Student.StuID",
        "topk_preds": [
            "select Has_Pet.StuID",
            "select Student.StuID",
            "select t1, Student.StuID",
            "select Student.StuID, Has_Pet.StuID",
            "select t1, Student.StuID",
            "select Pets.PetID",
            "select Has_Pet.StuID, Has_Pet.PetID",
            "select Has_Pet.StuID, Pets.is_cat"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the id of students who do not have a cat pet., database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "Has_Pet Pets",
            "",
            "",
            "",
            "Student Has_Pet",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the ids of the students who do not own cats as pets?, database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-A-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EEXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the ids of the students who do not own cats as pets?, database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "select t1.c0",
        "label": "select t0.c0",
        "score": false,
        "real_pred": "select Has_Pet.StuID",
        "real_label": "select Student.StuID",
        "topk_preds": [
            "select Has_Pet.StuID",
            "select Student.StuID",
            "select Has_Pet.StuID, Has_Pet.PetID",
            "select t1, Has_Pet.StuID",
            "select Student.StuID, Has_Pet.StuID",
            "select Has_Pet.StuID, Pets.is_cat",
            "select Has_Pet.StuID",
            "select Pets.PetID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the ids of the students who do not own cats as pets?, database: Database: pets_1_0. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: birthyear, c4: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "Has_Pet Pets",
            "",
            "",
            "Student Has_Pet",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the weight of the youngest dog., database: Database: pets_1_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: birthyear, c3: weight).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the weight of the youngest dog., database: Database: pets_1_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: birthyear, c3: weight).",
        "prediction": "select t2.c3",
        "label": "select t2.c3",
        "score": true,
        "real_pred": "select Pets.weight",
        "real_label": "select Pets.weight",
        "topk_preds": [
            "select Pets.weight",
            "select Pets.PetID, Pets.weight",
            "select Pets.weight, Pets.birthyear",
            "select min(Pets.weight)",
            "select Pets.weight)",
            "select Pets.weight.c3",
            "select max(Pets.weight)",
            "select Pets.PetID, max(Pets.weight)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the weight of the youngest dog., database: Database: pets_1_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: birthyear, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            "Has_Pet Pets"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How much does the youngest dog weigh?, database: Database: pets_1_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: birthyear, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-CATEGORY-ORDER BY-LIMIT",
            "SELECT-FROM-CLASS-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How much does the youngest dog weigh?, database: Database: pets_1_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: birthyear, c3: weight).",
        "prediction": "select t2.c3",
        "label": "select t2.c3",
        "score": true,
        "real_pred": "select Pets.weight",
        "real_label": "select Pets.weight",
        "topk_preds": [
            "select Pets.weight",
            "select min(Pets.weight)",
            "select max(Pets.weight)",
            "select Pets.PetID, Pets.weight",
            "select Pets.PetID, max(Pets.weight)",
            "select Pets.weight, max(Pets.weight)",
            "select Pets.weight, Pets.birthyear",
            "select Pets.weight)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How much does the youngest dog weigh?, database: Database: pets_1_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: birthyear, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the type and weight of the youngest pet., database: Database: pets_1_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: birthyear, c3: weight).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the type and weight of the youngest pet., database: Database: pets_1_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: birthyear, c3: weight).",
        "prediction": "select t2.c1, t2.c3",
        "label": "select t2.c1, t2.c3",
        "score": true,
        "real_pred": "select Pets.PetType, Pets.weight",
        "real_label": "select Pets.PetType, Pets.weight",
        "topk_preds": [
            "select Pets.PetType, Pets.weight",
            "select Pets.PetType, Pets.weight, Pets.birthyear",
            "select Pets.PetType, Pets.weight)",
            "select Pets.PetType.c1, Pets.weight",
            "select Pets.PetType, Pets.weight.",
            "select the Pets.PetType, Pets.weight",
            "select Pets.PetType, Pets.weight",
            "select Pets.PetType, Pets.weight,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the type and weight of the youngest pet., database: Database: pets_1_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: birthyear, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What type of pet is the youngest animal, and how much does it weigh?, database: Database: pets_1_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: birthyear, c3: weight).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What type of pet is the youngest animal, and how much does it weigh?, database: Database: pets_1_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: birthyear, c3: weight).",
        "prediction": "select t2.c1, t2.c3",
        "label": "select t2.c1, t2.c3",
        "score": true,
        "real_pred": "select Pets.PetType, Pets.weight",
        "real_label": "select Pets.PetType, Pets.weight",
        "topk_preds": [
            "select Pets.PetType, Pets.weight",
            "select Pets.PetID, Pets.PetType, Pets.weight",
            "select Pets.PetType, Pets.weight, Pets.birthyear",
            "select Pets.PetType.c1, Pets.weight",
            "select Pets.PetType, Pets.weight)",
            "select t2.c type, Pets.weight",
            "select Pets.PetType, Pets.weight, max(Pets.weight)",
            "select Pets.PetType, Pets.weight, min(Pets.weight)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What type of pet is the youngest animal, and how much does it weigh?, database: Database: pets_1_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: birthyear, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the number of dog pets that are raised by female students (with sex F)., database: Database: pets_1_2. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE NUM(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the number of dog pets that are raised by female students (with sex F)., database: Database: pets_1_2. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.is_male",
            "select count(*), Student.StuID",
            "select count(*), Student.LName",
            "select count(distinct Pets.PetType)",
            "select count(*), Student.Fname",
            "select count(*), Student.Age",
            "select count(*), Has_Pet.StuID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the number of dog pets that are raised by female students (with sex F)., database: Database: pets_1_2. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "",
            "Student Has_Pet",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many dog pets are raised by female students?, database: Database: pets_1_2. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE/GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many dog pets are raised by female students?, database: Database: pets_1_2. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.is_male",
            "select count(distinct Pets.PetType)",
            "select count(*), Student.StuID",
            "select count(*), Student.Fname",
            "select count(*), Student.LName",
            "select count(*), Student.is_male",
            "select count(*), Student.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many dog pets are raised by female students?, database: Database: pets_1_2. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "",
            "",
            "Student Has_Pet",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the number of dog pets that are raised by female students (with sex F)., database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE NUM(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the number of dog pets that are raised by female students (with sex F)., database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.StuID",
            "select count(*), Student.Sex",
            "select count(*), Student.LName",
            "select count(distinct Pets.is_dog)",
            "select count(*), Student.Fname",
            "select count(*), Student.StuID",
            "select count(*), Student.Sex"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the number of dog pets that are raised by female students (with sex F)., database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many dog pets are raised by female students?, database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many dog pets are raised by female students?, database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.Sex",
            "select count(*), Student.StuID",
            "select count(distinct Pets.is_dog)",
            "select count(*), Student.Sex",
            "select count(*), Student.LName",
            "select count(*), Student.Fname",
            "select count(*), Student.StuID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many dog pets are raised by female students?, database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the first name of students who have cat or dog pet., database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WITH-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the first name of students who have cat or dog pet., database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "select distinct t0.c2",
        "label": "select distinct t0.c2",
        "score": true,
        "real_pred": "select distinct Student.Fname",
        "real_label": "select distinct Student.Fname",
        "topk_preds": [
            "select distinct Student.Fname",
            "select Student.Fname",
            "select Student.StuID, Student.Fname",
            "select distinct Student.Fname, Student.LName",
            "select distinct Student.LName, Student.Fname",
            "select distinct Student.LName",
            "select distinct Student.Fname, Has_Pet.StuID",
            "select distinct Student.Fname, Student.StuID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the first name of students who have cat or dog pet., database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            "Student Has_Pet"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the first names of every student who has a cat or dog as a pet?, database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the first names of every student who has a cat or dog as a pet?, database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "select t0.c2",
        "label": "select distinct t0.c2",
        "score": false,
        "real_pred": "select Student.Fname",
        "real_label": "select distinct Student.Fname",
        "topk_preds": [
            "select Student.Fname",
            "select distinct Student.Fname",
            "select Student.StuID, Student.Fname",
            "select distinct Student.Fname, Student.LName",
            "select distinct Student.LName, Student.Fname",
            "select Student.LName",
            "select distinct Student.Fname, Student.StuID",
            "select unique Student.Fname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the first names of every student who has a cat or dog as a pet?, database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "",
            "Student Has_Pet",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the first name of students who have both cat and dog pets., database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WITH-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT-FROM-WHERE -INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROMWHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the first name of students who have both cat and dog pets., database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select Student.Fname",
        "real_label": "select Student.Fname",
        "topk_preds": [
            "select Student.Fname",
            "select Student.StuID, Student.Fname",
            "select Student.Fname, Student.LName",
            "select Student.LName, Student.Fname",
            "select Student.LName",
            "select Student.Fname, Has_Pet.StuID",
            "select Student.Fname, Student.LName",
            "select Student.StuID, Student.LName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the first name of students who have both cat and dog pets., database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the students' first names who have both cats and dogs as pets?, database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WITH-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM BOTH-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROMWHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WAIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the students' first names who have both cats and dogs as pets?, database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select Student.Fname",
        "real_label": "select Student.Fname",
        "topk_preds": [
            "select Student.Fname",
            "select Student.StuID, Student.Fname",
            "select Student.Fname, Student.LName",
            "select Student.LName",
            "select Student.LName, Student.Fname",
            "select Student.StuID, Student.LName",
            "select Student.Fname, Has_Pet.StuID",
            "select Student.Fname, Student.LName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the students' first names who have both cats and dogs as pets?, database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            "Student Has_Pet"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the id of students who do not have a cat pet., database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EVEN-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM -WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the id of students who do not have a cat pet., database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "select t1.c0",
        "label": "select t0.c0",
        "score": false,
        "real_pred": "select Has_Pet.StuID",
        "real_label": "select Student.StuID",
        "topk_preds": [
            "select Has_Pet.StuID",
            "select Student.StuID",
            "select t1, Student.StuID",
            "select Student.StuID, Has_Pet.StuID",
            "select t1, Student.StuID",
            "select t1, Pets.PetID",
            "select Pets.PetID",
            "select Has_Pet.StuID, Has_Pet.PetID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the id of students who do not have a cat pet., database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "Has_Pet Pets",
            "",
            "",
            "",
            "Student Has_Pet",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the ids of the students who do not own cats as pets?, database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-ESE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EEXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the ids of the students who do not own cats as pets?, database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "select t1.c0",
        "label": "select t0.c0",
        "score": false,
        "real_pred": "select Has_Pet.StuID",
        "real_label": "select Student.StuID",
        "topk_preds": [
            "select Has_Pet.StuID",
            "select Student.StuID",
            "select Has_Pet.StuID, Has_Pet.PetID",
            "select t1, Has_Pet.StuID",
            "select Has_Pet.StuID, Pets.is_cat",
            "select Student.StuID, Has_Pet.StuID",
            "select Has_Pet.StuID",
            "select Has_Pet.StuID, t1.c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the ids of the students who do not own cats as pets?, database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "Has_Pet Pets",
            "",
            "",
            "Student Has_Pet",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the last name of the student who has a cat that is age 3., database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the last name of the student who has a cat that is age 3., database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Student.LName",
        "real_label": "select Student.LName",
        "topk_preds": [
            "select Student.LName",
            "select Student.LName, Student.Fname",
            "select Pets.is_cat, Student.LName",
            "select Student.LName, Student.Fname, Student.birthyear",
            "select Student.LName, Student.Fname, Student.birthyear",
            "select Student.LName, Has_Pet.StuID",
            "select Student.LName, Student.Fname Student.birthyear",
            "select Student.LName Student.Fname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the last name of the student who has a cat that is age 3., database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "",
            "Student Pets",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the last name of the student who has a cat that is 3 years old?, database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the last name of the student who has a cat that is 3 years old?, database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Student.LName",
        "real_label": "select Student.LName",
        "topk_preds": [
            "select Student.LName",
            "select Student.LName, Student.Fname",
            "select Student.LName, Student.Fname, Student.birthyear",
            "select Pets.is_cat, Student.LName",
            "select Student.LName, Student.birthyear",
            "select Student.LName, Pets.is_dog, Pets.pet_age",
            "select Student.LName, Student.Fname, Student.birthyear",
            "select Student.LName, Has_Pet.StuID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the last name of the student who has a cat that is 3 years old?, database: Database: pets_1_4. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: is_cat, c2: is_dog, c3: pet_age, c4: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the weight of the youngest dog., database: Database: pets_1_5. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: birthyear, c3: weight).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the weight of the youngest dog., database: Database: pets_1_5. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: birthyear, c3: weight).",
        "prediction": "select t2.c3",
        "label": "select t2.c3",
        "score": true,
        "real_pred": "select Pets.weight",
        "real_label": "select Pets.weight",
        "topk_preds": [
            "select Pets.weight",
            "select Pets.PetID, Pets.weight",
            "select Pets.weight, Pets.birthyear",
            "select min(Pets.weight)",
            "select Pets.weight)",
            "select Pets.weight.c3",
            "select max(Pets.weight)",
            "select Pets.PetID, max(Pets.weight)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the weight of the youngest dog., database: Database: pets_1_5. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: birthyear, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "Has_Pet Pets",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How much does the youngest dog weigh?, database: Database: pets_1_5. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: birthyear, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How much does the youngest dog weigh?, database: Database: pets_1_5. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: birthyear, c3: weight).",
        "prediction": "select t2.c3",
        "label": "select t2.c3",
        "score": true,
        "real_pred": "select Pets.weight",
        "real_label": "select Pets.weight",
        "topk_preds": [
            "select Pets.weight",
            "select min(Pets.weight)",
            "select max(Pets.weight)",
            "select Pets.PetID, Pets.weight",
            "select Pets.PetID, max(Pets.weight)",
            "select Pets.weight, max(Pets.weight)",
            "select Pets.weight, Pets.birthyear",
            "select Pets.PetID, min(Pets.weight)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How much does the youngest dog weigh?, database: Database: pets_1_5. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: birthyear, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the number of dog pets that are raised by female students (with sex F)., database: Database: pets_1_5. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: birthyear, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE(count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the number of dog pets that are raised by female students (with sex F)., database: Database: pets_1_5. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: birthyear, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.StuID",
            "select count(*), Student.is_male",
            "select count(*), Student.Fname",
            "select count(distinct Pets.PetType)",
            "select count(*), Student.LName",
            "select count(distinct Pets.PetID)",
            "select count(*), Student.birthyear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the number of dog pets that are raised by female students (with sex F)., database: Database: pets_1_5. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: birthyear, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many dog pets are raised by female students?, database: Database: pets_1_5. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: birthyear, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE/GROUP BY-HAVING",
            "SELECT-FROM-WHERE, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many dog pets are raised by female students?, database: Database: pets_1_5. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: birthyear, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.is_male",
            "select count(distinct Pets.PetType)",
            "select count(*), Student.Fname",
            "select count(*), Student.StuID",
            "select count(distinct Pets.PetID)",
            "select count(*), Student.LName",
            "select count(*), Student.is_male"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many dog pets are raised by female students?, database: Database: pets_1_5. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: birthyear, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "Student Has_Pet",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the type and weight of the youngest pet., database: Database: pets_1_5. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: birthyear, c3: weight).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the type and weight of the youngest pet., database: Database: pets_1_5. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: birthyear, c3: weight).",
        "prediction": "select t2.c1, t2.c3",
        "label": "select t2.c1, t2.c3",
        "score": true,
        "real_pred": "select Pets.PetType, Pets.weight",
        "real_label": "select Pets.PetType, Pets.weight",
        "topk_preds": [
            "select Pets.PetType, Pets.weight",
            "select Pets.PetType, Pets.weight, Pets.birthyear",
            "select Pets.PetType, Pets.weight)",
            "select Pets.PetType.c1, Pets.weight",
            "select Pets.PetType, Pets.weight.",
            "select Pets.PetType, Pets.weight",
            "select the Pets.PetType, Pets.weight",
            "select Pets.PetType, Pets.weight,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the type and weight of the youngest pet., database: Database: pets_1_5. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: birthyear, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What type of pet is the youngest animal, and how much does it weigh?, database: Database: pets_1_5. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: birthyear, c3: weight).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What type of pet is the youngest animal, and how much does it weigh?, database: Database: pets_1_5. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: birthyear, c3: weight).",
        "prediction": "select t2.c1, t2.c3",
        "label": "select t2.c1, t2.c3",
        "score": true,
        "real_pred": "select Pets.PetType, Pets.weight",
        "real_label": "select Pets.PetType, Pets.weight",
        "topk_preds": [
            "select Pets.PetType, Pets.weight",
            "select Pets.PetID, Pets.PetType, Pets.weight",
            "select Pets.PetType, Pets.weight, Pets.birthyear",
            "select Pets.PetType.c1, Pets.weight",
            "select Pets.PetType, Pets.weight)",
            "select t2.c type, Pets.weight",
            "select Pets.PetType, Pets.weight, max(Pets.weight)",
            "select t2.ctype, Pets.weight"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What type of pet is the youngest animal, and how much does it weigh?, database: Database: pets_1_5. t0: student(c0: stuid, c1: lname, c2: fname, c3: birthyear, c4: is_male, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: birthyear, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Sort employee names by their age in ascending order., database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-ORDER BY (t0.c1), SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t0.c1, t0.c2",
            "SELECT-FROM-ORDER BY (t0.c1)",
            "SELECT-FROM-ORDER BY (t0.c1) - SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t0.c1, t0.c2)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Sort employee names by their age in ascending order., database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select employee.first_name, employee.last_name",
        "real_label": "select employee.first_name, employee.last_name",
        "topk_preds": [
            "select employee.first_name, employee.last_name",
            "select employee.first_name, employee.last_name, employee.Age",
            "select employee.first_name, employee.last_name in employee.Age",
            "select employee.first_name, employee.last_name and employee.Age",
            "select employee.Employee_ID, employee.first_name, employee.last_name",
            "select employee.first_name, employee.last_name, employee.Age",
            "select employee.first_name, employee.last_name, employee.Age",
            "select employee.first_name.c1, employee.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Sort employee names by their age in ascending order., database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "employee",
        "real_label": "employee",
        "topk_preds": [
            "employee",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of employees and sort in ascending order of age., database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY.",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY t0"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of employees and sort in ascending order of age., database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select employee.first_name, employee.last_name",
        "real_label": "select employee.first_name, employee.last_name",
        "topk_preds": [
            "select employee.first_name, employee.last_name",
            "select employee.first_name, employee.last_name, employee.Age",
            "select employee.Employee_ID, employee.first_name, employee.last_name",
            "select employee.first_name, employee.last_name, employee.Age",
            "select employee.first_name, employee.last_name and employee.Age",
            "select employee.first_name, employee.last_name in employee.Age",
            "select employee.first_name, employee.last_name, employee.Age",
            "select employee.first_name, employee.last_name sort(employee.Age)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of employees and sort in ascending order of age., database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "employee",
        "real_label": "employee",
        "topk_preds": [
            "employee",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the manager name and district of the shop whose number of products is the largest., database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the manager name and district of the shop whose number of products is the largest., database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c5, t1.c6",
        "label": "select t1.c5, t1.c6, t1.c3",
        "score": false,
        "real_pred": "select shop.manager_first_name, shop.manager_last_name",
        "real_label": "select shop.manager_first_name, shop.manager_last_name, shop.District",
        "topk_preds": [
            "select shop.manager_first_name, shop.manager_last_name",
            "select shop.manager_first_name, shop.manager_last_name, shop.District",
            "select shop.Name, shop.manager_last_name, shop.District",
            "select shop.manager_first_name, shop.manager_last_name, shop.Location, shop.District",
            "select shop.manager_first_name, shop.District",
            "select shop.Name, shop.District",
            "select shop.manager_first_name, shop.manager_last_name, shop.District, max(shop.Number_products)",
            "select shop.Name, shop.manager_last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the manager name and district of the shop whose number of products is the largest., database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the manager name and district of the shop that sells the largest number of products?, database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the manager name and district of the shop that sells the largest number of products?, database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c5, t1.c6",
        "label": "select t1.c5, t1.c6, t1.c3",
        "score": false,
        "real_pred": "select shop.manager_first_name, shop.manager_last_name",
        "real_label": "select shop.manager_first_name, shop.manager_last_name, shop.District",
        "topk_preds": [
            "select shop.manager_first_name, shop.manager_last_name",
            "select shop.manager_first_name, shop.manager_last_name, shop.District",
            "select shop.Name, shop.manager_last_name, shop.District",
            "select shop.manager_first_name, shop.manager_last_name, shop.Location, shop.District",
            "select shop.Name, shop.District",
            "select shop.Name, shop.manager_last_name",
            "select shop.manager_first_name, shop.manager_last_name, shop.Location",
            "select shop.manager_first_name, shop.manager_last_name, shop.District, shop.Location"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the manager name and district of the shop that sells the largest number of products?, database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: find the name of employee who was awarded the most times in the evaluation., database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-C1, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-C1, t0.c2",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: find the name of employee who was awarded the most times in the evaluation., database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select employee.first_name, employee.last_name",
        "real_label": "select employee.first_name, employee.last_name",
        "topk_preds": [
            "select employee.first_name, employee.last_name",
            "select employee.first_name, employee.last_name, employee.Employee_ID",
            "select employee.first_name, employee.last_name, employee.Age",
            "select t.c1, employee.last_name",
            "select employee.first_name, employee.last_name, evaluation.Year_awarded",
            "select tO.c1, employee.last_name",
            "select evaluation.Year_awarded, employee.last_name",
            "select hiring.Employee_ID, employee.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: find the name of employee who was awarded the most times in the evaluation., database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0 t3",
        "label": "t0 t3",
        "score": true,
        "real_pred": "employee evaluation",
        "real_label": "employee evaluation",
        "topk_preds": [
            "employee evaluation",
            "",
            "employee hiring evaluation",
            "",
            "employee shop hiring evaluation",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which employee received the most awards in evaluations? Give me the employee name., database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-C1, t0.c2",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-C1, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which employee received the most awards in evaluations? Give me the employee name., database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select employee.first_name, employee.last_name",
        "real_label": "select employee.first_name, employee.last_name",
        "topk_preds": [
            "select employee.first_name, employee.last_name",
            "select employee.Employee_ID, employee.first_name, employee.last_name",
            "select employee.first_name.c1, employee.last_name",
            "select employee.first_name, employee.last_name, employee.Employee_ID",
            "select employee.first_name, employee.last_name, employee.Age",
            "select tO.c1, employee.last_name",
            "select employee.first_name, employee.last_name, evaluation.Employee_ID",
            "select t10.c1, employee.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which employee received the most awards in evaluations? Give me the employee name., database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0 t3",
        "label": "t0 t3",
        "score": true,
        "real_pred": "employee evaluation",
        "real_label": "employee evaluation",
        "topk_preds": [
            "employee evaluation",
            "employee hiring evaluation",
            "employee shop evaluation",
            "employee shop hiring evaluation",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the name of the employee who got the highest one time bonus., database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the name of the employee who got the highest one time bonus., database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select employee.first_name, employee.last_name",
        "real_label": "select employee.first_name, employee.last_name",
        "topk_preds": [
            "select employee.first_name, employee.last_name",
            "select employee.first_name, employee.last_name, employee.Employee_ID",
            "select employee.first_name, employee.last_name, employee.Age",
            "select t.c1, employee.last_name",
            "select employee.first_name, employee.last_name (or employee.Employee_ID)",
            "select employee.first_name, employee.last_name, evaluation.Employee_ID",
            "select hiring.Employee_ID, employee.last_name",
            "select employee.first_name, employee.last_name (ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the name of the employee who got the highest one time bonus., database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0 t3",
        "label": "t0 t3",
        "score": true,
        "real_pred": "employee evaluation",
        "real_label": "employee evaluation",
        "topk_preds": [
            "employee evaluation",
            "employee hiring evaluation",
            "employee shop hiring evaluation",
            "employee shop evaluation",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which employee received the biggest bonus? Give me the employee name., database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which employee received the biggest bonus? Give me the employee name., database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select employee.first_name, employee.last_name",
        "real_label": "select employee.first_name, employee.last_name",
        "topk_preds": [
            "select employee.first_name, employee.last_name",
            "select employee.Employee_ID, employee.first_name, employee.last_name",
            "select evaluation.Employee_ID, employee.first_name, employee.last_name",
            "select employee.first_name, employee.last_name, employee.Employee_ID",
            "select employee.first_name, employee.last_name, evaluation.Employee_ID",
            "select employee.first_name, employee.last_name, employee.Age",
            "select hiring.Employee_ID, employee.last_name",
            "select t10.c1, employee.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which employee received the biggest bonus? Give me the employee name., database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0 t3",
        "label": "t0 t3",
        "score": true,
        "real_pred": "employee evaluation",
        "real_label": "employee evaluation",
        "topk_preds": [
            "employee evaluation",
            "employee hiring evaluation",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the names of employees who never won any award in the evaluation., database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the names of employees who never won any award in the evaluation., database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select employee.first_name, employee.last_name",
        "real_label": "select employee.first_name, employee.last_name",
        "topk_preds": [
            "select employee.first_name, employee.last_name",
            "select employee.Employee_ID, employee.first_name, employee.last_name",
            "select employee.first_name, employee.last_name, employee.Employee_ID",
            "select employee.first_name, employee.last_name, employee.Age",
            "select employee.first_name.c1, employee.last_name",
            "select t0-c1, t0-c2",
            "select t.c1, employee.last_name",
            "select employee.first_name, employee.last_name,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the names of employees who never won any award in the evaluation., database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0 t3",
        "label": "t0",
        "score": false,
        "real_pred": "employee evaluation",
        "real_label": "employee",
        "topk_preds": [
            "employee evaluation",
            "employee",
            "employee hiring evaluation",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the employees who never received any evaluation?, database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the employees who never received any evaluation?, database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select employee.first_name, employee.last_name",
        "real_label": "select employee.first_name, employee.last_name",
        "topk_preds": [
            "select employee.first_name, employee.last_name",
            "select employee.Employee_ID, employee.first_name, employee.last_name",
            "select employee.first_name, employee.last_name, employee.Age",
            "select employee.first_name.c1, employee.last_name",
            "select employee.first_name, employee.last_name, employee.Employee_ID",
            "select t0-c1, t0-c2",
            "select employee.first_name, employee.last_name, employee.Age",
            "select employee.first_name, employee.last_name,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the employees who never received any evaluation?, database: Database: employee_hire_evaluation_0. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: age, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "employee",
        "real_label": "employee",
        "topk_preds": [
            "employee",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Sort employee names by their age in ascending order., database: Database: employee_hire_evaluation_1. t0: employee(c0: employee_id, c1: name, c2: birthyear, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t0.c1)",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY (T0.c1)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Sort employee names by their age in ascending order., database: Database: employee_hire_evaluation_1. t0: employee(c0: employee_id, c1: name, c2: birthyear, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select employee.Name",
        "real_label": "select employee.Name",
        "topk_preds": [
            "select employee.Name",
            "select employee.Name, employee.birthyear",
            "select employee.Name in employee.birthyear",
            "select employee.Employee_ID, employee.Name",
            "select employee.Name-ORDER BY",
            "select employee.Name - employee.birthyear",
            "select employee.Name, employee.City",
            "select employee.Name (ORDER BY"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Sort employee names by their age in ascending order., database: Database: employee_hire_evaluation_1. t0: employee(c0: employee_id, c1: name, c2: birthyear, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "employee",
        "real_label": "employee",
        "topk_preds": [
            "employee",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of employees and sort in ascending order of age., database: Database: employee_hire_evaluation_1. t0: employee(c0: employee_id, c1: name, c2: birthyear, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY.",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY t0.c1",
            "SELECT-FROM-ORDER BY (t0.c1)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of employees and sort in ascending order of age., database: Database: employee_hire_evaluation_1. t0: employee(c0: employee_id, c1: name, c2: birthyear, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select employee.Name",
        "real_label": "select employee.Name",
        "topk_preds": [
            "select employee.Name",
            "select employee.Name, employee.birthyear",
            "select employee.Name-ORDER BY",
            "select employee.Name and employee.birthyear",
            "select employee.Name in employee.birthyear",
            "select employee.Name, employee.City",
            "select employee.Name (ORDER BY",
            "select employee.Name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of employees and sort in ascending order of age., database: Database: employee_hire_evaluation_1. t0: employee(c0: employee_id, c1: name, c2: birthyear, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "employee",
        "real_label": "employee",
        "topk_preds": [
            "employee",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the manager name and district of the shop whose number of products is the largest., database: Database: employee_hire_evaluation_4. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the manager name and district of the shop whose number of products is the largest., database: Database: employee_hire_evaluation_4. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c5, t1.c6, t1.c3",
        "label": "select t1.c5, t1.c6, t1.c3",
        "score": true,
        "real_pred": "select shop.manager_first_name, shop.manager_last_name, shop.District",
        "real_label": "select shop.manager_first_name, shop.manager_last_name, shop.District",
        "topk_preds": [
            "select shop.manager_first_name, shop.manager_last_name, shop.District",
            "select shop.manager_first_name, shop.manager_last_name",
            "select shop.Name, shop.manager_last_name, shop.District",
            "select shop.manager_first_name, shop.manager_last_name, shop.Location, shop.District",
            "select shop.Number_products, shop.manager_first_name, shop.manager_last_name",
            "select shop.manager_first_name, shop.manager_last_name, shop.Location",
            "select shop.Name, shop.manager_last_name",
            "select shop.manager_first_name, shop.manager_last_name, shop.District, max(shop.Number_products)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the manager name and district of the shop whose number of products is the largest., database: Database: employee_hire_evaluation_4. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the manager name and district of the shop that sells the largest number of products?, database: Database: employee_hire_evaluation_4. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the manager name and district of the shop that sells the largest number of products?, database: Database: employee_hire_evaluation_4. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c5, t1.c6, t1.c3",
        "label": "select t1.c5, t1.c6, t1.c3",
        "score": true,
        "real_pred": "select shop.manager_first_name, shop.manager_last_name, shop.District",
        "real_label": "select shop.manager_first_name, shop.manager_last_name, shop.District",
        "topk_preds": [
            "select shop.manager_first_name, shop.manager_last_name, shop.District",
            "select shop.manager_first_name, shop.manager_last_name",
            "select shop.Name, shop.manager_last_name, shop.District",
            "select shop.manager_first_name, shop.manager_last_name, shop.Location, shop.District",
            "select shop.manager_first_name, shop.manager_last_name, shop.Location",
            "select shop.Number_products, shop.manager_first_name, shop.manager_last_name",
            "select shop.Name, shop.manager_last_name",
            "select shop.manager_first_name, shop.manager_last_name, shop.District, shop.Location"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the manager name and district of the shop that sells the largest number of products?, database: Database: employee_hire_evaluation_4. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Sort employee names by their age in ascending order., database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t0.c1), t0.c2",
            "SELECT-FROM-ORDER BY (t0.c1), SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t0.c1) - SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-ORDER BY (t0.c1) et SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t0.c1, t0.c2"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Sort employee names by their age in ascending order., database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select employee.first_name, employee.last_name",
        "real_label": "select employee.first_name, employee.last_name",
        "topk_preds": [
            "select employee.first_name, employee.last_name",
            "select employee.first_name, employee.last_name, employee.birthyear",
            "select employee.Employee_ID, employee.first_name, employee.last_name",
            "select employee.first_name, employee.last_name in employee.birthyear",
            "select employee.first_name, employee.last_name and employee.birthyear",
            "select employee.first_name, employee.last_name, employee.birthyear",
            "select employee.first_name.c1, employee.last_name",
            "select employee.first_name, employee.last_name-ordered"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Sort employee names by their age in ascending order., database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "employee",
        "real_label": "employee",
        "topk_preds": [
            "employee",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of employees and sort in ascending order of age., database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t0.c1) - SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t0.c1), SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY (t0.c1), t0.c2",
            "SELECT-FROM-ORDER BY."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of employees and sort in ascending order of age., database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select employee.first_name, employee.last_name",
        "real_label": "select employee.first_name, employee.last_name",
        "topk_preds": [
            "select employee.first_name, employee.last_name",
            "select employee.first_name, employee.last_name, employee.birthyear",
            "select employee.Employee_ID, employee.first_name, employee.last_name",
            "select employee.first_name, employee.last_name in employee.birthyear",
            "select employee.first_name, employee.last_name and employee.birthyear",
            "select employee.first_name, employee.last_name, employee.birthyear",
            "select employee.first_name.c1, employee.last_name",
            "select employee.first_name, employee.last_name (ORDER BY"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of employees and sort in ascending order of age., database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "employee",
        "real_label": "employee",
        "topk_preds": [
            "employee",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the manager name and district of the shop whose number of products is the largest., database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the manager name and district of the shop whose number of products is the largest., database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c5, t1.c6",
        "label": "select t1.c5, t1.c6, t1.c3",
        "score": false,
        "real_pred": "select shop.manager_first_name, shop.manager_last_name",
        "real_label": "select shop.manager_first_name, shop.manager_last_name, shop.District",
        "topk_preds": [
            "select shop.manager_first_name, shop.manager_last_name",
            "select shop.manager_first_name, shop.manager_last_name, shop.District",
            "select shop.manager_first_name, shop.District",
            "select shop.Name, shop.District",
            "select shop.Name, shop.manager_last_name, shop.District",
            "select shop.manager_first_name, shop.manager_last_name, shop.Location, shop.District",
            "select shop.Name, shop.manager_last_name",
            "select shop.manager_first_name, shop.manager_last_name, shop.District, max(shop.Number_products)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the manager name and district of the shop whose number of products is the largest., database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the manager name and district of the shop that sells the largest number of products?, database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the manager name and district of the shop that sells the largest number of products?, database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c5, t1.c6",
        "label": "select t1.c5, t1.c6, t1.c3",
        "score": false,
        "real_pred": "select shop.manager_first_name, shop.manager_last_name",
        "real_label": "select shop.manager_first_name, shop.manager_last_name, shop.District",
        "topk_preds": [
            "select shop.manager_first_name, shop.manager_last_name",
            "select shop.manager_first_name, shop.manager_last_name, shop.District",
            "select shop.Name, shop.manager_last_name, shop.District",
            "select shop.Name, shop.District",
            "select shop.manager_first_name, shop.manager_last_name, shop.Location, shop.District",
            "select shop.Name, shop.manager_last_name",
            "select shop.manager_first_name, shop.manager_last_name, shop.Location",
            "select shop.manager_first_name, shop.manager_last_name, shop.District, shop.Location"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the manager name and district of the shop that sells the largest number of products?, database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: find the name of employee who was awarded the most times in the evaluation., database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-C1, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-C1, t0.c2",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: find the name of employee who was awarded the most times in the evaluation., database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select employee.first_name, employee.last_name",
        "real_label": "select employee.first_name, employee.last_name",
        "topk_preds": [
            "select employee.first_name, employee.last_name",
            "select employee.first_name, employee.last_name, employee.Employee_ID",
            "select employee.first_name, employee.last_name, employee.birthyear",
            "select evaluation.Year_awarded, employee.last_name",
            "select t.c1, employee.last_name",
            "select tO.c1, employee.last_name",
            "select hiring.Employee_ID, employee.last_name",
            "select employee.first_name, employee.last_name, evaluation.Year_awarded"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: find the name of employee who was awarded the most times in the evaluation., database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0 t3",
        "label": "t0 t3",
        "score": true,
        "real_pred": "employee evaluation",
        "real_label": "employee evaluation",
        "topk_preds": [
            "employee evaluation",
            "employee hiring evaluation",
            "employee shop hiring evaluation",
            "employee shop evaluation",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which employee received the most awards in evaluations? Give me the employee name., database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-C1, t0.c2",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-C1, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which employee received the most awards in evaluations? Give me the employee name., database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select employee.first_name, employee.last_name",
        "real_label": "select employee.first_name, employee.last_name",
        "topk_preds": [
            "select employee.first_name, employee.last_name",
            "select employee.Employee_ID, employee.first_name, employee.last_name",
            "select employee.first_name.c1, employee.last_name",
            "select employee.first_name, employee.last_name, employee.Employee_ID",
            "select employee.first_name, employee.last_name, employee.birthyear",
            "select tO.c1, employee.last_name",
            "select evaluation.Year_awarded, employee.last_name",
            "select t10.c1, employee.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which employee received the most awards in evaluations? Give me the employee name., database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0 t3",
        "label": "t0 t3",
        "score": true,
        "real_pred": "employee evaluation",
        "real_label": "employee evaluation",
        "topk_preds": [
            "employee evaluation",
            "employee hiring evaluation",
            "employee shop evaluation",
            "employee shop hiring evaluation",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the name of the employee who got the highest one time bonus., database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the name of the employee who got the highest one time bonus., database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select employee.first_name, employee.last_name",
        "real_label": "select employee.first_name, employee.last_name",
        "topk_preds": [
            "select employee.first_name, employee.last_name",
            "select employee.first_name, employee.last_name, employee.Employee_ID",
            "select employee.first_name, employee.last_name, employee.birthyear",
            "select t.c1, employee.last_name",
            "select employee.first_name, employee.last_name (or employee.Employee_ID)",
            "select evaluation.Year_awarded, employee.last_name",
            "select hiring.Employee_ID, employee.last_name",
            "select tO.c1, employee.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the name of the employee who got the highest one time bonus., database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0 t3",
        "label": "t0 t3",
        "score": true,
        "real_pred": "employee evaluation",
        "real_label": "employee evaluation",
        "topk_preds": [
            "employee evaluation",
            "employee hiring evaluation",
            "employee shop hiring evaluation",
            "employee shop evaluation",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which employee received the biggest bonus? Give me the employee name., database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which employee received the biggest bonus? Give me the employee name., database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select employee.first_name, employee.last_name",
        "real_label": "select employee.first_name, employee.last_name",
        "topk_preds": [
            "select employee.first_name, employee.last_name",
            "select employee.Employee_ID, employee.first_name, employee.last_name",
            "select evaluation.Employee_ID, employee.first_name, employee.last_name",
            "select employee.first_name, employee.last_name, employee.Employee_ID",
            "select t.0.c1, employee.last_name",
            "select hiring.Employee_ID, employee.last_name",
            "select employee.first_name, employee.last_name, evaluation.Employee_ID",
            "select t10.c1, employee.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which employee received the biggest bonus? Give me the employee name., database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0 t3",
        "label": "t0 t3",
        "score": true,
        "real_pred": "employee evaluation",
        "real_label": "employee evaluation",
        "topk_preds": [
            "employee evaluation",
            "employee hiring evaluation",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the names of employees who never won any award in the evaluation., database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the names of employees who never won any award in the evaluation., database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select employee.first_name, employee.last_name",
        "real_label": "select employee.first_name, employee.last_name",
        "topk_preds": [
            "select employee.first_name, employee.last_name",
            "select employee.Employee_ID, employee.first_name, employee.last_name",
            "select employee.first_name, employee.last_name, employee.Employee_ID",
            "select employee.first_name, employee.last_name, employee.birthyear",
            "select employee.first_name.c1, employee.last_name",
            "select t0-c1, t0-c2",
            "select t.c1, employee.last_name",
            "select employee.first_name, employee.last_name, t0.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the names of employees who never won any award in the evaluation., database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0 t3",
        "label": "t0",
        "score": false,
        "real_pred": "employee evaluation",
        "real_label": "employee",
        "topk_preds": [
            "employee evaluation",
            "employee",
            "employee hiring evaluation",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the employees who never received any evaluation?, database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the employees who never received any evaluation?, database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select employee.first_name, employee.last_name",
        "real_label": "select employee.first_name, employee.last_name",
        "topk_preds": [
            "select employee.first_name, employee.last_name",
            "select employee.Employee_ID, employee.first_name, employee.last_name",
            "select employee.first_name, employee.last_name, employee.birthyear",
            "select employee.first_name.c1, employee.last_name",
            "select employee.first_name, employee.last_name, employee.Employee_ID",
            "select t0-c1, t0-c2",
            "select employee.first_name, employee.last_name, employee.birthyear",
            "select employee.first_name, employee.last_name, t0.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the employees who never received any evaluation?, database: Database: employee_hire_evaluation_5. t0: employee(c0: employee_id, c1: first_name, c2: last_name, c3: birthyear, c4: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_first_name, c6: manager_last_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "employee",
        "real_label": "employee",
        "topk_preds": [
            "employee",
            "",
            "",
            "",
            "",
            "employee evaluation",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of teachers in ascending order of age., database: Database: course_teach_0. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: name, c2: birthyear, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY.",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY (t1.c1)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of teachers in ascending order of age., database: Database: course_teach_0. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: name, c2: birthyear, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.birthyear",
            "select teacher.Name, teacher.birthyear, teacher.Hometown",
            "select teacher.Name, teacher.birthyear - teacher.Hometown",
            "select teacher.Name in teacher.birthyear",
            "select teacher.Name (ORDER BY",
            "select teacher.Name (ordinal)",
            "select teacher.Name, teacher.birthyear, teacher.Hometown"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of teachers in ascending order of age., database: Database: course_teach_0. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: name, c2: birthyear, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the teachers ordered by ascending age?, database: Database: course_teach_0. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: name, c2: birthyear, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY.",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY t1.c1",
            "SELECT-FROM-ORDER BY ("
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the teachers ordered by ascending age?, database: Database: course_teach_0. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: name, c2: birthyear, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.birthyear",
            "select teacher.Name, teacher.birthyear, teacher.Hometown",
            "select teacher.Name (ordered by teacher.birthyear)",
            "select teacher.Name (ordered teacher.birthyear)",
            "select teacher.Name, teacher.birthyear, teacher.Hometown",
            "select teacher.Name or teacher.birthyear",
            "select teacher.Name (ordered by"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the teachers ordered by ascending age?, database: Database: course_teach_0. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: name, c2: birthyear, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the hometown of the youngest teacher?, database: Database: course_teach_0. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: name, c2: birthyear, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the hometown of the youngest teacher?, database: Database: course_teach_0. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: name, c2: birthyear, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select teacher.Hometown",
        "real_label": "select teacher.Hometown",
        "topk_preds": [
            "select teacher.Hometown",
            "select teacher.Hometown, teacher.birthyear",
            "select teacher.Hometown, teacher.birthyear, teacher.Teacher_ID",
            "select teacher.birthyear, teacher.Hometown",
            "select teacher.Hometown, teacher.birthyear (if teacher.Teacher_ID)",
            "select teacher.Hometown (ORDER BY-LIMIT)",
            "select teacher.Hometown (or teacher.birthyear)",
            "select teacher.Hometown, teacher.birthyear (if teacher.Hometown)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the hometown of the youngest teacher?, database: Database: course_teach_0. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: name, c2: birthyear, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Where is the youngest teacher from?, database: Database: course_teach_0. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: name, c2: birthyear, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Where is the youngest teacher from?, database: Database: course_teach_0. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: name, c2: birthyear, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select teacher.Hometown",
        "real_label": "select teacher.Hometown",
        "topk_preds": [
            "select teacher.Hometown",
            "select teacher.Hometown, teacher.birthyear",
            "select teacher.birthyear, teacher.Hometown",
            "select teacher.Hometown (symbol teacher.birthyear)",
            "select teacher.Hometown (syntax teacher.birthyear)",
            "select teacher.Hometown (select teacher.birthyear)",
            "select teacher.Hometown (or teacher.birthyear)",
            "select teacher.Hometown, max(teacher.birthyear)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Where is the youngest teacher from?, database: Database: course_teach_0. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: name, c2: birthyear, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of teachers in ascending order of age., database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY ",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM\u2013ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of teachers in ascending order of age., database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name",
        "real_label": "select teacher.first_name, teacher.last_name",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.Age",
            "select teacher.first_name, teacher.last_name, teacher.Age",
            "select teacher.first_name, teacher.last_name in teacher.Age",
            "select teacher.first_name, teacher.last_name the, teacher.Age",
            "select teacher.first_name, teacher.last_name, teacher.Age",
            "select teacher.first_name, teacher.last_name or teacher.Age",
            "select teacher.first_name, teacher.last_name (ORDER BY"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of teachers in ascending order of age., database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the teachers ordered by ascending age?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY ("
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the teachers ordered by ascending age?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name",
        "real_label": "select teacher.first_name, teacher.last_name",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.Age",
            "select teacher.first_name, teacher.last_name in teacher.Age",
            "select teacher.first_name, teacher.last_name or teacher.Age",
            "select teacher.first_name, teacher.last_name (ORDER BY",
            "select teacher.first_name, teacher.last_name, teacher.Age",
            "select teacher.first_name, teacher.last_name (ordered by",
            "select t1.c 1, teacher.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the teachers ordered by ascending age?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the name of teachers whose hometown is not  Little Lever Urban District ''., database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the name of teachers whose hometown is not  Little Lever Urban District ''., database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name",
        "real_label": "select teacher.first_name, teacher.last_name",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.Age",
            "select teacher.Teacher_ID, teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.Age, teacher.Hometown",
            "select teacher.first_name, teacher.last_name, teacher.Hometown",
            "select teacher.first_name, teacher.last_name, teacher.Teacher_ID",
            "select teacher.first_name, teacher.last_name, teacher.first_name, teacher.last_name",
            "select t1.c 1, teacher.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the name of teachers whose hometown is not  Little Lever Urban District ''., database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the teachers whose hometown is not  Little Lever Urban District ''?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the teachers whose hometown is not  Little Lever Urban District ''?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name",
        "real_label": "select teacher.first_name, teacher.last_name",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.Age",
            "select teacher.Teacher_ID, teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.Hometown",
            "select teacher.first_name, teacher.last_name, teacher.Teacher_ID",
            "select t1.c 1, teacher.last_name",
            "select teacher.first_name, teacher.last_name, t1.c5",
            "select teacher.first_name, teacher.last_name - teacher.Hometown"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the teachers whose hometown is not  Little Lever Urban District ''?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the name of teachers aged either 32 or 33?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the name of teachers aged either 32 or 33?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name",
        "real_label": "select teacher.first_name, teacher.last_name",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.Age",
            "select teacher.Teacher_ID, teacher.first_name, teacher.last_name",
            "select t1.c 1, teacher.last_name",
            "select teacher.first_name, teacher.Age",
            "select teacher.first_name, teacher.last_name (or teacher.Age)",
            "select teacher.first_name, teacher.last_name,",
            "select teacher.first_name, teacher.last_name."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the name of teachers aged either 32 or 33?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the teachers who are aged either 32 or 33?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-C1, t1.c2"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the teachers who are aged either 32 or 33?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name",
        "real_label": "select teacher.first_name, teacher.last_name",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.Age",
            "select distinct teacher.first_name, teacher.last_name",
            "select t1.c 1, teacher.last_name",
            "select teacher.first_name, teacher.last_name,",
            "select the teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name,",
            "select teacher.first_name, teacher.last_name."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the teachers who are aged either 32 or 33?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show names of teachers and the courses they are arranged to teach., database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM t1.c1, t1.c2",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM, SELECT-FROM",
            "SELECT-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show names of teachers and the courses they are arranged to teach., database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2, t0.c2",
        "label": "select t1.c1, t1.c2, t0.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name, course.Course",
        "real_label": "select teacher.first_name, teacher.last_name, course.Course",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name, course.Course",
            "select teacher.first_name, teacher.last_name, course.Staring_Date",
            "select teacher.first_name, teacher.last_name, course.Course, course_arrange.Teacher_ID",
            "select teacher.first_name, teacher.last_name, course.Course, teacher.Teacher_ID",
            "select teacher.first_name, teacher.last_name, t0.c3",
            "select teacher.first_name, teacher.last_name, course.Course_ID",
            "select course_arrange.Teacher_ID, teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show names of teachers and the courses they are arranged to teach., database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "course teacher course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "",
            "",
            "",
            "",
            "",
            "",
            "course teacher"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of each teacher and what course they teach?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-C2, SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of each teacher and what course they teach?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2, t0.c2",
        "label": "select t1.c1, t1.c2, t0.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name, course.Course",
        "real_label": "select teacher.first_name, teacher.last_name, course.Course",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name, course.Course",
            "select teacher.first_name, teacher.last_name, course.Course, teacher.Teacher_ID",
            "select teacher.first_name, teacher.last_name, course.Staring_Date",
            "select teacher.first_name, teacher.last_name, course.Course, course_arrange.Teacher_ID",
            "select teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, course.Course, course_arrange.Course_ID",
            "select teacher.first_name, teacher.last_name, t0.c3",
            "select teacher.first_name, teacher.last_name, course.Course, course.Course_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of each teacher and what course they teach?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "course teacher course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show names of teachers and the courses they are arranged to teach in ascending alphabetical order of the teacher's name., database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2",
            "SELECT-FROM-ORDER BY t0.c2, SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t2.c1, t0.c2",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2, t0.c2",
            "SELECT-FROM-ORDER BY (SELECT-FROM)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show names of teachers and the courses they are arranged to teach in ascending alphabetical order of the teacher's name., database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2, t0.c2",
        "label": "select t1.c1, t1.c2, t0.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name, course.Course",
        "real_label": "select teacher.first_name, teacher.last_name, course.Course",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name, course.Course",
            "select teacher.first_name, teacher.last_name, course.Staring_Date",
            "select teacher.first_name, teacher.last_name, course.Course, course_arrange.Teacher_ID",
            "select teacher.first_name, teacher.last_name, course.Course, course.Course_ID",
            "select teacher.first_name, teacher.last_name, course.Course_ID",
            "select teacher.first_name, teacher.last_name, t0.c3",
            "select teacher.first_name, teacher.last_name, course.Course, course_arrange.Course_ID",
            "select teacher.first_name, t01.c2, course.Course"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show names of teachers and the courses they are arranged to teach in ascending alphabetical order of the teacher's name., database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "course teacher course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the teachers and the courses they teach in ascending alphabetical order by the name of the teacher?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c2, SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (LIMIT, UNION-SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c2, t1.c1",
            "SELECT-FROM-ORDER BY t0.c2, t1.c1, t1.c2",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2, t0.c2"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the teachers and the courses they teach in ascending alphabetical order by the name of the teacher?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2, t0.c2",
        "label": "select t1.c1, t1.c2, t0.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name, course.Course",
        "real_label": "select teacher.first_name, teacher.last_name, course.Course",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name, course.Course",
            "select teacher.first_name, teacher.last_name, course.Staring_Date",
            "select teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, course.Course_ID",
            "select teacher.first_name, teacher.last_name, course.Course, course.Course_ID",
            "select teacher.first_name, teacher.last_name, t0.c3",
            "select teacher.first_name, teacher.last_name, course.Course, teacher.Teacher_ID",
            "select teacher.first_name, teacher.last_name, course.Course, course_arrange.Teacher_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the teachers and the courses they teach in ascending alphabetical order by the name of the teacher?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "course teacher course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the name of the teacher for the math course., database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the name of the teacher for the math course., database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name",
        "real_label": "select teacher.first_name, teacher.last_name",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.Teacher_ID",
            "select teacher.first_name, teacher.last_name, teacher.Age",
            "select t1.c 1, teacher.last_name",
            "select teacher.first_name.c1, teacher.last_name",
            "select teacher.first_name, teacher.last_name,",
            "select teacher.first_name, teacher.last_name, course.Course_ID",
            "select teacher.first_name, teacher.last_name, teacher.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the name of the teacher for the math course., database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "course teacher course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the people who teach math courses?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the people who teach math courses?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name",
        "real_label": "select teacher.first_name, teacher.last_name",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name",
            "select distinct teacher.first_name, teacher.last_name",
            "select unique teacher.first_name, teacher.last_name",
            "select distinctive teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.Age",
            "select distinct teacher.first_name, teacher.last_name, teacher.Age",
            "select separate teacher.first_name, teacher.last_name",
            "select specific teacher.first_name, teacher.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the people who teach math courses?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "course teacher course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show names of teachers and the number of courses they teach., database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GAGGER-GROUP BY",
            "SELECT-FROM-GROUP BY (ORDER BY",
            "SELECT-FROM-GIGROUP BY",
            "SELECT-FROM-GROUP BY -ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show names of teachers and the number of courses they teach., database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2, count(*)",
        "label": "select t1.c1, t1.c2, count(*)",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name, count(*)",
        "real_label": "select teacher.first_name, teacher.last_name, count(*)",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name, count(*)",
            "select teacher.first_name, teacher.last_name, count(*),",
            "select teacher.first_name, teacher.last_name, count(*), teacher.Teacher_ID",
            "select teacher.first_name, teacher.last_name, count(distinct course.Course)",
            "select teacher.first_name, teacher.last_name, count(*), course.Course",
            "select teacher.first_name, teacher.last_name, count(course.Course)",
            "select teacher.first_name, teacher.last_name, count(*), course.Course_ID",
            "select teacher.first_name, teacher.last_name, count(*), course_arrange.Teacher_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show names of teachers and the number of courses they teach., database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the teachers and how many courses do they teach?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GIRL-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GAGGER-GROUP BY",
            "SELECT-FROM-GEO-GROUP BY",
            "SELECT-FROM-GROUP BY -ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the teachers and how many courses do they teach?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2, count(*)",
        "label": "select t1.c1, t1.c2, count(*)",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name, count(*)",
        "real_label": "select teacher.first_name, teacher.last_name, count(*)",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name, count(*)",
            "select teacher.first_name, teacher.last_name, count(*), teacher.Teacher_ID",
            "select teacher.first_name, teacher.last_name, count(*),",
            "select teacher.first_name, teacher.last_name, count(distinct course.Course)",
            "select count(*), teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, count(course.Course)",
            "select teacher.first_name, teacher.last_name, count(*), course.Course",
            "select teacher.first_name, teacher.last_name, count(*), teacher.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the teachers and how many courses do they teach?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show names of teachers that teach at least two courses., database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show names of teachers that teach at least two courses., database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name",
        "real_label": "select teacher.first_name, teacher.last_name",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.Age",
            "select teacher.first_name, teacher.last_name, teacher.Teacher_ID",
            "select teacher.first_name, teacher.last_name, t0.c3",
            "select teacher.first_name, teacher.last_name,",
            "select teacher.first_name, teacher.last_name, course.Staring_Date",
            "select t1.c 1, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.Hometown"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show names of teachers that teach at least two courses., database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the teachers who teach at least two courses?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the teachers who teach at least two courses?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name",
        "real_label": "select teacher.first_name, teacher.last_name",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.Age",
            "select teacher.first_name, teacher.last_name, teacher.Teacher_ID",
            "select teacher.Teacher_ID, teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, t0.c3",
            "select teacher.first_name, teacher.last_name, course.Staring_Date",
            "select teacher.first_name, teacher.last_name,",
            "select teacher.first_name, teacher.last_name, course.Course_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the teachers who teach at least two courses?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of teachers who have not been arranged to teach courses., database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of teachers who have not been arranged to teach courses., database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name",
        "real_label": "select teacher.first_name, teacher.last_name",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.Age",
            "select distinct teacher.first_name, teacher.last_name",
            "select unarranged teacher.first_name, teacher.last_name",
            "select t1.c 1, teacher.last_name",
            "select the teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.Hometown",
            "select teacher.first_name, teacher.last_name, age(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of teachers who have not been arranged to teach courses., database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "teacher course_arrange",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the teachers whose courses have not been arranged?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the teachers whose courses have not been arranged?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name",
        "real_label": "select teacher.first_name, teacher.last_name",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.Age",
            "select teacher.Teacher_ID, teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.Teacher_ID",
            "select unarranged teacher.first_name, teacher.last_name",
            "select t1.c 1, teacher.last_name",
            "select teacher.first_name, teacher.last_name, t0.c3",
            "select teacher.first_name, teacher.last_name, age(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the teachers whose courses have not been arranged?, database: Database: course_teach_1. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: age, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t1",
        "score": false,
        "real_pred": "course teacher",
        "real_label": "teacher",
        "topk_preds": [
            "course teacher",
            "teacher",
            "course teacher course_arrange",
            "teacher course_arrange",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of teachers in ascending order of age., database: Database: course_teach_4. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: birthyear, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY.",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY (t1.c1)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of teachers in ascending order of age., database: Database: course_teach_4. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: birthyear, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.birthyear",
            "select teacher.Name, teacher.birthyear, teacher.Hometown",
            "select teacher.Name, teacher.birthyear - teacher.Hometown",
            "select teacher.Name in teacher.birthyear",
            "select teacher.Name (ORDER BY",
            "select teacher.Name (ordinal)",
            "select teacher.Name, teacher.Hometown"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of teachers in ascending order of age., database: Database: course_teach_4. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: birthyear, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the teachers ordered by ascending age?, database: Database: course_teach_4. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: birthyear, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY.",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY t1.c1",
            "SELECT-FROM-ORDER BY ("
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the teachers ordered by ascending age?, database: Database: course_teach_4. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: birthyear, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.birthyear",
            "select teacher.Name, teacher.birthyear, teacher.Hometown",
            "select teacher.Name (ordered by teacher.birthyear)",
            "select teacher.Name (ordered teacher.birthyear)",
            "select teacher.Name, teacher.birthyear, teacher.Hometown",
            "select teacher.Name or teacher.birthyear",
            "select teacher.Name (ordered by"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the teachers ordered by ascending age?, database: Database: course_teach_4. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: birthyear, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the hometown of the youngest teacher?, database: Database: course_teach_4. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: birthyear, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the hometown of the youngest teacher?, database: Database: course_teach_4. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: birthyear, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select teacher.Hometown",
        "real_label": "select teacher.Hometown",
        "topk_preds": [
            "select teacher.Hometown",
            "select teacher.Hometown, teacher.birthyear",
            "select teacher.birthyear, teacher.Hometown",
            "select teacher.Hometown, teacher.birthyear, teacher.Teacher_ID",
            "select teacher.Hometown, order by-lat.c3",
            "select teacher.Hometown, order by-lat/max(teacher.Hometown)",
            "select teacher.Hometown (ORDER BY-LIMIT)",
            "select teacher.Hometown, order by-lat/max(teacher.birthyear)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the hometown of the youngest teacher?, database: Database: course_teach_4. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: birthyear, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Where is the youngest teacher from?, database: Database: course_teach_4. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: birthyear, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Where is the youngest teacher from?, database: Database: course_teach_4. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: birthyear, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select teacher.Hometown",
        "real_label": "select teacher.Hometown",
        "topk_preds": [
            "select teacher.Hometown",
            "select teacher.Hometown, teacher.birthyear",
            "select teacher.birthyear, teacher.Hometown",
            "select teacher.Hometown (symbol teacher.birthyear)",
            "select teacher.Hometown, max(teacher.birthyear)",
            "select teacher.Hometown (select teacher.birthyear)",
            "select teacher.Hometown (or teacher.birthyear)",
            "select teacher.Hometown (teacher.birthyear)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Where is the youngest teacher from?, database: Database: course_teach_4. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: birthyear, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of teachers in ascending order of age., database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY.",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of teachers in ascending order of age., database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name",
        "real_label": "select teacher.first_name, teacher.last_name",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.birthyear",
            "select teacher.first_name, teacher.last_name in teacher.birthyear",
            "select teacher.first_name, teacher.last_name the, teacher.birthyear",
            "select teacher.first_name, teacher.last_name, teacher.birthyear",
            "select t1.c 1, teacher.last_name",
            "select teacher.first_name, teacher.last_name (ORDER BY",
            "select teacher.first_name, teacher.last_name the teacher.birthyear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of teachers in ascending order of age., database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the teachers ordered by ascending age?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2",
            "SELECT-FROM-ORDER BY (t1.c1), SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY (t1.c1), SELECT-FROM-GROUP BY",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2, t1.c3"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the teachers ordered by ascending age?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name",
        "real_label": "select teacher.first_name, teacher.last_name",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.birthyear",
            "select teacher.first_name, teacher.last_name in teacher.birthyear",
            "select teacher.first_name, teacher.last_name (ORDER BY",
            "select t1.c 1, teacher.last_name",
            "select teacher.first_name, teacher.last_name (ordered by",
            "select teacher.first_name, teacher.last_name-ORDER BY",
            "select teacher.first_name, teacher.last_name (ordned by"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the teachers ordered by ascending age?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the name of teachers whose hometown is not  Little Lever Urban District ''., database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the name of teachers whose hometown is not  Little Lever Urban District ''., database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name",
        "real_label": "select teacher.first_name, teacher.last_name",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.birthyear",
            "select teacher.first_name, teacher.last_name, teacher.Teacher_ID",
            "select teacher.Teacher_ID, teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.Hometown",
            "select teacher.first_name, teacher.last_name, t1.c5",
            "select t1.c 1, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the name of teachers whose hometown is not  Little Lever Urban District ''., database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the teachers whose hometown is not  Little Lever Urban District ''?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the teachers whose hometown is not  Little Lever Urban District ''?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name",
        "real_label": "select teacher.first_name, teacher.last_name",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.birthyear",
            "select teacher.first_name, teacher.last_name, teacher.Hometown",
            "select teacher.first_name, teacher.last_name, teacher.Teacher_ID",
            "select teacher.Teacher_ID, teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, t1.c5",
            "select t1.c 1, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the teachers whose hometown is not  Little Lever Urban District ''?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the hometown of the youngest teacher?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the hometown of the youngest teacher?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c4",
        "label": "select t1.c4",
        "score": true,
        "real_pred": "select teacher.Hometown",
        "real_label": "select teacher.Hometown",
        "topk_preds": [
            "select teacher.Hometown",
            "select teacher.Hometown, teacher.birthyear",
            "select teacher.Hometown, teacher.birthyear, teacher.last_name",
            "select teacher.Hometown, teacher.birthyear, teacher.Hometown",
            "select teacher.Hometown (ORDER BY-LIMIT)",
            "select teacher.Hometown (Order BY-LIMIT)",
            "select teacher.Hometown (or teacher.birthyear)",
            "select teacher.Hometown, order by-lat/max(teacher.birthyear)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the hometown of the youngest teacher?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Where is the youngest teacher from?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Where is the youngest teacher from?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c4",
        "label": "select t1.c4",
        "score": true,
        "real_pred": "select teacher.Hometown",
        "real_label": "select teacher.Hometown",
        "topk_preds": [
            "select teacher.Hometown",
            "select teacher.Hometown, teacher.birthyear",
            "select teacher.Hometown (symbol teacher.birthyear)",
            "select teacher.Hometown (syntax teacher.birthyear)",
            "select teacher.Hometown (select teacher.birthyear)",
            "select teacher.Hometown, teacher.birthyear, teacher.Teacher_ID",
            "select teacher.Hometown, max(teacher.birthyear)",
            "select teacher.Hometown (or teacher.birthyear)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Where is the youngest teacher from?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show names of teachers and the courses they are arranged to teach., database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM t1.c1, t1.c2",
            "SELECT-FROM t1.c1, t1.c2, t0.c3",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM TEXT-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show names of teachers and the courses they are arranged to teach., database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2, t0.c3",
        "label": "select t1.c1, t1.c2, t0.c3",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name, course.Course",
        "real_label": "select teacher.first_name, teacher.last_name, course.Course",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name, course.Course",
            "select teacher.first_name, teacher.last_name, course.starting_day",
            "select teacher.first_name, teacher.last_name, course.Course, course_arrange.Teacher_ID",
            "select course_arrange.Teacher_ID, teacher.first_name, teacher.last_name",
            "select course_arrange.Teacher_ID, teacher.first_name, course.Course",
            "select teacher.first_name, teacher.last_name, course.staring_month",
            "select teacher.first_name, teacher.last_name, course.Course, course_arrange.Course_ID",
            "select distinct teacher.first_name, teacher.last_name, course.Course"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show names of teachers and the courses they are arranged to teach., database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "course teacher course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "",
            "",
            "",
            "",
            "",
            "",
            "course teacher"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of each teacher and what course they teach?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of each teacher and what course they teach?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2, t0.c3",
        "label": "select t1.c1, t1.c2, t0.c3",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name, course.Course",
        "real_label": "select teacher.first_name, teacher.last_name, course.Course",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name, course.Course",
            "select teacher.first_name, teacher.last_name, course.Course, course_arrange.Teacher_ID",
            "select teacher.first_name, teacher.last_name, course.Course, teacher.Teacher_ID",
            "select teacher.first_name, teacher.last_name, course.Course, course_arrange.Course_ID",
            "select teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, course.starting_day",
            "select distinct teacher.first_name, teacher.last_name, course.Course",
            "select teacher.first_name, teacher.last_name, course.Course, course_arrange.Grade"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of each teacher and what course they teach?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "course teacher course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show names of teachers and the courses they are arranged to teach in ascending alphabetical order of the teacher's name., database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c3, SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t2.c1, t0.c3",
            "SELECT-FROM-ORDER BY t0.c3, t1.c1, t1.c2",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2, t0.c3",
            "SELECT-FROM-ORDER BY (SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show names of teachers and the courses they are arranged to teach in ascending alphabetical order of the teacher's name., database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2, t0.c3",
        "label": "select t1.c1, t1.c2, t0.c3",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name, course.Course",
        "real_label": "select teacher.first_name, teacher.last_name, course.Course",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name, course.Course",
            "select teacher.first_name, teacher.last_name, course.starting_day",
            "select teacher.first_name, teacher.last_name, course.Course, course_arrange.Teacher_ID",
            "select teacher.first_name, t01.c2, course.Course",
            "select teacher.first_name, teacher.last_name, course.Course, course_arrange.Course_ID",
            "select teacher.first_name, teacher.last_name, course.staring_month",
            "select course_arrange.Teacher_ID, teacher.first_name, course.Course",
            "select teacher.first_name, teacher.last_name, t0-c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show names of teachers and the courses they are arranged to teach in ascending alphabetical order of the teacher's name., database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "course teacher course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the teachers and the courses they teach in ascending alphabetical order by the name of the teacher?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c3, t1.c1",
            "SELECT-FROM-ORDER BY t0.c1, t1.c2",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.C1, t1.c2",
            "SELECT-FROM-ORDER BY (SELECT-FROM)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the teachers and the courses they teach in ascending alphabetical order by the name of the teacher?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2, t0.c3",
        "label": "select t1.c1, t1.c2, t0.c3",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name, course.Course",
        "real_label": "select teacher.first_name, teacher.last_name, course.Course",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name, course.Course",
            "select teacher.first_name, teacher.last_name, course.Course, course.Course_ID",
            "select teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, course.starting_day",
            "select teacher.first_name, teacher.last_name, course.Course, teacher.Teacher_ID",
            "select teacher.first_name, teacher.last_name, course.Course, course_arrange.Teacher_ID",
            "select teacher.first_name, teacher.last_name, course.Course_ID",
            "select teacher.first_name, teacher.last_name, course.Course, course_arrange.Course_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the teachers and the courses they teach in ascending alphabetical order by the name of the teacher?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "course teacher course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the name of the teacher for the math course., database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course (Math)). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the name of the teacher for the math course., database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course (Math)). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name",
        "real_label": "select teacher.first_name, teacher.last_name",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.Teacher_ID",
            "select teacher.Teacher_ID, teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.birthyear",
            "select teacher.first_name, teacher.last_name, course.Course",
            "select teacher.first_name.c1, teacher.last_name",
            "select t1.c 1, teacher.last_name",
            "select teacher.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the name of the teacher for the math course., database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course (Math)). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "course teacher course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "",
            "",
            "course teacher",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the people who teach math courses?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course (Math)). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the people who teach math courses?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course (Math)). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name",
        "real_label": "select teacher.first_name, teacher.last_name",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name",
            "select distinct teacher.first_name, teacher.last_name",
            "select unique teacher.first_name, teacher.last_name",
            "select distinctive teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.birthyear",
            "select distinct teacher.first_name, teacher.last_name, teacher.birthyear",
            "select separate teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.Teacher_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the people who teach math courses?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course (Math)). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "course teacher course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show names of teachers and the number of courses they teach., database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-GEO-GROUP BY",
            "SELECT-FROM-GIGROUP BY",
            "SELECT-FROM-GER-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show names of teachers and the number of courses they teach., database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2, count(*)",
        "label": "select t1.c1, t1.c2, count(*)",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name, count(*)",
        "real_label": "select teacher.first_name, teacher.last_name, count(*)",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name, count(*)",
            "select teacher.first_name, teacher.last_name, count(*), teacher.Teacher_ID",
            "select teacher.first_name, teacher.last_name, count(*),",
            "select teacher.first_name, teacher.last_name, count(distinct course.Course)",
            "select teacher.first_name, teacher.last_name, count(*), course.Course",
            "select teacher.first_name, teacher.last_name, count(*), course_arrange.Teacher_ID",
            "select teacher.first_name, teacher.last_name, count(course.Course)",
            "select teacher.first_name, teacher.last_name, count(*), course.Course_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show names of teachers and the number of courses they teach., database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the teachers and how many courses do they teach?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GIRL-GROUP BY",
            "SELECT-FROM-GAGGER-GROUP BY",
            "SELECT-FROM-GROUP BY (ORDER BY",
            "SELECT-FROM-GEO-GROUP BY",
            "SELECT-FROM-GROUP BY -ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the teachers and how many courses do they teach?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2, count(*)",
        "label": "select t1.c1, t1.c2, count(*)",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name, count(*)",
        "real_label": "select teacher.first_name, teacher.last_name, count(*)",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name, count(*)",
            "select teacher.first_name, teacher.last_name, count(*), teacher.Teacher_ID",
            "select teacher.first_name, teacher.last_name, count(*),",
            "select teacher.first_name, teacher.last_name, count(distinct course.Course)",
            "select count(*), teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, count(*), course.Course",
            "select teacher.first_name, teacher.last_name, count(course.Course)",
            "select teacher.first_name, teacher.last_name, count(*), teacher.birthyear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the teachers and how many courses do they teach?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show names of teachers that teach at least two courses., database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show names of teachers that teach at least two courses., database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name",
        "real_label": "select teacher.first_name, teacher.last_name",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.birthyear",
            "select teacher.first_name, teacher.last_name, course.Course",
            "select teacher.first_name, teacher.last_name, teacher.Teacher_ID",
            "select teacher.first_name, teacher.last_name, teacher.Hometown",
            "select teacher.first_name, teacher.last_name, t1.c5",
            "select teacher.first_name, teacher.last_name,",
            "select t1.c 1, teacher.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show names of teachers that teach at least two courses., database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the teachers who teach at least two courses?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the teachers who teach at least two courses?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name",
        "real_label": "select teacher.first_name, teacher.last_name",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.birthyear",
            "select teacher.first_name, teacher.last_name, teacher.Teacher_ID",
            "select teacher.Teacher_ID, teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, course.Course",
            "select teacher.first_name, teacher.last_name, t1.c5",
            "select teacher.first_name, teacher.last_name, teacher.Hometown",
            "select t1.c 1, teacher.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the teachers who teach at least two courses?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of teachers who have not been arranged to teach courses., database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of teachers who have not been arranged to teach courses., database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name",
        "real_label": "select teacher.first_name, teacher.last_name",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.birthyear",
            "select teacher.first_name, teacher.last_name, teacher.Hometown",
            "select distinct teacher.first_name, teacher.last_name",
            "select unarranged teacher.first_name, teacher.last_name",
            "select t1.c 1, teacher.last_name",
            "select the teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, t1.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of teachers who have not been arranged to teach courses., database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "teacher course_arrange",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the teachers whose courses have not been arranged?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the teachers whose courses have not been arranged?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select teacher.first_name, teacher.last_name",
        "real_label": "select teacher.first_name, teacher.last_name",
        "topk_preds": [
            "select teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.birthyear",
            "select teacher.Teacher_ID, teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.Teacher_ID",
            "select unarranged teacher.first_name, teacher.last_name",
            "select teacher.first_name, teacher.last_name, course.Course",
            "select t1.c 1, teacher.last_name",
            "select teacher.first_name, teacher.last_name, teacher.Hometown"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the teachers whose courses have not been arranged?, database: Database: course_teach_5. t0: course(c0: course_id, c1: starting_day, c2: staring_month, c3: course). t1: teacher(c0: teacher_id, c1: first_name, c2: last_name, c3: birthyear, c4: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t1",
        "score": false,
        "real_pred": "course teacher",
        "real_label": "teacher",
        "topk_preds": [
            "course teacher",
            "course teacher course_arrange",
            "teacher",
            "teacher course_arrange",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the names of the visitors whose membership level is higher than 4, and order the results by the level from high to low., database: Database: museum_visit_0. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: first_name, c2: last_name, c3: level_of_membership, c4: birthyear). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-WHERE-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY t1.c1, t1.c2",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY(t1.c1)",
            "SELECT-FROM-WHERE-ORDER BY ",
            "SELECT-FROM-WHERE-ORDER BY.",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the names of the visitors whose membership level is higher than 4, and order the results by the level from high to low., database: Database: museum_visit_0. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: first_name, c2: last_name, c3: level_of_membership, c4: birthyear). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select visitor.first_name, visitor.last_name",
        "real_label": "select visitor.first_name, visitor.last_name",
        "topk_preds": [
            "select visitor.first_name, visitor.last_name",
            "select visitor.first_name, visitor.last_name, visitor.Level_of_membership",
            "select visitor.first_name, visitor.last_name in visitor.Level_of_membership",
            "select visitor.ID, visitor.first_name, visitor.last_name",
            "select visitor.first_name, visitor.last_name and visitor.Level_of_membership",
            "select visitor.first_name, visitor.last_name or visitor.Level_of_membership",
            "select visitor.first_name, visitor.last_name (ORDER BY",
            "select visitor.first_name, visitor.last_name - visitor.Level_of_membership"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the names of the visitors whose membership level is higher than 4, and order the results by the level from high to low., database: Database: museum_visit_0. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: first_name, c2: last_name, c3: level_of_membership, c4: birthyear). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the name and membership level of the visitors whose membership level is higher than 4, and sort by their age from old to young., database: Database: museum_visit_0. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: first_name, c2: last_name, c3: level_of_membership, c4: birthyear). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-WHERE-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY.",
            "SELECT-FROM-WHEREF-ORDER BY",
            "SELECT-FROM-WHERES-ORDER BY",
            "SELECT-FROM-WHERE\u2013ORDER BY",
            "SELECT-FROM-WHEREORDER BY",
            "SELECT-FROM-WHERE-ORDER BY ",
            "SELECT-FROM-WHERE-ORDER BY ("
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the name and membership level of the visitors whose membership level is higher than 4, and sort by their age from old to young., database: Database: museum_visit_0. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: first_name, c2: last_name, c3: level_of_membership, c4: birthyear). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2, t1.c3",
        "label": "select t1.c1, t1.c2, t1.c3",
        "score": true,
        "real_pred": "select visitor.first_name, visitor.last_name, visitor.Level_of_membership",
        "real_label": "select visitor.first_name, visitor.last_name, visitor.Level_of_membership",
        "topk_preds": [
            "select visitor.first_name, visitor.last_name, visitor.Level_of_membership",
            "select visitor.first_name, visitor.last_name, visitor.Level_of_membership, visitor.birthyear",
            "select visitor.first_name, visitor.last_name",
            "select visitor.first_name, visitor.last_name, visitor.Level_of_membership-ordered",
            "select visitor.first_name, visitor.last_name, visitor.Level_of_membership--ORDER BY",
            "select visitor.first_name, visitor.last_name, visitor.Level_of_membership-ORDER BY",
            "select visitor.first_name, visitor.last_name, visitor.Level_of_membership-sorted by visitor.birthyear",
            "select visitor.first_name, visitor.last_name, visitor.Level_of_membership sort(visitor.birthyear)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the name and membership level of the visitors whose membership level is higher than 4, and sort by their age from old to young., database: Database: museum_visit_0. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: first_name, c2: last_name, c3: level_of_membership, c4: birthyear). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the id, name and membership level of visitors who have spent the largest amount of money in total in all museum tickets?, database: Database: museum_visit_0. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: first_name, c2: last_name, c3: level_of_membership, c4: birthyear). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GEORGE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the id, name and membership level of visitors who have spent the largest amount of money in total in all museum tickets?, database: Database: museum_visit_0. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: first_name, c2: last_name, c3: level_of_membership, c4: birthyear). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t2.c1, t1.c1, t1.c2, t1.c3",
        "label": "select t2.c1, t1.c1, t1.c2, t1.c3",
        "score": true,
        "real_pred": "select visit.visitor_ID, visitor.first_name, visitor.last_name, visitor.Level_of_membership",
        "real_label": "select visit.visitor_ID, visitor.first_name, visitor.last_name, visitor.Level_of_membership",
        "topk_preds": [
            "select visit.visitor_ID, visitor.first_name, visitor.last_name, visitor.Level_of_membership",
            "select visitor.ID, visitor.first_name, visitor.last_name, visitor.Level_of_membership",
            "select visit.visitor_ID, visitor.ID, visitor.first_name, visitor.last_name, visitor.Level_of_membership",
            "select visit.Museum_ID, visitor.first_name, visitor.last_name, visitor.Level_of_membership",
            "select visit.visitor_ID, visitor.ID, visitor.first_name, visitor.last_name, visitor.Level_of_membership",
            "select visit.visitor_ID, visitor.ID, visitor.last_name, visitor.Level_of_membership",
            "select visit.visitor_ID, visitor.first_name, visitor.last_name, visitor.Level_of_membership",
            "select visitor.ID, visitor.last_name, visitor.Level_of_membership"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the id, name and membership level of visitors who have spent the largest amount of money in total in all museum tickets?, database: Database: museum_visit_0. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: first_name, c2: last_name, c3: level_of_membership, c4: birthyear). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "visitor visit",
        "real_label": "visitor visit",
        "topk_preds": [
            "visitor visit",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the visitor who visited both a museum opened before 2009 and a museum opened after 2011?, database: Database: museum_visit_0. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: first_name, c2: last_name, c3: level_of_membership, c4: birthyear). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WITH-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT\u2013FROM-WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the visitor who visited both a museum opened before 2009 and a museum opened after 2011?, database: Database: museum_visit_0. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: first_name, c2: last_name, c3: level_of_membership, c4: birthyear). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select visitor.first_name, visitor.last_name",
        "real_label": "select visitor.first_name, visitor.last_name",
        "topk_preds": [
            "select visitor.first_name, visitor.last_name",
            "select visitor.first_name, visitor.last_name, museum.Open_Year",
            "select visitor.first_name, visitor.last_name, visitor.birthyear",
            "select visitor.first_name, visitor.last_name, visitor.ID",
            "select visitor.first_name, visitor.last_name, museum.Name",
            "select visitor.first_name, visitor.last_name, visitor.Level_of_membership",
            "select visitor.first_name, visitor.last_name, visit.visitor_ID",
            "select visitor.first_name, visitor.last_name, museum.Museum_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the visitor who visited both a museum opened before 2009 and a museum opened after 2011?, database: Database: museum_visit_0. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: first_name, c2: last_name, c3: level_of_membership, c4: birthyear). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "museum visitor visit",
        "real_label": "museum visitor visit",
        "topk_preds": [
            "museum visitor visit",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the name and membership level of the visitors whose membership level is higher than 4, and sort by their age from old to young., database: Database: museum_visit_1. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: birthyear). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-WHERE-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY t1.c1, t1.c2",
            "SELECT-FROM-WHERE-ORDER BY.",
            "SELECT-FROM-WHERE-ORDER BY(t1.c1)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHEREF-ORDER BY",
            "SELECT-FROM-WHERES-ORDER BY",
            "SELECT-FROM-WHERE\u2013ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the name and membership level of the visitors whose membership level is higher than 4, and sort by their age from old to young., database: Database: museum_visit_1. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: birthyear). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select visitor.Name, visitor.Level_of_membership",
        "real_label": "select visitor.Name, visitor.Level_of_membership",
        "topk_preds": [
            "select visitor.Name, visitor.Level_of_membership",
            "select visitor.Name, visitor.Level_of_membership, visitor.birthyear",
            "select visitor.Name, visitor.Level_of_membership sort by visitor.birthyear",
            "select visitor.Name, visitor.Level_of_membership sorting by visitor.birthyear",
            "select visitor.Name, visitor.Level_of_membership and visitor.birthyear",
            "select visitor.Name, visitor.Level_of_membership in visitor.birthyear",
            "select visitor.Name, visitor.Level_of_membership or visitor.birthyear",
            "select visitor.Name, visitor.Level_of_membership, visitor.birthyear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the name and membership level of the visitors whose membership level is higher than 4, and sort by their age from old to young., database: Database: museum_visit_1. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: birthyear). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the first name and birth date of all players from the country with code USA., database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code (USA)). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc (USA), c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc (USA), c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT.c1, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the first name and birth date of all players from the country with code USA., database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code (USA)). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc (USA), c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc (USA), c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c5",
        "label": "select t0.c1, t0.c4, t0.c5",
        "score": false,
        "real_pred": "select players.first_name, players.bithday",
        "real_label": "select players.first_name, players.birthyear, players.bithday",
        "topk_preds": [
            "select players.first_name, players.bithday",
            "select players.first_name, players.birthyear",
            "select players.first_name, players.last_name",
            "select players.first_name, players.birthyear, players.bithday",
            "select players.first_name, players.last_name, players.bithday",
            "select distinct players.first_name, players.bithday",
            "select players.first_name, players.is_right_handed",
            "select players.first_name, players.bithday, players.country_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the first name and birth date of all players from the country with code USA., database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code (USA)). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc (USA), c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc (USA), c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the first names and birth dates of players from the USA?, database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code (USA)). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc (USA), c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc (USA), c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the first names and birth dates of players from the USA?, database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code (USA)). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc (USA), c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc (USA), c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c5",
        "label": "select t0.c1, t0.c4, t0.c5",
        "score": false,
        "real_pred": "select players.first_name, players.bithday",
        "real_label": "select players.first_name, players.birthyear, players.bithday",
        "topk_preds": [
            "select players.first_name, players.bithday",
            "select players.first_name, players.last_name",
            "select players.first_name, players.last_name, players.bithday",
            "select players.first_name, players.birthyear",
            "select players.first_name, players.last_name, players.is_right_handed, players.bithday",
            "select players.first_name, players.last_name, players.is_right_handed",
            "select players.first_name, players.last_name, players.birthyear",
            "select players.first_name, players.last_name, players.is_right_handed, players.birthyear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the first names and birth dates of players from the USA?, database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code (USA)). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc (USA), c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc (USA), c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the first name and country code of the oldest player., database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the first name and country code of the oldest player., database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c6",
        "label": "select t0.c1, t0.c6",
        "score": true,
        "real_pred": "select players.first_name, players.country_code",
        "real_label": "select players.first_name, players.country_code",
        "topk_preds": [
            "select players.first_name, players.country_code",
            "select players.player_id, players.first_name, players.country_code",
            "select players.first_name, players.country_code, players.player_id",
            "select players.first_name, players.last_name, players.country_code",
            "select players.first_name, players.country_code, t0.c7",
            "select players.first_name, players.country_code, players.birthyear",
            "select players.first_name, players.country_code)",
            "select players.first_name, players.country_code, players.bithday"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the first name and country code of the oldest player., database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the first name and country code of the oldest player?, database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the first name and country code of the oldest player?, database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c6",
        "label": "select t0.c1, t0.c6",
        "score": true,
        "real_pred": "select players.first_name, players.country_code",
        "real_label": "select players.first_name, players.country_code",
        "topk_preds": [
            "select players.first_name, players.country_code",
            "select players.player_id, players.first_name, players.country_code",
            "select players.first_name, players.country_code, players.player_id",
            "select players.first_name, players.last_name, players.country_code",
            "select players.first_name, players.country_code)",
            "select players.first_name, players.country_code, t0.c7",
            "select players.first_name, players.country_code, players.birthyear",
            "select players.first_name, players.country_code,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the first name and country code of the oldest player?, database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the first and last name of all players in the order of birth date., database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name (Date, Last), c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the first and last name of all players in the order of birth date., database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name (Date, Last), c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select players.first_name, players.last_name",
        "real_label": "select players.first_name, players.last_name",
        "topk_preds": [
            "select players.first_name, players.last_name",
            "select players.first_name, players.last_name, players.bithday",
            "select players.first_name, players.last_name, players.birthyear",
            "select players.first_name, players.last_name (Date, Last)",
            "select players.first_name, players.last_name (Order BY",
            "select players.first_name, players.last_name (Date, Last",
            "select players.first_name, players.last_name (*)",
            "select players.first_name, players.last_name (in-players.bithday)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the first and last name of all players in the order of birth date., database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name (Date, Last), c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the full names of all players, sorted by birth date?, database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1, t0.c2 (WHERE-ORDER BY",
            "SELECT-FROM-ORDER BY t0",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the full names of all players, sorted by birth date?, database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select players.first_name, players.last_name",
        "real_label": "select players.first_name, players.last_name",
        "topk_preds": [
            "select players.first_name, players.last_name",
            "select players.first_name, players.last_name, players.birthyear",
            "select players.first_name, players.last_name (ORDER BY",
            "select players.first_name, players.last_name, players.bithday",
            "select players.first_name, players.last_name (Order BY",
            "select players.first_name, players.last_name (Ordered BY",
            "select players.first_name, players.last_name in players.birthyear",
            "select players.first_name, players.last_name (Ordered by"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the full names of all players, sorted by birth date?, database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the first and last name of all players who are left / L hand in the order of birth date., database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name (Date, Last), c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-WHERE-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-ORDER BY.",
            "SELECT-FROM-WHERE-ORDER BY "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the first and last name of all players who are left / L hand in the order of birth date., database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name (Date, Last), c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select players.first_name, players.last_name",
        "real_label": "select players.first_name, players.last_name",
        "topk_preds": [
            "select players.first_name, players.last_name",
            "select players.first_name, players.last_name, players.is_right_handed",
            "select players.first_name, players.last_name (Date, Last)",
            "select players.first_name, players.last_name in players.is_right_handed",
            "select players.first_name, players.last_name (Order BY",
            "select players.first_name, players.last_name in players.birthyear",
            "select players.first_name, players.last_name (\"Date, Last\")",
            "select players.first_name, players.last_name (Date, Last"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the first and last name of all players who are left / L hand in the order of birth date., database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name (Date, Last), c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the full names of all left handed players, in order of birth date?, database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-WHERE-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY(t0.c1), t0.c2",
            "SELECT-FROM-WHERE-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-WHERE-ORDER BY(t0.c1) - SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-ORDER BY.",
            "SELECT-FROM-WHEREF-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the full names of all left handed players, in order of birth date?, database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select players.first_name, players.last_name",
        "real_label": "select players.first_name, players.last_name",
        "topk_preds": [
            "select players.first_name, players.last_name",
            "select players.first_name, players.last_name, players.is_right_handed",
            "select players.first_name, players.last_name (Date)",
            "select players.first_name, players.last_name (Order BY",
            "select players.first_name, players.last_name (*)",
            "select players.first_name, players.last_name (players.bithday)",
            "select players.first_name, players.last_name (ORDER BY",
            "select players.first_name, players.last_name (players.birthyear)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the full names of all left handed players, in order of birth date?, database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many different winners both participated in the WTA Championships and were left handed?, database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (WTA Championships), c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-COUNT(*)",
            "SELECT-FROM-WHERE count(*)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-NUM(*)",
            "SELECT-FROM-WHERE-Count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many different winners both participated in the WTA Championships and were left handed?, database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (WTA Championships), c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select count(*)",
        "label": "select count(distinct t1.c27)",
        "score": false,
        "real_pred": "select count(*)",
        "real_label": "select count(distinct matches.winner_name)",
        "topk_preds": [
            "select count(*)",
            "select count(distinct matches.winner_id)",
            "select count(*), matches.winner_entry",
            "select count(distinct matches.loser_age)",
            "select count(distinct matches.loser_ht)",
            "select count(*), matches.is_winner_right_handed",
            "select count(*), matches.winner_id",
            "select count(*), matches.loser_age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many different winners both participated in the WTA Championships and were left handed?, database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (WTA Championships), c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "matches rankings",
            "players matches",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the number of left handed winners who participated in the WTA Championships., database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (WTA Championships), c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM",
            "SELECT-FROM-WHERE-COUNT(*)",
            "SELECT-FROM-WHERE count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the number of left handed winners who participated in the WTA Championships., database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (WTA Championships), c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select count(*)",
        "label": "select count(distinct t1.c27)",
        "score": false,
        "real_pred": "select count(*)",
        "real_label": "select count(distinct matches.winner_name)",
        "topk_preds": [
            "select count(*)",
            "select count(distinct matches.winner_entry)",
            "select count(distinct matches.loser_age)",
            "select count(distinct matches.is_winner_right_handed)",
            "select count(*), matches.winner_entry",
            "select count(left_entry)",
            "select count(distinct matches.winner_age)",
            "select count(*), matches.tourney_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the number of left handed winners who participated in the WTA Championships., database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (WTA Championships), c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "matches rankings",
            "",
            "",
            "",
            "rankings",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the first name, country code and birth date of the winner who has the highest rank points in all matches., database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the first name, country code and birth date of the winner who has the highest rank points in all matches., database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c6, t0.c5",
        "label": "select t0.c1, t0.c6, t0.c4, t0.c5",
        "score": false,
        "real_pred": "select players.first_name, players.country_code, players.bithday",
        "real_label": "select players.first_name, players.country_code, players.birthyear, players.bithday",
        "topk_preds": [
            "select players.first_name, players.country_code, players.bithday",
            "select players.first_name, players.last_name, players.country_code",
            "select players.first_name, players.bithday, players.country_code",
            "select players.first_name, players.birthyear, players.bithday",
            "select players.first_name, players.is_right_handed, players.country_code",
            "select players.first_name, players.country_code, players.birthyear",
            "select players.first_name, players.country_code, t0.c 5",
            "select matches.winner_name, players.country_code, players.bithday"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the first name, country code and birth date of the winner who has the highest rank points in all matches., database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "players matches",
        "real_label": "players matches",
        "topk_preds": [
            "players matches",
            "players matches rankings",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the first name, country code, and birth date of the player with the most winner rank points across all matches?, database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the first name, country code, and birth date of the player with the most winner rank points across all matches?, database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c6, t0.c5",
        "label": "select t0.c1, t0.c6, t0.c4, t0.c5",
        "score": false,
        "real_pred": "select players.first_name, players.country_code, players.bithday",
        "real_label": "select players.first_name, players.country_code, players.birthyear, players.bithday",
        "topk_preds": [
            "select players.first_name, players.country_code, players.bithday",
            "select players.first_name, players.last_name, players.country_code, players.bithday",
            "select players.first_name, players.country_code, players.birthyear",
            "select players.first_name, players.birthyear, players.bithday",
            "select players.first_name, players.bithday, players.country_code",
            "select players.first_name, players.last_name, players.country_code",
            "select players.first_name, players.is_right_handed, players.country_code",
            "select players.first_name, players.country_code, t0.c 5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the first name, country code, and birth date of the player with the most winner rank points across all matches?, database: Database: wta_1_0. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: is_right_handed, c4: birthyear, c5: bithday, c6: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: is_winner_right_handed, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "players matches",
        "real_label": "players matches",
        "topk_preds": [
            "players matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the first and last name of all players who are left / L hand in the order of birth date., database: Database: wta_1_3. t0: players(c0: player_id, c1: first_name, c2: last_name (Date, Last), c3: is_right_handed, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-WHERE-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-ORDER BY.",
            "SELECT-FROM-WHERE-ORDER BY "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the first and last name of all players who are left / L hand in the order of birth date., database: Database: wta_1_3. t0: players(c0: player_id, c1: first_name, c2: last_name (Date, Last), c3: is_right_handed, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select players.first_name, players.last_name",
        "real_label": "select players.first_name, players.last_name",
        "topk_preds": [
            "select players.first_name, players.last_name",
            "select players.first_name, players.last_name (Date, Last)",
            "select players.first_name, players.last_name, players.is_right_handed",
            "select players.first_name, players.last_name, players.birth_date",
            "select players.first_name, players.last_name (DATE, LAST)",
            "select players.first_name, players.last_name (Date, Last",
            "select players.first_name, players.last_name in players.birth_date",
            "select players.first_name, players.last_name (\"Date, Last\")"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the first and last name of all players who are left / L hand in the order of birth date., database: Database: wta_1_3. t0: players(c0: player_id, c1: first_name, c2: last_name (Date, Last), c3: is_right_handed, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the full names of all left handed players, in order of birth date?, database: Database: wta_1_3. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: is_right_handed, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-WHERE-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY(t0.c1), t0.c2",
            "SELECT-FROM-WHERE-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-ORDER BY.",
            "SELECT-FROM-WHEREF-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the full names of all left handed players, in order of birth date?, database: Database: wta_1_3. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: is_right_handed, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select players.first_name, players.last_name",
        "real_label": "select players.first_name, players.last_name",
        "topk_preds": [
            "select players.first_name, players.last_name",
            "select players.first_name, players.last_name (Date)",
            "select players.first_name, players.last_name, players.is_right_handed",
            "select players.first_name, players.last_name (players.birth_date)",
            "select players.first_name, players.last_name in players.birth_date",
            "select players.first_name, players.last_name, players.birth_date",
            "select players.first_name, players.last_name (*)",
            "select players.first_name, players.last_name(players.birth_date)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the full names of all left handed players, in order of birth date?, database: Database: wta_1_3. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: is_right_handed, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: is_loser_right_handed, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the total number of tours for each ranking date., database: Database: wta_1_4. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface_is_grass, c17: surface_is_hard, c18: surface_is_clay, c19: tourney_date, c20: tourney_id, c21: tourney_level, c22: tourney_name, c23: winner_age, c24: winner_entry, c25: winner_hand, c26: winner_ht, c27: winner_id, c28: winner_ioc, c29: winner_name, c30: winner_rank, c31: winner_rank_points, c32: winner_seed, c33: year) (c27) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: year, c1: month, c2: day, c3: ranking, c4: player_id, c5: ranking_points, c6: tours) (c4) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM for-GROUP BY",
            "SELECT-FROM-GROUP BY.",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM",
            "SELECT-FROM -GROUP BY",
            "SELECT-FROM-GROUP BY -ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the total number of tours for each ranking date., database: Database: wta_1_4. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface_is_grass, c17: surface_is_hard, c18: surface_is_clay, c19: tourney_date, c20: tourney_id, c21: tourney_level, c22: tourney_name, c23: winner_age, c24: winner_entry, c25: winner_hand, c26: winner_ht, c27: winner_id, c28: winner_ioc, c29: winner_name, c30: winner_rank, c31: winner_rank_points, c32: winner_seed, c33: year) (c27) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: year, c1: month, c2: day, c3: ranking, c4: player_id, c5: ranking_points, c6: tours) (c4) refers to t0(c0).",
        "prediction": "select t2.c3, sum(t2.c6)",
        "label": "select sum(t2.c6), t2.c0, t2.c1, t2.c2",
        "score": false,
        "real_pred": "select rankings.ranking, sum(rankings.tours)",
        "real_label": "select sum(rankings.tours), rankings.year, rankings.month, rankings.day",
        "topk_preds": [
            "select rankings.ranking, sum(rankings.tours)",
            "select rankings.year, sum(rankings.tours)",
            "select rankings.month, sum(rankings.tours)",
            "select rankings.year3, sum(rankings.tours)",
            "select sum(rankings.tours), rankings.ranking",
            "select rankings.day, sum(rankings.tours)",
            "select tour_rankings.ranking, sum(rankings.tours)",
            "select rankings.ranking, sum(rankings.tours)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the total number of tours for each ranking date., database: Database: wta_1_4. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface_is_grass, c17: surface_is_hard, c18: surface_is_clay, c19: tourney_date, c20: tourney_id, c21: tourney_level, c22: tourney_name, c23: winner_age, c24: winner_entry, c25: winner_hand, c26: winner_ht, c27: winner_id, c28: winner_ioc, c29: winner_name, c30: winner_rank, c31: winner_rank_points, c32: winner_seed, c33: year) (c27) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: year, c1: month, c2: day, c3: ranking, c4: player_id, c5: ranking_points, c6: tours) (c4) refers to t0(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "rankings",
        "real_label": "rankings",
        "topk_preds": [
            "rankings",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many total tours were there for each ranking date?, database: Database: wta_1_4. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface_is_grass, c17: surface_is_hard, c18: surface_is_clay, c19: tourney_date, c20: tourney_id, c21: tourney_level, c22: tourney_name, c23: winner_age, c24: winner_entry, c25: winner_hand, c26: winner_ht, c27: winner_id, c28: winner_ioc, c29: winner_name, c30: winner_rank, c31: winner_rank_points, c32: winner_seed, c33: year) (c27) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: year, c1: month, c2: day, c3: ranking, c4: player_id, c5: ranking_points, c6: tours) (c4) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY (ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY (ORDER BY-LIMIT)",
            "SELECT-FROM for-GROUP BY",
            "SELECT-FROM-GROUP BY -ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many total tours were there for each ranking date?, database: Database: wta_1_4. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface_is_grass, c17: surface_is_hard, c18: surface_is_clay, c19: tourney_date, c20: tourney_id, c21: tourney_level, c22: tourney_name, c23: winner_age, c24: winner_entry, c25: winner_hand, c26: winner_ht, c27: winner_id, c28: winner_ioc, c29: winner_name, c30: winner_rank, c31: winner_rank_points, c32: winner_seed, c33: year) (c27) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: year, c1: month, c2: day, c3: ranking, c4: player_id, c5: ranking_points, c6: tours) (c4) refers to t0(c0).",
        "prediction": "select t2.c0, sum(t2.c6)",
        "label": "select sum(t2.c6), t2.c0, t2.c1, t2.c2",
        "score": false,
        "real_pred": "select rankings.year, sum(rankings.tours)",
        "real_label": "select sum(rankings.tours), rankings.year, rankings.month, rankings.day",
        "topk_preds": [
            "select rankings.year, sum(rankings.tours)",
            "select rankings.month, sum(rankings.tours)",
            "select rankings.ranking, sum(rankings.tours)",
            "select rankings.year3, sum(rankings.tours)",
            "select rankings.day, sum(rankings.tours)",
            "select rankings.player_id, sum(rankings.tours)",
            "select sum(rankings.tours), rankings.ranking",
            "select rankings.ranking_points, sum(rankings.tours)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many total tours were there for each ranking date?, database: Database: wta_1_4. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface_is_grass, c17: surface_is_hard, c18: surface_is_clay, c19: tourney_date, c20: tourney_id, c21: tourney_level, c22: tourney_name, c23: winner_age, c24: winner_entry, c25: winner_hand, c26: winner_ht, c27: winner_id, c28: winner_ioc, c29: winner_name, c30: winner_rank, c31: winner_rank_points, c32: winner_seed, c33: year) (c27) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: year, c1: month, c2: day, c3: ranking, c4: player_id, c5: ranking_points, c6: tours) (c4) refers to t0(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "rankings",
        "real_label": "rankings",
        "topk_preds": [
            "rankings",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many ships ended up being 'Captured'?, database: Database: battle_death_0. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: brig_ship, c5: 18-gun_brig_ship, c6: 8_gun_brig_ship, c7: location, c8: is_captured, c9: is_wrecked, c10: is_scuttled, c11: is_sank) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many ships ended up being 'Captured'?, database: Database: battle_death_0. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: brig_ship, c5: 18-gun_brig_ship, c6: 8_gun_brig_ship, c7: location, c8: is_captured, c9: is_wrecked, c10: is_scuttled, c11: is_sank) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), ship.is_captured",
            "select count(*),",
            "select count(*), ship.location",
            "select count(*), ship.is_captured",
            "select count(*) (ship.is_captured)",
            "select count(*), ship.8_gun_brig_ship",
            "select count(*), ship.18-gun_brig_ship"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many ships ended up being 'Captured'?, database: Database: battle_death_0. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: brig_ship, c5: 18-gun_brig_ship, c6: 8_gun_brig_ship, c7: location, c8: is_captured, c9: is_wrecked, c10: is_scuttled, c11: is_sank) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "ship",
        "real_label": "ship",
        "topk_preds": [
            "ship",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the different ids and names of the battles that lost any 'Brig' type shipes?, database: Database: battle_death_0. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: brig_ship, c5: 18-gun_brig_ship, c6: 8_gun_brig_ship, c7: location, c8: is_captured, c9: is_wrecked, c10: is_scuttled, c11: is_sank) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the different ids and names of the battles that lost any 'Brig' type shipes?, database: Database: battle_death_0. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: brig_ship, c5: 18-gun_brig_ship, c6: 8_gun_brig_ship, c7: location, c8: is_captured, c9: is_wrecked, c10: is_scuttled, c11: is_sank) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select distinct t0.c0, t0.c1",
        "label": "select distinct t0.c0, t0.c1",
        "score": true,
        "real_pred": "select distinct battle.id, battle.name",
        "real_label": "select distinct battle.id, battle.name",
        "topk_preds": [
            "select distinct battle.id, battle.name",
            "select distinct battle.name, battle.id",
            "select distinct battle.name, battle.date",
            "select unique battle.id, battle.name",
            "select different battle.id, battle.name",
            "select battle.id, battle.name",
            "select distinct battle.name, battle.bulgarian_commander",
            "select distinct t0.c, battle.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the different ids and names of the battles that lost any 'Brig' type shipes?, database: Database: battle_death_0. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: brig_ship, c5: 18-gun_brig_ship, c6: 8_gun_brig_ship, c7: location, c8: is_captured, c9: is_wrecked, c10: is_scuttled, c11: is_sank) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "battle ship",
        "real_label": "battle ship",
        "topk_preds": [
            "battle ship",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many ships ended up being 'Captured'?, database: Database: battle_death_1. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: is_captured, c7: is_wrecked, c8: is_scuttled, c9: is_sank) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many ships ended up being 'Captured'?, database: Database: battle_death_1. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: is_captured, c7: is_wrecked, c8: is_scuttled, c9: is_sank) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), ship.is_captured",
            "select count(*),",
            "select count(*), ship.lost_in_battle",
            "select count(*), ship.is_captured",
            "select count(*), ship.id",
            "select count(*) (ship.is_captured)",
            "select count(*), ship.location"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many ships ended up being 'Captured'?, database: Database: battle_death_1. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: is_captured, c7: is_wrecked, c8: is_scuttled, c9: is_sank) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "ship",
        "real_label": "ship",
        "topk_preds": [
            "ship",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the semester which most student registered in? Show both the name and the id., database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-C1, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-C1, SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the semester which most student registered in? Show both the name and the id., database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10:",
        "prediction": "select t5.c1, t5.c0",
        "label": "select t5.c1, t5.c2, t5.c0",
        "score": false,
        "real_pred": "select Semesters.semester_term, Semesters.semester_id",
        "real_label": "select Semesters.semester_term, Semesters.semester_year, Semesters.semester_id",
        "topk_preds": [
            "select Semesters.semester_term, Semesters.semester_id",
            "select Semesters.semester_year, Semesters.semester_id",
            "select Students.first_name, Students.middle_name, Students.student_id",
            "select Students.first_name, Students.middle_name, Semesters.semester_id",
            "select Students.current_address_id, Students.student_id",
            "select Students.first_name, Students.last_name, Semesters.semester_id",
            "select Students.first_name, Students.last_name, Students.student_id",
            "select Semesters.semester_term, Students.student_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the semester which most student registered in? Show both the name and the id., database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_register",
        "prediction": "t5 t6",
        "label": "t5 t7",
        "score": false,
        "real_pred": "Semesters Students",
        "real_label": "Semesters Student_Enrolment",
        "topk_preds": [
            "Semesters Students",
            "",
            "",
            "",
            "",
            "Semesters Students Student_Enrolment_Courses",
            "Departments Semesters Students",
            "Semesters Student_Enrolment_Courses"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For each semester, what is the name and id of the one with the most students registered?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT - SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For each semester, what is the name and id of the one with the most students registered?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10",
        "prediction": "select t5.c1, t5.c0",
        "label": "select t5.c1, t5.c2, t5.c0",
        "score": false,
        "real_pred": "select Semesters.semester_term, Semesters.semester_id",
        "real_label": "select Semesters.semester_term, Semesters.semester_year, Semesters.semester_id",
        "topk_preds": [
            "select Semesters.semester_term, Semesters.semester_id",
            "select Semesters.semester_description, Semesters.semester_id",
            "select Semesters.semester_year, Semesters.semester_id",
            "select Semesters.other_details, Semesters.semester_id",
            "select t5.c6, Semesters.semester_id",
            "select t5.c5, Semesters.semester_id",
            "select Students.current_address_id, Semesters.semester_id",
            "select Semesters.semester_term, t5c0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For each semester, what is the name and id of the one with the most students registered?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_",
        "prediction": "t5 t6",
        "label": "t5 t7",
        "score": false,
        "real_pred": "Semesters Students",
        "real_label": "Semesters Student_Enrolment",
        "topk_preds": [
            "Semesters Students",
            "Courses Semesters Students",
            "Departments Semesters Students",
            "Degree_Programs Semesters Students",
            "Semesters Student_Enrolment_Courses",
            "Semesters Student_Enrolment",
            "",
            "Semesters Students Student_Enrolment_Courses"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who is enrolled in a Bachelor degree program? List the first name, middle name, last name., database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C3, t6.c4, t6.c5",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who is enrolled in a Bachelor degree program? List the first name, middle name, last name., database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c",
        "prediction": "select t6.c3, t6.c4, t6.c5",
        "label": "select distinct t6.c3, t6.c4, t6.c5",
        "score": false,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name",
        "real_label": "select distinct Students.first_name, Students.middle_name, Students.last_name",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select distinct Students.first_name, Students.middle_name, Students.last_name",
            "select Students.student_id, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name.c3, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.current_address_id, Students.middle_name, Students.last_name",
            "select Students.first_name., Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who is enrolled in a Bachelor degree program? List the first name, middle name, last name., database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first",
        "prediction": "t3 t6",
        "label": "t3 t6 t7",
        "score": false,
        "real_pred": "Degree_Programs Students",
        "real_label": "Degree_Programs Students Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Students",
            "Departments Degree_Programs Students",
            "Courses Degree_Programs Students",
            "Addresses Degree_Programs Students",
            "Degree_Programs Students Student_Enrolment_Courses",
            "Degree_Programs Students Student_Enrolment",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the first, middle, and last names for everybody enrolled in a Bachelors program?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the first, middle, and last names for everybody enrolled in a Bachelors program?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10",
        "prediction": "select t6.c3, t6.c4, t6.c5",
        "label": "select distinct t6.c3, t6.c4, t6.c5",
        "score": false,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name",
        "real_label": "select distinct Students.first_name, Students.middle_name, Students.last_name",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.student_id, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name., Students.middle_name, Students.last_name",
            "select Students.current_address_id, Students.middle_name, Students.last_name",
            "select distinct Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name and Students.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the first, middle, and last names for everybody enrolled in a Bachelors program?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_",
        "prediction": "t3 t6",
        "label": "t3 t6 t7",
        "score": false,
        "real_pred": "Degree_Programs Students",
        "real_label": "Degree_Programs Students Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Students",
            "Departments Degree_Programs Students",
            "Addresses Degree_Programs Students",
            "Courses Degree_Programs Students",
            "Degree_Programs Sections Students",
            "",
            "Degree_Programs Students Student_Enrolment",
            "Degree_Programs Students Student_Enrolment_Courses"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which semesters do not have any student enrolled? List the semester name., database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered,",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-HOLD-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which semesters do not have any student enrolled? List the semester name., database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_",
        "prediction": "select t5.c1",
        "label": "select t5.c1, t5.c2",
        "score": false,
        "real_pred": "select Semesters.semester_term",
        "real_label": "select Semesters.semester_term, Semesters.semester_year",
        "topk_preds": [
            "select Semesters.semester_term",
            "select Semesters.semester_term, Semesters.semester_description",
            "select Semesters.semester_term, Semesters.semester_year",
            "select Semesters.semester_term, Students.student_id",
            "select Semesters.semester_term, Students.permanent_address_id",
            "select Semesters.semester_term, Students.current_address_id3",
            "select Semesters.semester_term, Students.current_address_id",
            "select Semesters.semester_term, Students.time_first_registered"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which semesters do not have any student enrolled? List the semester name., database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, ",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Semesters",
        "real_label": "Semesters",
        "topk_preds": [
            "Semesters",
            "Semesters Students",
            "",
            "Semesters Student_Enrolment_Courses",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the semester with no students enrolled?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c11",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-HAVE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-HOLD-EXCEPT-SELECT-FROM",
            "SELECT-FROM-FROM-EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the semester with no students enrolled?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered",
        "prediction": "select t5.c1",
        "label": "select t5.c1, t5.c2",
        "score": false,
        "real_pred": "select Semesters.semester_term",
        "real_label": "select Semesters.semester_term, Semesters.semester_year",
        "topk_preds": [
            "select Semesters.semester_term",
            "select Semesters.semester_term, Semesters.semester_description",
            "select Semesters.semester_description",
            "select Semesters.semester_term, Semesters.semester_year",
            "select Semesters.semester_term, Semesters.semester_year, Semesters.semester_description",
            "select Semesters.semester_term, Semesters.semester_description, Semesters.other_details",
            "select Semesters.semester_term, Semesters.semester_description, Semesters.semester_year",
            "select Semesters.semester_description, Semesters.semester_year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the semester with no students enrolled?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c11:",
        "prediction": "t5 t6",
        "label": "t5",
        "score": false,
        "real_pred": "Semesters Students",
        "real_label": "Semesters",
        "topk_preds": [
            "Semesters Students",
            "Semesters Student_Enrolment_Courses",
            "Semesters Student_Enrolment",
            "Semesters Transcripts",
            "",
            "",
            "Semesters",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the date and id of the transcript with at least 2 course results., database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the date and id of the transcript with at least 2 course results., database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first",
        "prediction": "select t12.c5, t12.c0",
        "label": "select t9.c1, t9.c2, t10.c1",
        "score": false,
        "real_pred": "select t12.c5, t12.c0",
        "real_label": "select Transcripts.transcript_date, Transcripts.transcript_time, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t12.c5, t12.c0",
            "select t8.c5, Student_Enrolment_Courses.student_course_id",
            "select t12.c3, t12.c0",
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t14.c5, t14.c0",
            "select t12.c0, t12.c3",
            "select t11.c3, t11.c4",
            "select t12.c5, t12.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the date and id of the transcript with at least 2 course results., database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered,",
        "prediction": "t8",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Student_Enrolment_Courses",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Student_Enrolment_Courses",
            "Transcripts",
            "Student_Enrolment",
            "",
            "Students Student_Enrolment_Courses",
            "Transcript_Contents",
            "Transcripts Transcript_Contents",
            "Student_Enrolment_Courses Transcripts"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the date and id of the transcript with at least 2 courses listed?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registere",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING In-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the date and id of the transcript with at least 2 courses listed?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_",
        "prediction": "select t12.c5, t12.c0",
        "label": "select t9.c1, t9.c2, t10.c1",
        "score": false,
        "real_pred": "select t12.c5, t12.c0",
        "real_label": "select Transcripts.transcript_date, Transcripts.transcript_time, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t12.c5, t12.c0",
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t12.c3, t12.c0",
            "select t12.c0, t12.c3",
            "select t11.c3, t11.c4",
            "select t14.c5, t14.c0",
            "select t11.c3, t11.c0",
            "select t14.c3, t14.c0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the date and id of the transcript with at least 2 courses listed?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered",
        "prediction": "t1 t8",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Courses Student_Enrolment_Courses",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Courses Student_Enrolment_Courses",
            "Courses Student_Enrolment",
            "Courses Transcripts",
            "Courses Sections",
            "Courses Students",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who is the first student to register? List the first name, middle name and last name., database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_register",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who is the first student to register? List the first name, middle name and last name., database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time",
        "prediction": "select t6.c3, t6.c4, t6.c5",
        "label": "select t6.c3, t6.c4, t6.c5",
        "score": true,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name",
        "real_label": "select Students.first_name, Students.middle_name, Students.last_name",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.student_id, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name., Students.middle_name, Students.last_name",
            "select Students.current_address_id, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name.",
            "select t 6.c3, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who is the first student to register? List the first name, middle name and last name., database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registere",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Students",
        "real_label": "Students",
        "topk_preds": [
            "Students",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the first, middle, and last name of the first student to register?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the first, middle, and last name of the first student to register?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first",
        "prediction": "select t6.c3, t6.c4, t6.c5",
        "label": "select t6.c3, t6.c4, t6.c5",
        "score": true,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name",
        "real_label": "select Students.first_name, Students.middle_name, Students.last_name",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.student_id, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name., Students.middle_name, Students.last_name",
            "select t6, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name), Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the first, middle, and last name of the first student to register?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered,",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Students",
        "real_label": "Students",
        "topk_preds": [
            "Students",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When is the first transcript released? List the date and details., database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c11",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When is the first transcript released? List the date and details., database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered",
        "prediction": "select t12.c5, t12.c6",
        "label": "select t9.c1, t9.c2, t9.c3",
        "score": false,
        "real_pred": "select t12.c5, t12.c6",
        "real_label": "select Transcripts.transcript_date, Transcripts.transcript_time, Transcripts.other_details",
        "topk_preds": [
            "select t12.c5, t12.c6",
            "select t8.c5, t8.c6",
            "select t12.c9, t12.c3",
            "select t8.c9, Student_Enrolment_Courses.course_id0",
            "select t7.c5, t7.c6",
            "select t8.c9, t8.c3",
            "select t12.c9, t12.c2",
            "select t1.c5, t1.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When is the first transcript released? List the date and details., database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c11:",
        "prediction": "t9",
        "label": "t9",
        "score": true,
        "real_pred": "Transcripts",
        "real_label": "Transcripts",
        "topk_preds": [
            "Transcripts",
            "Courses",
            "Transcript_Contents",
            "Courses Student_Enrolment_Courses",
            "Student_Enrolment_Courses",
            "",
            "",
            "Addresses Student_Enrolment_Courses"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the earliest date of a transcript release, and what details can you tell me?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the earliest date of a transcript release, and what details can you tell me?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10:",
        "prediction": "select t8.c5, t8.c6",
        "label": "select t9.c1, t9.c2, t9.c3",
        "score": false,
        "real_pred": "select t8.c5, t8.c6",
        "real_label": "select Transcripts.transcript_date, Transcripts.transcript_time, Transcripts.other_details",
        "topk_preds": [
            "select t8.c5, t8.c6",
            "select t12.c5, t12.c6",
            "select t13.c5, t13.c6",
            "select t10.c5, t10.c6",
            "select t14.c5, t14.c6",
            "select t1.c5, t1.c6",
            "select t9.c5, t9.c6",
            "select t2.c5, t2.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the earliest date of a transcript release, and what details can you tell me?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_register",
        "prediction": "t9",
        "label": "t9",
        "score": true,
        "real_pred": "Transcripts",
        "real_label": "Transcripts",
        "topk_preds": [
            "Transcripts",
            "Transcript_Contents",
            "",
            "Student_Enrolment",
            "",
            "",
            "",
            "Student_Enrolment_Courses"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the last transcript release date?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c11: date_left,",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the last transcript release date?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c11:",
        "prediction": "select t12.c5",
        "label": "select t9.c1, t9.c2",
        "score": false,
        "real_pred": "select t12.c5",
        "real_label": "select Transcripts.transcript_date, Transcripts.transcript_time",
        "topk_preds": [
            "select t12.c5",
            "select t8.c5",
            "select t13.c5",
            "select max(t8.c3)",
            "select max(t8.c5)",
            "select max(t8.c7)",
            "select t10.c5",
            "select max(t8.c6)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the last transcript release date?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c11: date_left, ",
        "prediction": "t12",
        "label": "t9",
        "score": false,
        "real_pred": "Courses2",
        "real_label": "Transcripts",
        "topk_preds": [
            "",
            "Student_Enrolment_Courses",
            "Transcripts",
            "Student_Enrolment",
            "",
            "Transcript_Contents",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When was the last transcript released?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c11: date_left, ",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM.ORDER BY-LIMIT",
            "SELECT-FROM-OCT-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When was the last transcript released?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c11: date",
        "prediction": "select t12.c5",
        "label": "select t9.c1, t9.c2",
        "score": false,
        "real_pred": "select t12.c5",
        "real_label": "select Transcripts.transcript_date, Transcripts.transcript_time",
        "topk_preds": [
            "select t12.c5",
            "select t8.c5",
            "select t10.c5",
            "select t13.c5",
            "select t9.c5",
            "select max(t10.c5)",
            "select t11.c3",
            "select max(t8.c6)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When was the last transcript released?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c11: date_left, c",
        "prediction": "t9",
        "label": "t9",
        "score": true,
        "real_pred": "Transcripts",
        "real_label": "Transcripts",
        "topk_preds": [
            "Transcripts",
            "Student_Enrolment_Courses",
            "",
            "Transcript_Contents",
            "",
            "",
            "Student_Enrolment",
            "Transcripts Transcript_Contents"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the date of the transcript which shows the least number of results, also list the id., database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, t8.c0"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the date of the transcript which shows the least number of results, also list the id., database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10",
        "prediction": "select t12.c5, t12.c0",
        "label": "select t9.c1, t9.c2, t10.c1",
        "score": false,
        "real_pred": "select t12.c5, t12.c0",
        "real_label": "select Transcripts.transcript_date, Transcripts.transcript_time, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t12.c5, t12.c0",
            "select t12.c3, t12.c0",
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t12.c0, t12.c3",
            "select t8.c5, Student_Enrolment_Courses.student_course_id",
            "select t12.c1, t12.c0",
            "select t12.c6, t12.c0",
            "select t12.c3, t12.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the date of the transcript which shows the least number of results, also list the id., database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_",
        "prediction": "t8",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Student_Enrolment_Courses",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Student_Enrolment_Courses",
            "Transcripts",
            "Transcript_Contents",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the date and id of the transcript with the least number of results?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registere",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the date and id of the transcript with the least number of results?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_",
        "prediction": "select t12.c5, t12.c0",
        "label": "select t9.c1, t9.c2, t10.c1",
        "score": false,
        "real_pred": "select t12.c5, t12.c0",
        "real_label": "select Transcripts.transcript_date, Transcripts.transcript_time, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t12.c5, t12.c0",
            "select t12.c3, t12.c0",
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t11.c3, t11.c4",
            "select t14.c3, t14.c0",
            "select t12.c0, t12.c3",
            "select t12.c3, t12.c4",
            "select t11.c3, t11.c0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the date and id of the transcript with the least number of results?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered",
        "prediction": "t9",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Transcripts",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Transcripts",
            "",
            "Student_Enrolment_Courses",
            "",
            "Transcripts Transcript_Contents",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the semester when both Master students and Bachelor students got enrolled in., database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, ",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the semester when both Master students and Bachelor students got enrolled in., database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_register",
        "prediction": "select t5.c1",
        "label": "select distinct t7.c2",
        "score": false,
        "real_pred": "select Semesters.semester_term",
        "real_label": "select distinct Student_Enrolment.semester_id",
        "topk_preds": [
            "select Semesters.semester_term",
            "select Semesters.semester_term, Degree_Programs.is_bachelor, Degree_Programs.is_master",
            "select Semesters.semester_term, Semesters.semester_year",
            "select Semesters.semester_term, Degree_Programs.is_bachelor",
            "select Semesters.semester_term, Students.current_address_id3",
            "select Semesters.semester_term, Students.current_address_id",
            "select Semesters.semester_term, Students.current_address_id, Students.permanent_address_id",
            "select Semesters.semester_term, Degree_Programs.is_master"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the semester when both Master students and Bachelor students got enrolled in., database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c",
        "prediction": "t3 t6",
        "label": "t3 t7",
        "score": false,
        "real_pred": "Degree_Programs Students",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Students",
            "",
            "",
            "Departments Degree_Programs Students",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the id of the semester that had both Masters and Bachelors students enrolled?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WITH-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the id of the semester that had both Masters and Bachelors students enrolled?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10:",
        "prediction": "select t5.c1",
        "label": "select distinct t7.c2",
        "score": false,
        "real_pred": "select Semesters.semester_term",
        "real_label": "select distinct Student_Enrolment.semester_id",
        "topk_preds": [
            "select Semesters.semester_term",
            "select Semesters.semester_id",
            "select Semesters.semester_term, Degree_Programs.is_bachelor, Degree_Programs.is_master",
            "select Semesters.semester_id, Degree_Programs.is_bachelor, Degree_Programs.is_master",
            "select Semesters.semester_term, Semesters.semester_year",
            "select Semesters.semester_term, Students.current_address_id",
            "select Students.current_address_id",
            "select Semesters.semester_term, Students.time_first_registered"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the id of the semester that had both Masters and Bachelors students enrolled?, database: Database: student_transcripts_tracking_0. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_term, c2: semester_year, c3: semester_description, c4: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_register",
        "prediction": "t3 t6",
        "label": "t3 t7",
        "score": false,
        "real_pred": "Degree_Programs Students",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Students",
            "Degree_Programs Semesters Students",
            "Degree_Programs Sections Students",
            "Departments Degree_Programs Semesters Students",
            "Departments Degree_Programs Students",
            "Departments Degree_Programs Sections Students",
            "Addresses Degree_Programs Students",
            "Degree_Programs Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who is the first student to register? List the first name, middle name and last name., database: Database: student_transcripts_tracking_1. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: year_first_registered, c10: month_first_registered, c11: day_first_registered, c12: time_first_register",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who is the first student to register? List the first name, middle name and last name., database: Database: student_transcripts_tracking_1. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: year_first_registered, c10: month_first_registered, c11: day_first_registered, c12: time",
        "prediction": "select t6.c3, t6.c4, t6.c5",
        "label": "select t6.c3, t6.c4, t6.c5",
        "score": true,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name",
        "real_label": "select Students.first_name, Students.middle_name, Students.last_name",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.student_id, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name., Students.middle_name, Students.last_name",
            "select Students.current_address_id, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name.",
            "select t 6.c3, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who is the first student to register? List the first name, middle name and last name., database: Database: student_transcripts_tracking_1. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: year_first_registered, c10: month_first_registered, c11: day_first_registered, c12: time_first_registere",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Students",
        "real_label": "Students",
        "topk_preds": [
            "Students",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the first, middle, and last name of the first student to register?, database: Database: student_transcripts_tracking_1. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: year_first_registered, c10: month_first_registered, c11: day_first_registered, c12: time_first_registered",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the first, middle, and last name of the first student to register?, database: Database: student_transcripts_tracking_1. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: year_first_registered, c10: month_first_registered, c11: day_first_registered, c12: time_first",
        "prediction": "select t6.c3, t6.c4, t6.c5",
        "label": "select t6.c3, t6.c4, t6.c5",
        "score": true,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name",
        "real_label": "select Students.first_name, Students.middle_name, Students.last_name",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.student_id, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name., Students.middle_name, Students.last_name",
            "select t6, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
            "select Students.first_name, t 6.c4, Students.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the first, middle, and last name of the first student to register?, database: Database: student_transcripts_tracking_1. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: year_first_registered, c10: month_first_registered, c11: day_first_registered, c12: time_first_registered,",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Students",
        "real_label": "Students",
        "topk_preds": [
            "Students",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who is the earliest graduate of the school? List the first name, middle name and last name., database: Database: student_transcripts_tracking_1. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: year_first_registered, c10: month_first_registered, c11: day_first_registered, c12: time_first",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who is the earliest graduate of the school? List the first name, middle name and last name., database: Database: student_transcripts_tracking_1. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: year_first_registered, c10: month_first_registered, c11: day_first_registered, c12",
        "prediction": "select t6.c3, t6.c4, t6.c5",
        "label": "select t6.c3, t6.c4, t6.c5",
        "score": true,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name",
        "real_label": "select Students.first_name, Students.middle_name, Students.last_name",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.student_id, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name.c3, Students.middle_name, Students.last_name",
            "select Students.first_name., Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name.",
            "select Students.current_address_id, Students.middle_name, Students.last_name",
            "select t 6.c3, Students.middle_name, Students.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who is the earliest graduate of the school? List the first name, middle name and last name., database: Database: student_transcripts_tracking_1. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: year_first_registered, c10: month_first_registered, c11: day_first_registered, c12: time_first_",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Students",
        "real_label": "Students",
        "topk_preds": [
            "Students",
            "",
            "Degree_Programs Sections Students",
            "Degree_Programs Sections Semesters Students",
            "",
            "",
            "Students Student_Enrolment",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the first, middle, and last name of the earliest school graduate?, database: Database: student_transcripts_tracking_1. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: year_first_registered, c10: month_first_registered, c11: day_first_registered, c12: time_first_registered",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the first, middle, and last name of the earliest school graduate?, database: Database: student_transcripts_tracking_1. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: year_first_registered, c10: month_first_registered, c11: day_first_registered, c12: time_first",
        "prediction": "select t6.c3, t6.c4, t6.c5",
        "label": "select t6.c3, t6.c4, t6.c5",
        "score": true,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name",
        "real_label": "select Students.first_name, Students.middle_name, Students.last_name",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.student_id, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name., Students.middle_name, Students.last_name",
            "select Students.first_name), Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name, Students.ssn",
            "select Students.first_name, Students.middle_name, Students.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the first, middle, and last name of the earliest school graduate?, database: Database: student_transcripts_tracking_1. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: year_first_registered, c10: month_first_registered, c11: day_first_registered, c12: time_first_registered,",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Students",
        "real_label": "Students",
        "topk_preds": [
            "Students",
            "",
            "Degree_Programs Sections Semesters Students",
            "Degree_Programs Sections Students",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who is the first student to register? List the first name, middle name and last name., database: Database: student_transcripts_tracking_2. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: year_first_registered, c10: month_first_registered, c11: day_first_registered, c12: time_first_register",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who is the first student to register? List the first name, middle name and last name., database: Database: student_transcripts_tracking_2. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: year_first_registered, c10: month_first_registered, c11: day_first_registered, c12: time",
        "prediction": "select t6.c3, t6.c4, t6.c5",
        "label": "select t6.c3, t6.c4, t6.c5",
        "score": true,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name",
        "real_label": "select Students.first_name, Students.middle_name, Students.last_name",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.student_id, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name., Students.middle_name, Students.last_name",
            "select Students.current_address_id, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name.",
            "select t 6.c3, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who is the first student to register? List the first name, middle name and last name., database: Database: student_transcripts_tracking_2. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: year_first_registered, c10: month_first_registered, c11: day_first_registered, c12: time_first_registere",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Students",
        "real_label": "Students",
        "topk_preds": [
            "Students",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the first, middle, and last name of the first student to register?, database: Database: student_transcripts_tracking_2. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: year_first_registered, c10: month_first_registered, c11: day_first_registered, c12: time_first_registered",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the first, middle, and last name of the first student to register?, database: Database: student_transcripts_tracking_2. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: year_first_registered, c10: month_first_registered, c11: day_first_registered, c12: time_first",
        "prediction": "select t6.c3, t6.c4, t6.c5",
        "label": "select t6.c3, t6.c4, t6.c5",
        "score": true,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name",
        "real_label": "select Students.first_name, Students.middle_name, Students.last_name",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.student_id, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name., Students.middle_name, Students.last_name",
            "select t6, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name, Students.student_id",
            "select Students.first_name, t 6.c4, Students.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the first, middle, and last name of the first student to register?, database: Database: student_transcripts_tracking_2. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: year_first_registered, c10: month_first_registered, c11: day_first_registered, c12: time_first_registered,",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Students",
        "real_label": "Students",
        "topk_preds": [
            "Students",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who is enrolled in a Bachelor degree program? List the first name, middle name, last name., database: Database: student_transcripts_tracking_3. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c11",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C3, t6.c4, t6.c5",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who is enrolled in a Bachelor degree program? List the first name, middle name, last name., database: Database: student_transcripts_tracking_3. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered",
        "prediction": "select t6.c3, t6.c4, t6.c5",
        "label": "select distinct t6.c3, t6.c4, t6.c5",
        "score": false,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name",
        "real_label": "select distinct Students.first_name, Students.middle_name, Students.last_name",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select distinct Students.first_name, Students.middle_name, Students.last_name",
            "select Students.student_id, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name.c3, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.current_address_id, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, t6.c 5",
            "select Students.first_name, Students.middle_name., Students.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who is enrolled in a Bachelor degree program? List the first name, middle name, last name., database: Database: student_transcripts_tracking_3. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c11:",
        "prediction": "t3 t6",
        "label": "t3 t6 t7",
        "score": false,
        "real_pred": "Degree_Programs Students",
        "real_label": "Degree_Programs Students Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Students",
            "Degree_Programs Students Student_Enrolment_Courses",
            "Departments Degree_Programs Students",
            "Courses Degree_Programs Students",
            "Addresses Degree_Programs Students",
            "Degree_Programs Students Student_Enrolment",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the first, middle, and last names for everybody enrolled in a Bachelors program?, database: Database: student_transcripts_tracking_3. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c11:",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C3, t6.c4, t6.c5",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-C3 - SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C3, t6.c4, t6.c 5"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the first, middle, and last names for everybody enrolled in a Bachelors program?, database: Database: student_transcripts_tracking_3. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered,",
        "prediction": "select t6.c3, t6.c4, t6.c5",
        "label": "select distinct t6.c3, t6.c4, t6.c5",
        "score": false,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name",
        "real_label": "select distinct Students.first_name, Students.middle_name, Students.last_name",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.student_id, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name., Students.middle_name, Students.last_name",
            "select Students.current_address_id, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, and Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name and Students.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the first, middle, and last names for everybody enrolled in a Bachelors program?, database: Database: student_transcripts_tracking_3. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c11: date",
        "prediction": "t3 t6",
        "label": "t3 t6 t7",
        "score": false,
        "real_pred": "Degree_Programs Students",
        "real_label": "Degree_Programs Students Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Students",
            "Departments Degree_Programs Students",
            "Addresses Degree_Programs Students",
            "Courses Degree_Programs Students",
            "Degree_Programs Sections Students",
            "Degree_Programs Students Student_Enrolment_Courses",
            "",
            "Degree_Programs Students Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who is the first student to register? List the first name, middle name and last name., database: Database: student_transcripts_tracking_3. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c11: date_",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who is the first student to register? List the first name, middle name and last name., database: Database: student_transcripts_tracking_3. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c",
        "prediction": "select t6.c3, t6.c4, t6.c5",
        "label": "select t6.c3, t6.c4, t6.c5",
        "score": true,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name",
        "real_label": "select Students.first_name, Students.middle_name, Students.last_name",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.student_id, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name., Students.middle_name, Students.last_name",
            "select Students.first_name.c3, Students.middle_name, Students.last_name",
            "select Students.current_address_id, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name.",
            "select t 6.c3, Students.middle_name, Students.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who is the first student to register? List the first name, middle name and last name., database: Database: student_transcripts_tracking_3. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c11: date_left",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Students",
        "real_label": "Students",
        "topk_preds": [
            "Students",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the first, middle, and last name of the first student to register?, database: Database: student_transcripts_tracking_3. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c11: date_left,",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the first, middle, and last name of the first student to register?, database: Database: student_transcripts_tracking_3. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c11:",
        "prediction": "select t6.c3, t6.c4, t6.c5",
        "label": "select t6.c3, t6.c4, t6.c5",
        "score": true,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name",
        "real_label": "select Students.first_name, Students.middle_name, Students.last_name",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.student_id, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name., Students.middle_name, Students.last_name",
            "select t6, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name, Students.ssn",
            "select Students.first_name, t 6.c4, Students.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the first, middle, and last name of the first student to register?, database: Database: student_transcripts_tracking_3. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c11: date_left, ",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Students",
        "real_label": "Students",
        "topk_preds": [
            "Students",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the semester when both Master students and Bachelor students got enrolled in., database: Database: student_transcripts_tracking_3. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c11: date_left, c",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-BY-HAVING-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the semester when both Master students and Bachelor students got enrolled in., database: Database: student_transcripts_tracking_3. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c11: date_",
        "prediction": "select t5.c1",
        "label": "select distinct t7.c2",
        "score": false,
        "real_pred": "select Semesters.semester_name",
        "real_label": "select distinct Student_Enrolment.semester_id",
        "topk_preds": [
            "select Semesters.semester_name",
            "select Semesters.semester_name, Degree_Programs.is_bachelor, Degree_Programs.is_master",
            "select Semesters.semester_name, Semesters.semester_description",
            "select Semesters.semester_name, Degree_Programs.is_bachelor",
            "select Semesters.semester_name, Students.current_address_id3",
            "select Semesters.semester_name, Students.other_student_details",
            "select Semesters.semester_name, Degree_Programs.is_bachelor, Students.first_name",
            "select Semesters.semester_name, Students.date_left"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the semester when both Master students and Bachelor students got enrolled in., database: Database: student_transcripts_tracking_3. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c11: date_left, c12",
        "prediction": "t3 t6",
        "label": "t3 t7",
        "score": false,
        "real_pred": "Degree_Programs Students",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Students",
            "",
            "",
            "Departments Degree_Programs Students",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the id of the semester that had both Masters and Bachelors students enrolled?, database: Database: student_transcripts_tracking_3. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c11: date",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WITH-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the id of the semester that had both Masters and Bachelors students enrolled?, database: Database: student_transcripts_tracking_3. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, ",
        "prediction": "select t6.c1",
        "label": "select distinct t7.c2",
        "score": false,
        "real_pred": "select Students.current_address_id",
        "real_label": "select distinct Student_Enrolment.semester_id",
        "topk_preds": [
            "select Students.current_address_id",
            "select Semesters.semester_name",
            "select Students.student_id",
            "select Semesters.semester_id",
            "select Student_Enrolment_Courses.course_id",
            "select Sections.course_id",
            "select Sections.section_id",
            "select Student_Enrolment.degree_program_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the id of the semester that had both Masters and Bachelors students enrolled?, database: Database: student_transcripts_tracking_3. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: is_bachelor, c3: is_master, c4: is_phd, c5: degree_summary_description, c6: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: time_first_registered, c11: date_",
        "prediction": "t3 t6",
        "label": "t3 t7",
        "score": false,
        "real_pred": "Degree_Programs Students",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Students",
            "Degree_Programs Sections Students",
            "Departments Degree_Programs Sections Students",
            "Degree_Programs Semesters Students",
            "Departments Degree_Programs Students",
            "Courses Degree_Programs Students",
            "Degree_Programs Student_Enrolment_Courses",
            "Departments Degree_Programs Semesters Students"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the date and id of the transcript with at least 2 course results., database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t7: student_",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the date and id of the transcript with at least 2 course results., database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t",
        "prediction": "select t12.c5, t12.c0",
        "label": "select t9.c1, t9.c2, t9.c3, t9.c4, t10.c1",
        "score": false,
        "real_pred": "select t12.c5, t12.c0",
        "real_label": "select Transcripts.transcript_year, Transcripts.transcript_month, Transcripts.transcript_day, Transcripts.transcript_time, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t12.c5, t12.c0",
            "select t12.c3, t12.c0",
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t12.c0, t12.c3",
            "select t8.c5, Student_Enrolment_Courses.student_course_id",
            "select t12.c3, t12.c4",
            "select t12.c5, t12.c6",
            "select t11.c3, t11.c0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the date and id of the transcript with at least 2 course results., database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t7: student_en",
        "prediction": "t9",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Transcripts",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Transcripts",
            "Student_Enrolment_Courses",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the date and id of the transcript with at least 2 courses listed?, database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t7: student",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING In-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the date and id of the transcript with at least 2 courses listed?, database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). ",
        "prediction": "select t10.c5, t10.c0",
        "label": "select t9.c1, t9.c2, t9.c3, t9.c4, t10.c1",
        "score": false,
        "real_pred": "select t10.c5, Transcript_Contents.student_course_id",
        "real_label": "select Transcripts.transcript_year, Transcripts.transcript_month, Transcripts.transcript_day, Transcripts.transcript_time, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t12.c5, t12.c0",
            "select t12.c3, t12.c0",
            "select t12.c0, t12.c3",
            "select t14.c3, t14.c0",
            "select t11.c3, t11.c4",
            "select t11.c3, t11.c0",
            "select t10.c3, Transcript_Contents.student_course_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the date and id of the transcript with at least 2 courses listed?, database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t7: student_",
        "prediction": "t1 t8",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Courses Student_Enrolment_Courses",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Courses Student_Enrolment_Courses",
            "Courses Student_Enrolment",
            "Courses Transcripts",
            "Semesters Student_Enrolment_Courses",
            "",
            "Semesters Student_Enrolment",
            "Courses",
            "Courses Transcript_Contents"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who is the earliest graduate of the school? List the first name, middle name and last name., database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who is the earliest graduate of the school? List the first name, middle name and last name., database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_detail",
        "prediction": "select t6.c3, t6.c4, t6.c5",
        "label": "select t6.c3, t6.c4, t6.c5",
        "score": true,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name",
        "real_label": "select Students.first_name, Students.middle_name, Students.last_name",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.student_id, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name.c3, Students.middle_name, Students.last_name",
            "select Students.first_name., Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name.",
            "select t 6.c3, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who is the earliest graduate of the school? List the first name, middle name and last name., database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t7",
        "prediction": "t6 t7",
        "label": "t6",
        "score": false,
        "real_pred": "Students Student_Enrolment",
        "real_label": "Students",
        "topk_preds": [
            "Students Student_Enrolment",
            "Students",
            "",
            "",
            "",
            "",
            "Semesters Students Student_Enrolment",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the first, middle, and last name of the earliest school graduate?, database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t7: student_",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT(t6.c3), SELECT-FROM-ORDER BY-LIMIT(t6.c4), SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT(t6.c3), SELECT-FROM-GROUP BY-LIMIT(t6.c4), SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT(t6.c3), SELECT-FROM-ORDER BY-LIMIT(t6.c4), t6.c5",
            "SELECT-FROM-ORDER BY-LIMIT(t6.c3), t6.c4, t6.c5",
            "SELECT-FROM-ORDER BY-LIMIT(t6.c3), SELECT-FROM-ORDER BY-LIMIT(t6.c4)",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT(t6.c3), SELECT-FROM-ORDER BY-LIMIT(t6.c4) and SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the first, middle, and last name of the earliest school graduate?, database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t",
        "prediction": "select t6.c3, t6.c4, t6.c5",
        "label": "select t6.c3, t6.c4, t6.c5",
        "score": true,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name",
        "real_label": "select Students.first_name, Students.middle_name, Students.last_name",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.student_id, Students.first_name, Students.middle_name, Students.last_name",
            "select t6, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name., Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name, Students.ssn",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Semesters.other_details, t5.c4, Students.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the first, middle, and last name of the earliest school graduate?, database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t7: student_en",
        "prediction": "t6 t7",
        "label": "t6",
        "score": false,
        "real_pred": "Students Student_Enrolment",
        "real_label": "Students",
        "topk_preds": [
            "Students Student_Enrolment",
            "Students",
            "",
            "",
            "",
            "",
            "Semesters Students Student_Enrolment",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When is the first transcript released? List the date and details., database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t7: student_enrolment(",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When is the first transcript released? List the date and details., database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t7: student_",
        "prediction": "select t8.c5, t8.c6",
        "label": "select t9.c1, t9.c2, t9.c3, t9.c4, t9.c5",
        "score": false,
        "real_pred": "select t8.c5, t8.c6",
        "real_label": "select Transcripts.transcript_year, Transcripts.transcript_month, Transcripts.transcript_day, Transcripts.transcript_time, Transcripts.other_details",
        "topk_preds": [
            "select t8.c5, t8.c6",
            "select t12.c5, t12.c6",
            "select t8.c5, t9.c6",
            "select t8.c5, Student_Enrolment.degree_program_id2",
            "select t7.c5, Student_Enrolment.degree_program_id2",
            "select t7.c5, t7.c6",
            "select Transcripts.other_details, t9.c6",
            "select t10.c5, t10.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When is the first transcript released? List the date and details., database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t7: student_enrolment(c",
        "prediction": "t9",
        "label": "t9",
        "score": true,
        "real_pred": "Transcripts",
        "real_label": "Transcripts",
        "topk_preds": [
            "Transcripts",
            "Student_Enrolment_Courses",
            "Transcript_Contents",
            "Courses Student_Enrolment_Courses",
            "Semesters Student_Enrolment_Courses",
            "Courses",
            "Semesters Student_Enrolment",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the earliest date of a transcript release, and what details can you tell me?, database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t7",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the earliest date of a transcript release, and what details can you tell me?, database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details",
        "prediction": "select t8.c5, t8.c6",
        "label": "select t9.c1, t9.c2, t9.c3, t9.c4, t9.c5",
        "score": false,
        "real_pred": "select t8.c5, t8.c6",
        "real_label": "select Transcripts.transcript_year, Transcripts.transcript_month, Transcripts.transcript_day, Transcripts.transcript_time, Transcripts.other_details",
        "topk_preds": [
            "select t8.c5, t8.c6",
            "select t12.c5, t12.c6",
            "select t13.c5, t13.c6",
            "select t10.c5, t10.c6",
            "select t14.c5, t14.c6",
            "select Addresses.zip_postcode, Addresses.state_province_county",
            "select t1.c5, t1.c6",
            "select t2.c5, t2.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the earliest date of a transcript release, and what details can you tell me?, database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t7:",
        "prediction": "t9",
        "label": "t9",
        "score": true,
        "real_pred": "Transcripts",
        "real_label": "Transcripts",
        "topk_preds": [
            "Transcripts",
            "Student_Enrolment",
            "Student_Enrolment_Courses",
            "Transcript_Contents",
            "Semesters Student_Enrolment",
            "Sections Student_Enrolment",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the last transcript release date?, database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the last transcript release date?, database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t7: student_enrolment(c",
        "prediction": "select t8.c5",
        "label": "select t9.c1, t9.c2, t9.c3, t9.c4",
        "score": false,
        "real_pred": "select t8.c5",
        "real_label": "select Transcripts.transcript_year, Transcripts.transcript_month, Transcripts.transcript_day, Transcripts.transcript_time",
        "topk_preds": [
            "select t8.c5",
            "select t12.c5",
            "select Transcripts.other_details",
            "select t14.c5",
            "select t13.c5",
            "select max(t8.c3)",
            "select t10.c5",
            "select max(t8.c6)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the last transcript release date?, database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "t9",
        "label": "t9",
        "score": true,
        "real_pred": "Transcripts",
        "real_label": "Transcripts",
        "topk_preds": [
            "Transcripts",
            "Student_Enrolment_Courses",
            "Transcript_Contents",
            "",
            "",
            "",
            "",
            "Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When was the last transcript released?, database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM.ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When was the last transcript released?, database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t7: student_enrolment(c0",
        "prediction": "select t8.c5",
        "label": "select t9.c1, t9.c2, t9.c3, t9.c4",
        "score": false,
        "real_pred": "select t8.c5",
        "real_label": "select Transcripts.transcript_year, Transcripts.transcript_month, Transcripts.transcript_day, Transcripts.transcript_time",
        "topk_preds": [
            "select t8.c5",
            "select Transcripts.other_details",
            "select t10.c5",
            "select t12.c5",
            "select max(t10.c5)",
            "select max(t8.c6)",
            "select t11.c3",
            "select max(t9.c6)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When was the last transcript released?, database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "t9",
        "label": "t9",
        "score": true,
        "real_pred": "Transcripts",
        "real_label": "Transcripts",
        "topk_preds": [
            "Transcripts",
            "Student_Enrolment_Courses",
            "Transcript_Contents",
            "",
            "",
            "Student_Enrolment",
            "",
            "Sections"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the date of the transcript which shows the least number of results, also list the id., database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the date of the transcript which shows the least number of results, also list the id., database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_detail",
        "prediction": "select t12.c5, t12.c0",
        "label": "select t9.c1, t9.c2, t9.c3, t9.c4, t10.c1",
        "score": false,
        "real_pred": "select t12.c5, t12.c0",
        "real_label": "select Transcripts.transcript_year, Transcripts.transcript_month, Transcripts.transcript_day, Transcripts.transcript_time, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t12.c5, t12.c0",
            "select t12.c3, t12.c0",
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t12.c0, t12.c3",
            "select t12.c6, t12.c0",
            "select t12.c5, t12.c6",
            "select t12.c1, t12.c0",
            "select t12.c3, t12.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the date of the transcript which shows the least number of results, also list the id., database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t7",
        "prediction": "t9",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Transcripts",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Transcripts",
            "Student_Enrolment_Courses",
            "Transcript_Contents",
            "Semesters Student_Enrolment",
            "",
            "",
            "Semesters Student_Enrolment_Courses",
            "Transcripts Transcript_Contents"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the date and id of the transcript with the least number of results?, database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t7: student",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the date and id of the transcript with the least number of results?, database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). ",
        "prediction": "select t12.c5, t12.c0",
        "label": "select t9.c1, t9.c2, t9.c3, t9.c4, t10.c1",
        "score": false,
        "real_pred": "select t12.c5, t12.c0",
        "real_label": "select Transcripts.transcript_year, Transcripts.transcript_month, Transcripts.transcript_day, Transcripts.transcript_time, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t12.c5, t12.c0",
            "select t12.c3, t12.c0",
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t12.c0, t12.c3",
            "select t12.c3, t12.c4",
            "select t11.c3, t11.c0",
            "select t11.c3, t11.c4",
            "select t12.c5, t12.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the date and id of the transcript with the least number of results?, database: Database: student_transcripts_tracking_4. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: time_left, c12: other_student_details). t7: student_",
        "prediction": "t9",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Transcripts",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Transcripts",
            "Student_Enrolment_Courses",
            "Sections Students Student_Enrolment_Courses",
            "Sections Students Student_Enrolment",
            "Semesters Student_Enrolment",
            "",
            "Transcripts Transcript_Contents",
            "Sections Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all cartoon directed by \"Ben Jones\"., database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all cartoon directed by \"Ben Jones\"., database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Cartoon.Title",
        "real_label": "select Cartoon.Title",
        "topk_preds": [
            "select Cartoon.Title",
            "select Cartoon.Title, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname",
            "select Cartoon.Title de, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.id",
            "select Cartoon.Title, Cartoon.air_month",
            "select Cartoon.Title de, Cartoon.director_lastname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all cartoon directed by \"Ben Jones\"., database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of all cartoons directed by Ben Jones?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of all cartoons directed by Ben Jones?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Cartoon.Title",
        "real_label": "select Cartoon.Title",
        "topk_preds": [
            "select Cartoon.Title",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname",
            "select Cartoon.Title de, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname-, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname & Cartoon.director_lastname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of all cartoons directed by Ben Jones?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many cartoons were written by \"Joseph Kuhr\"?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname (Joseph), c5: writer_lastname (Kuhr), c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many cartoons were written by \"Joseph Kuhr\"?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname (Joseph), c5: writer_lastname (Kuhr), c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Cartoon.id",
            "select count(*), Cartoon.Title",
            "select count(*), Cartoon.writer_firstname",
            "select count(*), Cartoon.director_lastname",
            "select count(*), Cartoon.Production_code",
            "select count(*), Cartoon.air_year",
            "select count(*), Cartoon.air_month"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many cartoons were written by \"Joseph Kuhr\"?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname (Joseph), c5: writer_lastname (Kuhr), c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "TV_series Cartoon",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of cartoones written by Joseph Kuhr?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname (Joseph), c5: writer_lastname (Kuhr), c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE(count(*)",
            "SELECT-FROM-WHERE count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of cartoones written by Joseph Kuhr?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname (Joseph), c5: writer_lastname (Kuhr), c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Cartoon.id",
            "select count(*), Cartoon.Title",
            "select count(*), Cartoon.writer_firstname",
            "select count(*), Cartoon.air_year",
            "select count(*), Cartoon.director_lastname",
            "select count(*), Cartoon.Production_code",
            "select count(*), Cartoon.writer_lastname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of cartoones written by Joseph Kuhr?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname (Joseph), c5: writer_lastname (Kuhr), c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: list all cartoon titles and their directors ordered by their air date, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t2.c1, t2.c3",
            "SELECT-FROM-ORDER BY t2.c1, t2.c2",
            "SELECT-FROM-ORDER BY t2.c1, t2.c2, t2.c3",
            "SELECT-FROM-ORDER BY t2.C1, t2.c2, t2.c3",
            "SELECT-FROM-ORDER BY TI2.C1, t2.c2, t2.c3",
            "SELECT-FROM-ORDER BY t2.c1, t2.c2 and t2.c3",
            "SELECT-FROM-ORDER BY t2.c1, t2.c2, t2.c3"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: list all cartoon titles and their directors ordered by their air date, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "select t2.c1, t2.c2",
        "label": "select t2.c1, t2.c2, t2.c3",
        "score": false,
        "real_pred": "select Cartoon.Title, Cartoon.director_firstname",
        "real_label": "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
        "topk_preds": [
            "select Cartoon.Title, Cartoon.director_firstname",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname, Cartoon.air_day",
            "select Cartoon.Title, Cartoon.director_firstname de, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname and Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname ou Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname (Cartoon.director_lastname)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: list all cartoon titles and their directors ordered by their air date, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name and directors of all the cartoons that are ordered by air date?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t2.c1), SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t2.c1, t2.c2, t2.c3",
            "SELECT-FROM-ORDER BY t2.c1, t2.c3",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-ORDER BY (t2.c1), SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY t2.c1, t2.c2"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name and directors of all the cartoons that are ordered by air date?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "select t2.c1, t2.c3",
        "label": "select t2.c1, t2.c2, t2.c3",
        "score": false,
        "real_pred": "select Cartoon.Title, Cartoon.director_lastname",
        "real_label": "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
        "topk_preds": [
            "select Cartoon.Title, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname, Cartoon.air_day",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname, Cartoon.id",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname, Cartoon.air_year",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.director_firstname",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname, Cartoon.air_month"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name and directors of all the cartoons that are ordered by air date?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the title of all cartoon directed by \"Ben Jones\" or \"Brandon Vietti\"., database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Brandon, Ben), c3: director_lastname (Vietti, Jones), c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-UNITED-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the title of all cartoon directed by \"Ben Jones\" or \"Brandon Vietti\"., database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Brandon, Ben), c3: director_lastname (Vietti, Jones), c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Cartoon.Title",
        "real_label": "select Cartoon.Title",
        "topk_preds": [
            "select Cartoon.Title",
            "select Cartoon.Title, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.writer_firstname",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.director_firstname",
            "select Cartoon.Title, Cartoon.director_firstname (Vietti, Vietti)",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the title of all cartoon directed by \"Ben Jones\" or \"Brandon Vietti\"., database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Brandon, Ben), c3: director_lastname (Vietti, Jones), c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the titles of all cartoons directed by Ben Jones or Brandon Vietti?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Brandon, Ben), c3: director_lastname (Vietti, Jones), c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the titles of all cartoons directed by Ben Jones or Brandon Vietti?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Brandon, Ben), c3: director_lastname (Vietti, Jones), c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Cartoon.Title",
        "real_label": "select Cartoon.Title",
        "topk_preds": [
            "select Cartoon.Title",
            "select Cartoon.Title, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.writer_firstname",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.director_firstname",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.id",
            "select Cartoon.Title, Cartoon.director_firstname-, Cartoon.director_lastname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the titles of all cartoons directed by Ben Jones or Brandon Vietti?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Brandon, Ben), c3: director_lastname (Vietti, Jones), c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the air date of TV series with Episode \"A Love of a Lifetime\"?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (ACT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the air date of TV series with Episode \"A Love of a Lifetime\"?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "select t1.c3",
        "label": "select t1.c2, t1.c3, t1.c4",
        "score": false,
        "real_pred": "select TV_series.air_day",
        "real_label": "select TV_series.air_month, TV_series.air_day, TV_series.air_year",
        "topk_preds": [
            "select TV_series.air_day",
            "select TV_series.id, TV_series.air_day",
            "select TV_series.id, TV_series.air_month, TV_series.air_day",
            "select TV_series.air_day, TV_series.air_month",
            "select TV_series.air_day, TV_series.air_year",
            "select TV_series.air_day, TV_series.air_month, TV_series.air_year",
            "select TV_series.air_month, TV_series.air_day",
            "select TV_series.id, TV_series.air_day, TV_series.air_year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the air date of TV series with Episode \"A Love of a Lifetime\"?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When did the episode \"A Love of a Lifetime\" air?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When did the episode \"A Love of a Lifetime\" air?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "select t1.c3",
        "label": "select t1.c2, t1.c3, t1.c4",
        "score": false,
        "real_pred": "select TV_series.air_day",
        "real_label": "select TV_series.air_month, TV_series.air_day, TV_series.air_year",
        "topk_preds": [
            "select TV_series.air_day",
            "select TV_series.air_day, TV_series.air_month",
            "select TV_series.air_day, TV_series.air_year",
            "select TV_series.id, TV_series.air_month",
            "select TV_series.air_day, TV_series.Share",
            "select Cartoon.director_lastname, TV_series.air_month",
            "select Cartoon.director_lastname, Cartoon.director_firstname",
            "select TV_series.air_day, TV_series.air_month"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When did the episode \"A Love of a Lifetime\" air?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the number of cartoons directed by each of the listed directors., database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GEOGRAPHY-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY.LIMIT",
            "SELECT-FROM-GROUPS-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the number of cartoons directed by each of the listed directors., database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "select t2.c2, t2.c3, count(*)",
        "label": "select count(*), t2.c2, t2.c3",
        "score": false,
        "real_pred": "select Cartoon.director_firstname, Cartoon.director_lastname, count(*)",
        "real_label": "select count(*), Cartoon.director_firstname, Cartoon.director_lastname",
        "topk_preds": [
            "select Cartoon.director_firstname, Cartoon.director_lastname, count(*)",
            "select Cartoon.director_firstname, Cartoon.director_lastname",
            "select count(*), Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.id, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_lastname, count(*)",
            "select Cartoon.director_firstname, Cartoon.director_lastname, count(*),",
            "select count(*), Cartoon.director_firstname",
            "select Cartoon.director_firstname, Cartoon.director_lastname, count(**)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the number of cartoons directed by each of the listed directors., database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many cartoons did each director create?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GEOGRAPHY-GROUP BY",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-GERMANY-GROUP BY",
            "SELECT-FROM-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many cartoons did each director create?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "select t2.c2, t2.c3",
        "label": "select count(*), t2.c2, t2.c3",
        "score": false,
        "real_pred": "select Cartoon.director_firstname, Cartoon.director_lastname",
        "real_label": "select count(*), Cartoon.director_firstname, Cartoon.director_lastname",
        "topk_preds": [
            "select Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.director_firstname, Cartoon.director_lastname, count(*)",
            "select Cartoon.id, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.director_lastname, count(*)",
            "select Cartoon.director_firstname, Cartoon.director_lastname - count(*)",
            "select Cartoon.director_firstname, Cartoon.director_lastname, count(*),",
            "select Cartoon.Title, Cartoon.director_lastname",
            "select Cartoon.writer_lastname, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many cartoons did each director create?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the production code and channel of the most recently aired cartoon., database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the production code and channel of the most recently aired cartoon., database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "select t2.c9, t2.c10",
        "label": "select t2.c9, t2.c10",
        "score": true,
        "real_pred": "select Cartoon.Production_code, Cartoon.Channel",
        "real_label": "select Cartoon.Production_code, Cartoon.Channel",
        "topk_preds": [
            "select Cartoon.Production_code, Cartoon.Channel",
            "select max(Cartoon.Production_code), max(Cartoon.Channel)",
            "select Cartoon.Production_code, Cartoon.Channel, Cartoon.director_lastname",
            "select Cartoon.Production_code.c10, Cartoon.Production_code",
            "select Cartoon.Production_code, Cartoon.Channel, max(Cartoon.air_month)",
            "select Cartoon.Production_code, Cartoon.Channel.",
            "select Cartoon.Production_code, Cartoon.Channel, Cartoon.air_month",
            "select Cartoon.Production_code, Cartoon.Channel, Cartoon.Title3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the production code and channel of the most recently aired cartoon., database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the produdction code and channel of the most recent cartoon?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the produdction code and channel of the most recent cartoon?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "select t2.c9, t2.c10",
        "label": "select t2.c9, t2.c10",
        "score": true,
        "real_pred": "select Cartoon.Production_code, Cartoon.Channel",
        "real_label": "select Cartoon.Production_code, Cartoon.Channel",
        "topk_preds": [
            "select Cartoon.Production_code, Cartoon.Channel",
            "select max(Cartoon.Production_code), max(Cartoon.Channel)",
            "select Cartoon.air_year, Cartoon.Channel",
            "select Cartoon.Production_code, Cartoon.Channel.",
            "select Cartoon.Production_code, Cartoon.Channel",
            "select Cartoon.Production_code, Cartoon.Channel,",
            "select t2.c 9, Cartoon.Channel",
            "select Cartoon.Production_code0, Cartoon.Channel"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the produdction code and channel of the most recent cartoon?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "TV_series Cartoon",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: which countries' tv channels are playing some cartoon written by Todd Casey?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname (Todd), c5: writer_lastname (Casey), c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: which countries' tv channels are playing some cartoon written by Todd Casey?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname (Todd), c5: writer_lastname (Casey), c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select TV_Channel.Country",
        "real_label": "select TV_Channel.Country",
        "topk_preds": [
            "select TV_Channel.Country",
            "select distinct TV_Channel.Country",
            "select TV_Channel.Country, TV_Channel.Language",
            "select TV_Channel.Country, Cartoon.Channel",
            "select TV_Channel.series_name, TV_Channel.Country",
            "select TV_Channel.Country, TV_Channel.Content",
            "select TV_Channel.Country, TV_Channel.Pixel_aspect_ratio_PAR",
            "select distinct TV_Channel.Country, TV_Channel.Language"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: which countries' tv channels are playing some cartoon written by Todd Casey?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname (Todd), c5: writer_lastname (Casey), c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "",
            "",
            "",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the countries that have cartoons on TV that were written by Todd Casey?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname (Todd), c5: writer_lastname (Casey), c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the countries that have cartoons on TV that were written by Todd Casey?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname (Todd), c5: writer_lastname (Casey), c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select TV_Channel.Country",
        "real_label": "select TV_Channel.Country",
        "topk_preds": [
            "select TV_Channel.Country",
            "select distinct TV_Channel.Country",
            "select TV_Channel.Country, TV_Channel.Language",
            "select TV_Channel.Country, Cartoon.Channel",
            "select TV_Channel.Country, Cartoon.air_month",
            "select TV_Channel.Country, Cartoon.Title",
            "select TV_Channel.Country, Cartoon.Title3",
            "select count(distinct TV_Channel.Country)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the countries that have cartoons on TV that were written by Todd Casey?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname (Todd), c5: writer_lastname (Casey), c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: which countries' tv channels are not playing any cartoon written by Todd Casey?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname (Todd), c5: writer_lastname (Casey), c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-ESE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2013EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: which countries' tv channels are not playing any cartoon written by Todd Casey?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname (Todd), c5: writer_lastname (Casey), c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select TV_Channel.Country",
        "real_label": "select TV_Channel.Country",
        "topk_preds": [
            "select TV_Channel.Country",
            "select TV_Channel.Country, Cartoon.Channel",
            "select distinct TV_Channel.Country",
            "select TV_Channel.Country, TV_Channel.Language",
            "select TV_Channel.series_name, TV_Channel.Country",
            "select TV_Channel.Country, Cartoon.Title",
            "select TV_Channel.id, TV_Channel.Country",
            "select TV_Channel.Country, TV_Channel.Content"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: which countries' tv channels are not playing any cartoon written by Todd Casey?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname (Todd), c5: writer_lastname (Casey), c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "",
            "",
            "",
            "",
            "TV_Channel TV_series Cartoon",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the countries that are not playing cartoons written by Todd Casey?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname (Todd), c5: writer_lastname (Casey), c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-A-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2014EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the countries that are not playing cartoons written by Todd Casey?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname (Todd), c5: writer_lastname (Casey), c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select TV_Channel.Country",
        "real_label": "select TV_Channel.Country",
        "topk_preds": [
            "select TV_Channel.Country",
            "select TV_Channel.Country, Cartoon.Title",
            "select TV_Channel.Country, Cartoon.writer_firstname",
            "select TV_Channel.Country, TV_Channel.Language",
            "select TV_Channel.Country, Cartoon.Channel",
            "select TV_Channel.series_name, TV_Channel.Country",
            "select TV_Channel.Country, Cartoon.writer_lastname",
            "select TV_Channel.Country, Cartoon.Production_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the countries that are not playing cartoons written by Todd Casey?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: writer_firstname (Todd), c5: writer_lastname (Casey), c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the series name and country of the tv channel that is playing some cartoons directed by Ben Jones and Michael Chang?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Michael, Ben), c3: director_lastname (Chang, Jones), c4: writer_firstname (Michael), c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE,",
            "SELECTS-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT\u2013FROM-WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the series name and country of the tv channel that is playing some cartoons directed by Ben Jones and Michael Chang?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Michael, Ben), c3: director_lastname (Chang, Jones), c4: writer_firstname (Michael), c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select TV_Channel.series_name, TV_Channel.Country",
        "real_label": "select TV_Channel.series_name, TV_Channel.Country",
        "topk_preds": [
            "select TV_Channel.series_name, TV_Channel.Country",
            "select TV_Channel.series_name, TV_Channel.Country, Cartoon.Channel",
            "select Cartoon.Title, TV_Channel.Country",
            "select TV_Channel.series_name, TV_Channel.Country, TV_Channel.Language",
            "select t3.c1, TV_Channel.Country",
            "select to.c1, TV_Channel.Country",
            "select t 0.c1, TV_Channel.Country",
            "select TV_Channel.series_name, TV_Channel.Country, TV_series.Channel"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the series name and country of the tv channel that is playing some cartoons directed by Ben Jones and Michael Chang?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Michael, Ben), c3: director_lastname (Chang, Jones), c4: writer_firstname (Michael), c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the series name and country of all TV channels that are playing cartoons directed by Ben Jones and cartoons directed by Michael Chang?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Michael, Ben), c3: director_lastname (Chang, Jones), c4: writer_firstname (Michael), c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the series name and country of all TV channels that are playing cartoons directed by Ben Jones and cartoons directed by Michael Chang?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Michael, Ben), c3: director_lastname (Chang, Jones), c4: writer_firstname (Michael), c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select TV_Channel.series_name, TV_Channel.Country",
        "real_label": "select TV_Channel.series_name, TV_Channel.Country",
        "topk_preds": [
            "select TV_Channel.series_name, TV_Channel.Country",
            "select Cartoon.Title, TV_Channel.Country",
            "select t 0.c1, TV_Channel.Country",
            "select to.c1, TV_Channel.Country",
            "select TV_series.Episode, TV_Channel.Country",
            "select t3.c1, TV_Channel.Country",
            "select t0-c1, t0-c2",
            "select TV_Channel.series_name, t0-c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the series name and country of all TV channels that are playing cartoons directed by Ben Jones and cartoons directed by Michael Chang?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Michael, Ben), c3: director_lastname (Chang, Jones), c4: writer_firstname (Michael), c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            "",
            "",
            "TV_Channel Cartoon TV_series Cartoon",
            "TV_Channel Cartoon TV_series"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: find the id of tv channels that do not play any cartoon directed by Ben Jones., database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-HESITATION-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: find the id of tv channels that do not play any cartoon directed by Ben Jones., database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select TV_Channel.id",
        "real_label": "select TV_Channel.id",
        "topk_preds": [
            "select TV_Channel.id",
            "select TV_Channel.id, Cartoon.Channel",
            "select TV_Channel.id, TV_Channel.series_name",
            "select TV_Channel.series_name",
            "select TV_Channel.id, Cartoon.Title",
            "select TV_Channel.id, TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.id defeat Cartoon.Channel",
            "select TV_Channel.id, Cartoon.Production_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: find the id of tv channels that do not play any cartoon directed by Ben Jones., database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the ids of the TV channels that do not have any cartoons directed by Ben Jones?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM_EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2014EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the ids of the TV channels that do not have any cartoons directed by Ben Jones?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select TV_Channel.id",
        "real_label": "select TV_Channel.id",
        "topk_preds": [
            "select TV_Channel.id",
            "select TV_Channel.id, Cartoon.Channel",
            "select TV_Channel.id, Cartoon.director_firstname, Cartoon.director_lastname",
            "select TV_Channel.id, TV_Channel.series_name",
            "select TV_Channel.series_name",
            "select TV_Channel.series_name, TV_Channel.Country",
            "select TV_Channel.id, Cartoon.Title",
            "select TV_Channel.id, Cartoon.Production_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the ids of the TV channels that do not have any cartoons directed by Ben Jones?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: find the package option of the tv channel that do not have any cartoon directed by Ben Jones., database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE.",
            "SELECT-FROM_EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: find the package option of the tv channel that do not have any cartoon directed by Ben Jones., database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "select t0.c8",
        "label": "select t0.c8",
        "score": true,
        "real_pred": "select TV_Channel.Package_Option",
        "real_label": "select TV_Channel.Package_Option",
        "topk_preds": [
            "select TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Channel, TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, Cartoon.Channel",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.Package_Option, TV_Channel.Pay_per_view_PPV",
            "select TV_Channel.Package_Option, TV_Channel.series_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: find the package option of the tv channel that do not have any cartoon directed by Ben Jones., database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the package options of all tv channels that are not playing any cartoons directed by Ben Jones?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the package options of all tv channels that are not playing any cartoons directed by Ben Jones?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "select t0.c8",
        "label": "select t0.c8",
        "score": true,
        "real_pred": "select TV_Channel.Package_Option",
        "real_label": "select TV_Channel.Package_Option",
        "topk_preds": [
            "select TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Channel, TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, Cartoon.Channel",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, Cartoon.director_firstname",
            "select TV_Channel.Package_Option, t0.c9",
            "select TV_Channel.Package_Option (Option)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the package options of all tv channels that are not playing any cartoons directed by Ben Jones?, database: Database: tvshow_0. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: writer_firstname, c5: writer_lastname, c6: air_month, c7: air_day, c8: air_year, c9: production_code, c10: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "",
            "",
            "",
            "",
            "",
            "TV_Channel TV_series Cartoon",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: list all cartoon titles and their directors ordered by their air date, database: Database: tvshow_1. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: air_month, c5: air_day, c6: air_year, c7: production_code, c8: channel).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t2.c1, t2.c2",
            "SELECT-FROM-ORDER BY t2.C1, t2.c2",
            "SELECT-FROM-ORDER BY TI2.C1, t2.c2",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY TI2.c1, t2.c2",
            "SELECT-FROM-ORDER BY (t2.c1)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: list all cartoon titles and their directors ordered by their air date, database: Database: tvshow_1. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: air_month, c5: air_day, c6: air_year, c7: production_code, c8: channel).",
        "prediction": "select t2.c1, t2.c2",
        "label": "select t2.c1, t2.c2",
        "score": true,
        "real_pred": "select Cartoon.Title, Cartoon.Directed_by",
        "real_label": "select Cartoon.Title, Cartoon.Directed_by",
        "topk_preds": [
            "select Cartoon.Title, Cartoon.Directed_by",
            "select Cartoon.Title, Cartoon.Directed_by, Cartoon.air_day",
            "select Cartoon.Title, Cartoon.Directed_by, Cartoon.air_month",
            "select Cartoon.Title, Cartoon.Directed_by, Cartoon.air_year",
            "select Cartoon.Title, Cartoon.Directed_by, Cartoon.Written_by",
            "select Cartoon.Title, Cartoon.Directed_by (ordered by",
            "select Cartoon.Title, Cartoon.Directed_by (if applicable)",
            "select Cartoon.Title, Cartoon.Directed_by,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: list all cartoon titles and their directors ordered by their air date, database: Database: tvshow_1. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: air_month, c5: air_day, c6: air_year, c7: production_code, c8: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name and directors of all the cartoons that are ordered by air date?, database: Database: tvshow_1. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: air_month, c5: air_day, c6: air_year, c7: production_code, c8: channel).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t2.c1, t2.c2",
            "SELECT-FROM-ORDER BY (t2.c1), SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-ORDER BY (SMART-QUEST-SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name and directors of all the cartoons that are ordered by air date?, database: Database: tvshow_1. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: air_month, c5: air_day, c6: air_year, c7: production_code, c8: channel).",
        "prediction": "select t2.c1, t2.c2",
        "label": "select t2.c1, t2.c2",
        "score": true,
        "real_pred": "select Cartoon.Title, Cartoon.Directed_by",
        "real_label": "select Cartoon.Title, Cartoon.Directed_by",
        "topk_preds": [
            "select Cartoon.Title, Cartoon.Directed_by",
            "select Cartoon.Title, Cartoon.Directed_by, Cartoon.air_month",
            "select Cartoon.Title, Cartoon.Directed_by, Cartoon.air_year",
            "select Cartoon.Title, Cartoon.Directed_by, Cartoon.air_day",
            "select Cartoon.Title, Cartoon.Directed_by, Cartoon.Written_by",
            "select Cartoon.Title, Cartoon.Directed_by, Cartoon.Production_code",
            "select Cartoon.Title, Cartoon.Directed_by, Cartoon.id",
            "select Cartoon.Title, Cartoon.Directed_by, t2.c9"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name and directors of all the cartoons that are ordered by air date?, database: Database: tvshow_1. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: air_month, c5: air_day, c6: air_year, c7: production_code, c8: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the air date of TV series with Episode \"A Love of a Lifetime\"?, database: Database: tvshow_1. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: air_month, c5: air_day, c6: air_year, c7: production_code, c8: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the air date of TV series with Episode \"A Love of a Lifetime\"?, database: Database: tvshow_1. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: air_month, c5: air_day, c6: air_year, c7: production_code, c8: channel).",
        "prediction": "select t1.c3",
        "label": "select t1.c2, t1.c3, t1.c4",
        "score": false,
        "real_pred": "select TV_series.air_day",
        "real_label": "select TV_series.air_month, TV_series.air_day, TV_series.air_year",
        "topk_preds": [
            "select TV_series.air_day",
            "select TV_series.air_day)",
            "select TV_series.air_day.",
            "select TV_series.Episode",
            "select TV_series.air_day,",
            "select TV_series.air_day/",
            "select TV_series.air_month",
            "select Cartoon.Written_by"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the air date of TV series with Episode \"A Love of a Lifetime\"?, database: Database: tvshow_1. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: air_month, c5: air_day, c6: air_year, c7: production_code, c8: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When did the episode \"A Love of a Lifetime\" air?, database: Database: tvshow_1. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: air_month, c5: air_day, c6: air_year, c7: production_code, c8: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When did the episode \"A Love of a Lifetime\" air?, database: Database: tvshow_1. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: air_month, c5: air_day, c6: air_year, c7: production_code, c8: channel).",
        "prediction": "select t1.c3",
        "label": "select t1.c2, t1.c3, t1.c4",
        "score": false,
        "real_pred": "select TV_series.air_day",
        "real_label": "select TV_series.air_month, TV_series.air_day, TV_series.air_year",
        "topk_preds": [
            "select TV_series.air_day",
            "select TV_series.air_day, TV_series.air_month",
            "select TV_series.air_day, TV_series.air_year",
            "select Cartoon.Written_by, TV_series.air_month",
            "select TV_series.air_day, TV_series.air_month",
            "select TV_series.air_day (or TV_series.air_month)",
            "select TV_series.air_day, TV_series.Share",
            "select Cartoon.Written_by, Cartoon.Directed_by"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When did the episode \"A Love of a Lifetime\" air?, database: Database: tvshow_1. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: air_month, c5: air_day, c6: air_year, c7: production_code, c8: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the production code and channel of the most recently aired cartoon., database: Database: tvshow_1. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: air_month, c5: air_day, c6: air_year, c7: production_code, c8: channel).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the production code and channel of the most recently aired cartoon., database: Database: tvshow_1. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: air_month, c5: air_day, c6: air_year, c7: production_code, c8: channel).",
        "prediction": "select t2.c7, t2.c8",
        "label": "select t2.c7, t2.c8",
        "score": true,
        "real_pred": "select Cartoon.Production_code, Cartoon.Channel",
        "real_label": "select Cartoon.Production_code, Cartoon.Channel",
        "topk_preds": [
            "select Cartoon.Production_code, Cartoon.Channel",
            "select max(Cartoon.Production_code), max(Cartoon.Channel)",
            "select Cartoon.Production_code), Cartoon.Channel",
            "select Cartoon.air_day, Cartoon.Channel",
            "select Cartoon.id, Cartoon.Channel",
            "select t2.c 7, Cartoon.Channel",
            "select Cartoon.air_year, Cartoon.Channel",
            "select Cartoon.Channel, Cartoon.Production_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the production code and channel of the most recently aired cartoon., database: Database: tvshow_1. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: air_month, c5: air_day, c6: air_year, c7: production_code, c8: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the produdction code and channel of the most recent cartoon?, database: Database: tvshow_1. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: air_month, c5: air_day, c6: air_year, c7: production_code, c8: channel).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the produdction code and channel of the most recent cartoon?, database: Database: tvshow_1. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: air_month, c5: air_day, c6: air_year, c7: production_code, c8: channel).",
        "prediction": "select t2.c7, t2.c8",
        "label": "select t2.c7, t2.c8",
        "score": true,
        "real_pred": "select Cartoon.Production_code, Cartoon.Channel",
        "real_label": "select Cartoon.Production_code, Cartoon.Channel",
        "topk_preds": [
            "select Cartoon.Production_code, Cartoon.Channel",
            "select max(Cartoon.Production_code), max(Cartoon.Channel)",
            "select Cartoon.air_day, Cartoon.Channel",
            "select Cartoon.Production_code), Cartoon.Channel",
            "select Cartoon.air_year, Cartoon.Channel",
            "select Cartoon.id, Cartoon.Production_code",
            "select t2.c 7, Cartoon.Channel",
            "select Cartoon.Title, Cartoon.Production_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the produdction code and channel of the most recent cartoon?, database: Database: tvshow_1. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: air_month, c5: air_day, c6: air_year, c7: production_code, c8: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "TV_series Cartoon",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            "TV_Channel Cartoon",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all cartoon directed by \"Ben Jones\"., database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all cartoon directed by \"Ben Jones\"., database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Cartoon.Title",
        "real_label": "select Cartoon.Title",
        "topk_preds": [
            "select Cartoon.Title",
            "select Cartoon.Title, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname",
            "select Cartoon.id",
            "select Cartoon.Title de, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.id",
            "select Cartoon.Title de, Cartoon.director_lastname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all cartoon directed by \"Ben Jones\"., database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of all cartoons directed by Ben Jones?, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of all cartoons directed by Ben Jones?, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Cartoon.Title",
        "real_label": "select Cartoon.Title",
        "topk_preds": [
            "select Cartoon.Title",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname",
            "select Cartoon.Title de, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname-, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname & Cartoon.director_lastname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of all cartoons directed by Ben Jones?, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: list all cartoon titles and their directors ordered by their air date, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t2.c1, t2.c3",
            "SELECT-FROM-ORDER BY t2.c1, t2.c2, t2.c3",
            "SELECT-FROM-ORDER BY t2.c1, t2.c2",
            "SELECT-FROM-ORDER BY (t2.c1), SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t2.C1, t2.c2, t2.c3",
            "SELECT-FROM-ORDER BY t2.C1, t2.c3",
            "SELECT-FROM-ORDER BY TI2.C1, t2.c3"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: list all cartoon titles and their directors ordered by their air date, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "select t2.c1, t2.c3",
        "label": "select t2.c1, t2.c2, t2.c3",
        "score": false,
        "real_pred": "select Cartoon.Title, Cartoon.director_lastname",
        "real_label": "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
        "topk_preds": [
            "select Cartoon.Title, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname, Cartoon.Original_air_date",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.Original_air_date",
            "select Cartoon.Title, Cartoon.director_firstname-, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.Title, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname ou Cartoon.director_lastname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: list all cartoon titles and their directors ordered by their air date, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name and directors of all the cartoons that are ordered by air date?, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t2.c1), SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t2.c1), SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (t2.c1), SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ORDER BY t2.c1, t2.c2, t2.c3",
            "SELECT-FROM-ORDER BY (TI2.c1), SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t2.c1, t2.c3",
            "SELECT-FROM-ORDER BY (t2.c1), SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name and directors of all the cartoons that are ordered by air date?, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "select t2.c1, t2.c3",
        "label": "select t2.c1, t2.c2, t2.c3",
        "score": false,
        "real_pred": "select Cartoon.Title, Cartoon.director_lastname",
        "real_label": "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
        "topk_preds": [
            "select Cartoon.Title, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.director_firstname",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.Original_air_date",
            "select Cartoon.Title, Cartoon.director_firstname & Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.Written_by",
            "select Cartoon.Title, Cartoon.director_firstname& Cartoon.director_lastname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name and directors of all the cartoons that are ordered by air date?, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the title of all cartoon directed by \"Ben Jones\" or \"Brandon Vietti\"., database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Brandon, Ben), c3: director_lastname (Vietti, Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the title of all cartoon directed by \"Ben Jones\" or \"Brandon Vietti\"., database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Brandon, Ben), c3: director_lastname (Vietti, Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Cartoon.Title",
        "real_label": "select Cartoon.Title",
        "topk_preds": [
            "select Cartoon.Title",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.director_firstname",
            "select Cartoon.Title, Cartoon.director_firstname ou Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname (Vietti, Vietti)",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.Written_by"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the title of all cartoon directed by \"Ben Jones\" or \"Brandon Vietti\"., database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Brandon, Ben), c3: director_lastname (Vietti, Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the titles of all cartoons directed by Ben Jones or Brandon Vietti?, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Brandon, Ben), c3: director_lastname (Vietti, Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the titles of all cartoons directed by Ben Jones or Brandon Vietti?, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Brandon, Ben), c3: director_lastname (Vietti, Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Cartoon.Title",
        "real_label": "select Cartoon.Title",
        "topk_preds": [
            "select Cartoon.Title",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.director_firstname",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.Written_by",
            "select Cartoon.Title, Cartoon.director_firstname-, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname ou Cartoon.director_lastname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the titles of all cartoons directed by Ben Jones or Brandon Vietti?, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Brandon, Ben), c3: director_lastname (Vietti, Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the number of cartoons directed by each of the listed directors., database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GEOGRAPHY-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY.LIMIT",
            "SELECT-FROM-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY -ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the number of cartoons directed by each of the listed directors., database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "select t2.c2, t2.c3, count(*)",
        "label": "select count(*), t2.c2, t2.c3",
        "score": false,
        "real_pred": "select Cartoon.director_firstname, Cartoon.director_lastname, count(*)",
        "real_label": "select count(*), Cartoon.director_firstname, Cartoon.director_lastname",
        "topk_preds": [
            "select Cartoon.director_firstname, Cartoon.director_lastname, count(*)",
            "select Cartoon.director_firstname, Cartoon.director_lastname",
            "select count(*), Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_lastname, count(*)",
            "select Cartoon.director_firstname.c2, Cartoon.director_lastname, count(*)",
            "select Cartoon.id, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.director_lastname, count(*)",
            "select Cartoon.director_firstname, Cartoon.director_lastname, count(*),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the number of cartoons directed by each of the listed directors., database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many cartoons did each director create?, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GEOGRAPHY-GROUP BY",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY ORDINARY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many cartoons did each director create?, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "select t2.c2, t2.c3, count(*)",
        "label": "select count(*), t2.c2, t2.c3",
        "score": false,
        "real_pred": "select Cartoon.director_firstname, Cartoon.director_lastname, count(*)",
        "real_label": "select count(*), Cartoon.director_firstname, Cartoon.director_lastname",
        "topk_preds": [
            "select Cartoon.director_firstname, Cartoon.director_lastname, count(*)",
            "select Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.director_lastname, count(*)",
            "select Cartoon.director_firstname.c2, Cartoon.director_lastname, count(*)",
            "select Cartoon.id, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_lastname, count(*)",
            "select Cartoon.director_firstname, Cartoon.director_lastname, count(*),",
            "select Cartoon.director_firstname, Cartoon.director_lastname, count(**)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many cartoons did each director create?, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the series name and country of the tv channel that is playing some cartoons directed by Ben Jones and Michael Chang?, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Michael, Ben), c3: director_lastname (Chang, Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECTS-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT\u2013FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE,"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the series name and country of the tv channel that is playing some cartoons directed by Ben Jones and Michael Chang?, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Michael, Ben), c3: director_lastname (Chang, Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select TV_Channel.series_name, TV_Channel.Country",
        "real_label": "select TV_Channel.series_name, TV_Channel.Country",
        "topk_preds": [
            "select TV_Channel.series_name, TV_Channel.Country",
            "select TV_Channel.series_name, TV_Channel.Country, Cartoon.Channel",
            "select TV_Channel.series_name, TV_Channel.Country, TV_series.Weekly_Rank",
            "select TV_Channel.series_name, TV_Channel.Country, TV_Channel.Language",
            "select TV_Channel.series_name, TV_Channel.Country, TV_series.Channel",
            "select Cartoon.Title, TV_Channel.Country",
            "select to.c1, TV_Channel.Country",
            "select t 0.c1, TV_Channel.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the series name and country of the tv channel that is playing some cartoons directed by Ben Jones and Michael Chang?, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Michael, Ben), c3: director_lastname (Chang, Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            "",
            "",
            "",
            "TV_Channel Cartoon TV_series Cartoon"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the series name and country of all TV channels that are playing cartoons directed by Ben Jones and cartoons directed by Michael Chang?, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Michael, Ben), c3: director_lastname (Chang, Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2013WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the series name and country of all TV channels that are playing cartoons directed by Ben Jones and cartoons directed by Michael Chang?, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Michael, Ben), c3: director_lastname (Chang, Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select TV_Channel.series_name, TV_Channel.Country",
        "real_label": "select TV_Channel.series_name, TV_Channel.Country",
        "topk_preds": [
            "select TV_Channel.series_name, TV_Channel.Country",
            "select TV_Channel.series_name, TV_Channel.Country, TV_Channel.Language",
            "select TV_Channel.series_name, TV_Channel.Country, Cartoon.Channel",
            "select TV_Channel.series_name, TV_Channel.Country, TV_series.Weekly_Rank",
            "select TV_Channel.series_name, TV_Channel.Country, TV_series.Channel",
            "select TV_Channel.series_name, TV_Channel.Country, TV_Channel.id",
            "select t 0.c1, TV_Channel.Country",
            "select to.c1, TV_Channel.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the series name and country of all TV channels that are playing cartoons directed by Ben Jones and cartoons directed by Michael Chang?, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Michael, Ben), c3: director_lastname (Chang, Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            "TV_Channel Cartoon TV_series Cartoon",
            "",
            "",
            "TV_Channel Cartoon TV_series"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: find the id of tv channels that do not play any cartoon directed by Ben Jones., database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-HESITATION-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: find the id of tv channels that do not play any cartoon directed by Ben Jones., database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select TV_Channel.id",
        "real_label": "select TV_Channel.id",
        "topk_preds": [
            "select TV_Channel.id",
            "select TV_Channel.id, Cartoon.Channel",
            "select TV_Channel.id, TV_Channel.series_name",
            "select t0.c, Cartoon.Channel",
            "select TV_Channel.series_name",
            "select Cartoon.Channel",
            "select t0.c, TV_Channel.series_name",
            "select TV_Channel.id defeat Cartoon.Channel"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: find the id of tv channels that do not play any cartoon directed by Ben Jones., database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the ids of the TV channels that do not have any cartoons directed by Ben Jones?, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM_EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2014EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the ids of the TV channels that do not have any cartoons directed by Ben Jones?, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select TV_Channel.id",
        "real_label": "select TV_Channel.id",
        "topk_preds": [
            "select TV_Channel.id",
            "select TV_Channel.id, Cartoon.Channel",
            "select TV_Channel.id, TV_Channel.series_name",
            "select TV_Channel.series_name",
            "select TV_Channel.series_name, TV_Channel.Country",
            "select TV_Channel.id, t2.c8",
            "select t0.c, Cartoon.Channel",
            "select Cartoon.Channel"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the ids of the TV channels that do not have any cartoons directed by Ben Jones?, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: find the package option of the tv channel that do not have any cartoon directed by Ben Jones., database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2013EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: find the package option of the tv channel that do not have any cartoon directed by Ben Jones., database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "select t0.c8",
        "label": "select t0.c8",
        "score": true,
        "real_pred": "select TV_Channel.Package_Option",
        "real_label": "select TV_Channel.Package_Option",
        "topk_preds": [
            "select TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, Cartoon.director_firstname, Cartoon.director_lastname",
            "select TV_Channel.Package_Option, Cartoon.Channel",
            "select TV_Channel.Package_Option, TV_Channel.Country, TV_Channel.Language",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, TV_Channel.series_name, TV_Channel.Country",
            "select TV_Channel.Package_Option, TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Hight_definition_TV",
            "select TV_Channel.Package_Option, t2.c8"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: find the package option of the tv channel that do not have any cartoon directed by Ben Jones., database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the package options of all tv channels that are not playing any cartoons directed by Ben Jones?, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the package options of all tv channels that are not playing any cartoons directed by Ben Jones?, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "select t0.c8",
        "label": "select t0.c8",
        "score": true,
        "real_pred": "select TV_Channel.Package_Option",
        "real_label": "select TV_Channel.Package_Option",
        "topk_preds": [
            "select TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, Cartoon.director_firstname, Cartoon.director_lastname",
            "select TV_Channel.Package_Option, Cartoon.Channel",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Package_Option",
            "select TV_Channel.Hight_definition_TV, TV_Channel.Package_Option",
            "select TV_Channel.Package_Option (Option)",
            "select TV_Channel.Package_Option, TV_Channel.Pay_per_view_PPV",
            "select TV_Channel.Package_Option, t0.c9"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the package options of all tv channels that are not playing any cartoons directed by Ben Jones?, database: Database: tvshow_2. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "",
            "",
            "",
            "",
            "",
            "TV_Channel TV_series Cartoon",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many cartoons were written by \"Joseph Kuhr\"?, database: Database: tvshow_4. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: writer_firstname (Joseph), c4: writer_lastname (Kuhr), c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many cartoons were written by \"Joseph Kuhr\"?, database: Database: tvshow_4. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: writer_firstname (Joseph), c4: writer_lastname (Kuhr), c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Cartoon.writer_firstname, Cartoon.writer_lastname",
            "select count(*), Cartoon.id",
            "select count(*), Cartoon.Title, Cartoon.Directed_by",
            "select count(*), Cartoon.Title, Cartoon.writer_firstname",
            "select count(*), Cartoon.Title, Cartoon.writer_lastname",
            "select count(*), Cartoon.Title",
            "select count(*), Cartoon.id, Cartoon.writer_firstname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many cartoons were written by \"Joseph Kuhr\"?, database: Database: tvshow_4. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: writer_firstname (Joseph), c4: writer_lastname (Kuhr), c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of cartoones written by Joseph Kuhr?, database: Database: tvshow_4. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: writer_firstname (Joseph), c4: writer_lastname (Kuhr), c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE count(*)",
            "SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of cartoones written by Joseph Kuhr?, database: Database: tvshow_4. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: writer_firstname (Joseph), c4: writer_lastname (Kuhr), c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Cartoon.writer_firstname, Cartoon.writer_lastname",
            "select count(*), Cartoon.id",
            "select count(*), Cartoon.id, Cartoon.writer_firstname",
            "select count(*), Cartoon.Title, Cartoon.writer_lastname",
            "select count(*), Cartoon.Title",
            "select count(*), Cartoon.Title, Cartoon.Directed_by",
            "select count(*), Cartoon.Title, Cartoon.writer_firstname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of cartoones written by Joseph Kuhr?, database: Database: tvshow_4. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: writer_firstname (Joseph), c4: writer_lastname (Kuhr), c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the air date of TV series with Episode \"A Love of a Lifetime\"?, database: Database: tvshow_4. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: writer_firstname, c4: writer_lastname, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (ACTUAL-GROUP BY-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE (ACTUAL-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the air date of TV series with Episode \"A Love of a Lifetime\"?, database: Database: tvshow_4. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: writer_firstname, c4: writer_lastname, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "select t1.c3",
        "label": "select t1.c2, t1.c3, t1.c4",
        "score": false,
        "real_pred": "select TV_series.air_day",
        "real_label": "select TV_series.air_month, TV_series.air_day, TV_series.air_year",
        "topk_preds": [
            "select TV_series.air_day",
            "select TV_series.air_day, TV_series.air_month",
            "select TV_series.air_day, TV_series.air_year",
            "select TV_series.air_day, TV_series.Share",
            "select TV_series.air_day)",
            "select TV_series.air_day, TV_series.Rating",
            "select TV_series.air_day (or TV_series.air_month)",
            "select TV_series.air_day (or TV_series.air_year)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the air date of TV series with Episode \"A Love of a Lifetime\"?, database: Database: tvshow_4. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: writer_firstname, c4: writer_lastname, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When did the episode \"A Love of a Lifetime\" air?, database: Database: tvshow_4. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: writer_firstname, c4: writer_lastname, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When did the episode \"A Love of a Lifetime\" air?, database: Database: tvshow_4. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: writer_firstname, c4: writer_lastname, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "select t1.c3",
        "label": "select t1.c2, t1.c3, t1.c4",
        "score": false,
        "real_pred": "select TV_series.air_day",
        "real_label": "select TV_series.air_month, TV_series.air_day, TV_series.air_year",
        "topk_preds": [
            "select TV_series.air_day",
            "select TV_series.air_day, TV_series.air_month",
            "select TV_series.air_day, TV_series.air_month",
            "select TV_series.air_day de, TV_series.air_month",
            "select TV_series.air_day, TV_series.air_year",
            "select TV_series.air_day (or TV_series.air_month)",
            "select Cartoon.writer_firstname",
            "select TV_series.air_day)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When did the episode \"A Love of a Lifetime\" air?, database: Database: tvshow_4. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: writer_firstname, c4: writer_lastname, c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: which countries' tv channels are playing some cartoon written by Todd Casey?, database: Database: tvshow_4. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: writer_firstname (Todd), c4: writer_lastname (Casey), c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: which countries' tv channels are playing some cartoon written by Todd Casey?, database: Database: tvshow_4. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: writer_firstname (Todd), c4: writer_lastname (Casey), c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select TV_Channel.Country",
        "real_label": "select TV_Channel.Country",
        "topk_preds": [
            "select TV_Channel.Country",
            "select distinct TV_Channel.Country",
            "select TV_Channel.Country, TV_Channel.Language",
            "select TV_Channel.Country, Cartoon.Channel",
            "select TV_Channel.series_name, TV_Channel.Country",
            "select TV_Channel.Country, TV_Channel.Content",
            "select distinct TV_Channel.Country, TV_Channel.Language",
            "select TV_Channel.Country, TV_Channel.Pixel_aspect_ratio_PAR"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: which countries' tv channels are playing some cartoon written by Todd Casey?, database: Database: tvshow_4. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: writer_firstname (Todd), c4: writer_lastname (Casey), c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            "TV_Channel TV_series Cartoon"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the countries that have cartoons on TV that were written by Todd Casey?, database: Database: tvshow_4. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: writer_firstname (Todd), c4: writer_lastname (Casey), c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the countries that have cartoons on TV that were written by Todd Casey?, database: Database: tvshow_4. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: writer_firstname (Todd), c4: writer_lastname (Casey), c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select TV_Channel.Country",
        "real_label": "select TV_Channel.Country",
        "topk_preds": [
            "select TV_Channel.Country",
            "select distinct TV_Channel.Country",
            "select TV_Channel.Country, Cartoon.Channel",
            "select TV_Channel.Country, TV_Channel.Language",
            "select count(distinct TV_Channel.Country)",
            "select distinct TV_Channel.Country, TV_Channel.Language",
            "select TV_Channel.Country, Cartoon.Original_air_date",
            "select count(TV_Channel.Country)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the countries that have cartoons on TV that were written by Todd Casey?, database: Database: tvshow_4. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: writer_firstname (Todd), c4: writer_lastname (Casey), c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: which countries' tv channels are not playing any cartoon written by Todd Casey?, database: Database: tvshow_4. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: writer_firstname (Todd), c4: writer_lastname (Casey), c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-ESE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2013EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: which countries' tv channels are not playing any cartoon written by Todd Casey?, database: Database: tvshow_4. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: writer_firstname (Todd), c4: writer_lastname (Casey), c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select TV_Channel.Country",
        "real_label": "select TV_Channel.Country",
        "topk_preds": [
            "select TV_Channel.Country",
            "select TV_Channel.Country, Cartoon.Channel",
            "select distinct TV_Channel.Country",
            "select TV_Channel.Country, TV_Channel.Language",
            "select TV_Channel.series_name, TV_Channel.Country",
            "select TV_Channel.Country, TV_Channel.Content",
            "select TV_Channel.Country, TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.id, TV_Channel.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: which countries' tv channels are not playing any cartoon written by Todd Casey?, database: Database: tvshow_4. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: writer_firstname (Todd), c4: writer_lastname (Casey), c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "",
            "",
            "",
            "",
            "",
            "TV_Channel TV_series Cartoon",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the countries that are not playing cartoons written by Todd Casey?, database: Database: tvshow_4. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: writer_firstname (Todd), c4: writer_lastname (Casey), c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2014EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the countries that are not playing cartoons written by Todd Casey?, database: Database: tvshow_4. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: writer_firstname (Todd), c4: writer_lastname (Casey), c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select TV_Channel.Country",
        "real_label": "select TV_Channel.Country",
        "topk_preds": [
            "select TV_Channel.Country",
            "select TV_Channel.Country, Cartoon.writer_firstname, Cartoon.writer_lastname",
            "select TV_Channel.Country, Cartoon.writer_firstname",
            "select TV_Channel.Country, Cartoon.Channel",
            "select TV_Channel.Country, TV_Channel.Language",
            "select TV_Channel.Country, Cartoon.Title",
            "select TV_Channel.series_name, TV_Channel.Country",
            "select TV_Channel.Country, TV_Channel.Language, TV_Channel.Content"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the countries that are not playing cartoons written by Todd Casey?, database: Database: tvshow_4. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: writer_firstname (Todd), c4: writer_lastname (Casey), c5: original_air_date, c6: production_code, c7: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all cartoon directed by \"Ben Jones\"., database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all cartoon directed by \"Ben Jones\"., database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Cartoon.Title",
        "real_label": "select Cartoon.Title",
        "topk_preds": [
            "select Cartoon.Title",
            "select Cartoon.Title, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname",
            "select Cartoon.Title de, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.id",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.id",
            "select Cartoon.Title de, Cartoon.director_lastname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all cartoon directed by \"Ben Jones\"., database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of all cartoons directed by Ben Jones?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of all cartoons directed by Ben Jones?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Cartoon.Title",
        "real_label": "select Cartoon.Title",
        "topk_preds": [
            "select Cartoon.Title",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname",
            "select Cartoon.Title de, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname, Cartoon.id",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname - Cartoon.id",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of all cartoons directed by Ben Jones?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: list all cartoon titles and their directors ordered by their air date, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t2.c1, t2.c3",
            "SELECT-FROM-ORDER BY t2.c1, t2.c2",
            "SELECT-FROM-ORDER BY t2.c1, t2.c2, t2.c3",
            "SELECT-FROM-ORDER BY t2.C1, t2.c3",
            "SELECT-FROM-ORDER BY t2.C1, t2.c2, t2.c3",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY TI2.C1, t2.c3"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: list all cartoon titles and their directors ordered by their air date, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "select t2.c1, t2.c3",
        "label": "select t2.c1, t2.c2, t2.c3",
        "score": false,
        "real_pred": "select Cartoon.Title, Cartoon.director_lastname",
        "real_label": "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
        "topk_preds": [
            "select Cartoon.Title, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.air_month",
            "select Cartoon.Title, Cartoon.director_firstname-, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname ou Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname and Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname (Cartoon.director_lastname)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: list all cartoon titles and their directors ordered by their air date, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name and directors of all the cartoons that are ordered by air date?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t2.c1), SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t2.c1, t2.c3",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t2.c1, t2.c2, t2.c3",
            "SELECT-FROM-ORDER BY (t2.c1), SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name and directors of all the cartoons that are ordered by air date?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "select t2.c1, t2.c3",
        "label": "select t2.c1, t2.c2, t2.c3",
        "score": false,
        "real_pred": "select Cartoon.Title, Cartoon.director_lastname",
        "real_label": "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
        "topk_preds": [
            "select Cartoon.Title, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.director_firstname",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.air_month",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.Written_by",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.air_day",
            "select Cartoon.Title, Cartoon.director_firstname & Cartoon.director_lastname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name and directors of all the cartoons that are ordered by air date?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the title of all cartoon directed by \"Ben Jones\" or \"Brandon Vietti\"., database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Brandon, Ben), c3: director_lastname (Vietti, Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-UNITED-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the title of all cartoon directed by \"Ben Jones\" or \"Brandon Vietti\"., database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Brandon, Ben), c3: director_lastname (Vietti, Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Cartoon.Title",
        "real_label": "select Cartoon.Title",
        "topk_preds": [
            "select Cartoon.Title",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.Written_by",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.director_firstname",
            "select Cartoon.Title, Cartoon.director_firstname ou Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname (Vietti, Vietti)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the title of all cartoon directed by \"Ben Jones\" or \"Brandon Vietti\"., database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Brandon, Ben), c3: director_lastname (Vietti, Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the titles of all cartoons directed by Ben Jones or Brandon Vietti?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Brandon, Ben), c3: director_lastname (Vietti, Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNITED-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the titles of all cartoons directed by Ben Jones or Brandon Vietti?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Brandon, Ben), c3: director_lastname (Vietti, Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Cartoon.Title",
        "real_label": "select Cartoon.Title",
        "topk_preds": [
            "select Cartoon.Title",
            "select Cartoon.Title, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_firstname",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.Written_by",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.director_firstname",
            "select Cartoon.Title, Cartoon.director_lastname, Cartoon.id",
            "select Cartoon.Title, Cartoon.director_firstname-, Cartoon.director_lastname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the titles of all cartoons directed by Ben Jones or Brandon Vietti?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Brandon, Ben), c3: director_lastname (Vietti, Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the air date of TV series with Episode \"A Love of a Lifetime\"?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (ACT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the air date of TV series with Episode \"A Love of a Lifetime\"?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "select t1.c3",
        "label": "select t1.c2, t1.c3, t1.c4",
        "score": false,
        "real_pred": "select TV_series.air_day",
        "real_label": "select TV_series.air_month, TV_series.air_day, TV_series.air_year",
        "topk_preds": [
            "select TV_series.air_day",
            "select TV_series.id, TV_series.air_day",
            "select TV_series.id, TV_series.air_month, TV_series.air_day",
            "select TV_series.air_day, TV_series.air_month",
            "select TV_series.air_month, TV_series.air_day",
            "select TV_series.air_day, TV_series.air_month, TV_series.air_year",
            "select TV_series.air_day, TV_series.air_year",
            "select TV_series.id, TV_series.air_day, TV_series.air_year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the air date of TV series with Episode \"A Love of a Lifetime\"?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When did the episode \"A Love of a Lifetime\" air?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When did the episode \"A Love of a Lifetime\" air?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "select t1.c3",
        "label": "select t1.c2, t1.c3, t1.c4",
        "score": false,
        "real_pred": "select TV_series.air_day",
        "real_label": "select TV_series.air_month, TV_series.air_day, TV_series.air_year",
        "topk_preds": [
            "select TV_series.air_day",
            "select TV_series.air_day, TV_series.air_month",
            "select TV_series.air_day, TV_series.air_year",
            "select Cartoon.director_lastname, TV_series.air_month",
            "select TV_series.air_day, TV_series.air_month",
            "select TV_series.air_day, TV_series.Share",
            "select TV_series.air_day (or TV_series.air_month)",
            "select Cartoon.director_lastname, Cartoon.director_firstname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When did the episode \"A Love of a Lifetime\" air?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the number of cartoons directed by each of the listed directors., database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GEOGRAPHY-GROUP BY",
            "SELECT-FROM-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY.LIMIT",
            "SELECT-FROM-GROUP BY (ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the number of cartoons directed by each of the listed directors., database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "select t2.c2, t2.c3, count(*)",
        "label": "select count(*), t2.c2, t2.c3",
        "score": false,
        "real_pred": "select Cartoon.director_firstname, Cartoon.director_lastname, count(*)",
        "real_label": "select count(*), Cartoon.director_firstname, Cartoon.director_lastname",
        "topk_preds": [
            "select Cartoon.director_firstname, Cartoon.director_lastname, count(*)",
            "select Cartoon.director_firstname, Cartoon.director_lastname",
            "select count(*), Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.Title, Cartoon.director_lastname, count(*)",
            "select Cartoon.id, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.director_firstname-, Cartoon.director_lastname, count(*)",
            "select Cartoon.director_lastname, count(*)",
            "select Cartoon.air_month, Cartoon.director_firstname, Cartoon.director_lastname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the number of cartoons directed by each of the listed directors., database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many cartoons did each director create?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GEOGRAPHY-GROUP BY",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY -LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many cartoons did each director create?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "select t2.c2, t2.c3, count(*)",
        "label": "select count(*), t2.c2, t2.c3",
        "score": false,
        "real_pred": "select Cartoon.director_firstname, Cartoon.director_lastname, count(*)",
        "real_label": "select count(*), Cartoon.director_firstname, Cartoon.director_lastname",
        "topk_preds": [
            "select Cartoon.director_firstname, Cartoon.director_lastname, count(*)",
            "select Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.id, Cartoon.director_firstname, Cartoon.director_lastname",
            "select Cartoon.director_lastname, count(*)",
            "select Cartoon.director_firstname.c2, Cartoon.director_lastname, count(*)",
            "select Cartoon.Title, Cartoon.director_lastname, count(*)",
            "select Cartoon.director_firstname, Cartoon.director_lastname, count(*),",
            "select Cartoon.Title, Cartoon.director_lastname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many cartoons did each director create?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the production code and channel of the most recently aired cartoon., database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the production code and channel of the most recently aired cartoon., database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "select t2.c8, t2.c9",
        "label": "select t2.c8, t2.c9",
        "score": true,
        "real_pred": "select Cartoon.Production_code, Cartoon.Channel",
        "real_label": "select Cartoon.Production_code, Cartoon.Channel",
        "topk_preds": [
            "select Cartoon.Production_code, Cartoon.Channel",
            "select Cartoon.air_month, Cartoon.Production_code, Cartoon.Channel",
            "select max(Cartoon.Production_code), max(Cartoon.Channel)",
            "select Cartoon.Production_code, Cartoon.Channel, max(Cartoon.air_month)",
            "select Cartoon.Production_code, Cartoon.Channel, Cartoon.director_lastname",
            "select Cartoon.Channel, Cartoon.Production_code",
            "select Cartoon.Production_code, Cartoon.Channel, Cartoon.Written_by",
            "select Cartoon.Production_code, Cartoon.Channel, Cartoon.air_month"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the production code and channel of the most recently aired cartoon., database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "TV_series Cartoon",
            "",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the produdction code and channel of the most recent cartoon?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-C8, SELECT-FROM-C9"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the produdction code and channel of the most recent cartoon?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "select t2.c8, t2.c9",
        "label": "select t2.c8, t2.c9",
        "score": true,
        "real_pred": "select Cartoon.Production_code, Cartoon.Channel",
        "real_label": "select Cartoon.Production_code, Cartoon.Channel",
        "topk_preds": [
            "select Cartoon.Production_code, Cartoon.Channel",
            "select max(Cartoon.Production_code), max(Cartoon.Channel)",
            "select Cartoon.Channel, Cartoon.Production_code",
            "select max(Cartoon.Production_code), Cartoon.Channel",
            "select Cartoon.Production_code, Cartoon.Channel",
            "select t2.c 8, Cartoon.Channel",
            "select Cartoon.Production_code, Cartoon.Channel.",
            "select Cartoon.air_year, Cartoon.Channel"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the produdction code and channel of the most recent cartoon?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname, c3: director_lastname, c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "TV_series Cartoon",
            "",
            "TV_Channel TV_series Cartoon",
            "TV_Channel Cartoon",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the series name and country of the tv channel that is playing some cartoons directed by Ben Jones and Michael Chang?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Michael, Ben), c3: director_lastname (Chang, Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE,",
            "SELECT\u2013FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECTS-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the series name and country of the tv channel that is playing some cartoons directed by Ben Jones and Michael Chang?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Michael, Ben), c3: director_lastname (Chang, Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select TV_Channel.series_name, TV_Channel.Country",
        "real_label": "select TV_Channel.series_name, TV_Channel.Country",
        "topk_preds": [
            "select TV_Channel.series_name, TV_Channel.Country",
            "select TV_Channel.series_name, TV_Channel.Country, Cartoon.Channel",
            "select TV_Channel.series_name, TV_Channel.Country, TV_Channel.Language",
            "select Cartoon.Title, TV_Channel.Country",
            "select TV_Channel.series_name, TV_Channel.Country, Cartoon.Title0",
            "select TV_Channel.series_name, TV_Channel.Country, TV_series.Channel",
            "select to.c1, TV_Channel.Country",
            "select t 0.c1, TV_Channel.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the series name and country of the tv channel that is playing some cartoons directed by Ben Jones and Michael Chang?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Michael, Ben), c3: director_lastname (Chang, Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            "",
            "",
            "TV_Channel TV_Channel Cartoon",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the series name and country of all TV channels that are playing cartoons directed by Ben Jones and cartoons directed by Michael Chang?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Michael, Ben), c3: director_lastname (Chang, Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2013WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the series name and country of all TV channels that are playing cartoons directed by Ben Jones and cartoons directed by Michael Chang?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Michael, Ben), c3: director_lastname (Chang, Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select TV_Channel.series_name, TV_Channel.Country",
        "real_label": "select TV_Channel.series_name, TV_Channel.Country",
        "topk_preds": [
            "select TV_Channel.series_name, TV_Channel.Country",
            "select TV_Channel.series_name, TV_Channel.Country, TV_Channel.Language",
            "select TV_Channel.series_name, TV_Channel.Country, Cartoon.Channel",
            "select TV_Channel.series_name, TV_Channel.Country, TV_Channel.id",
            "select TV_Channel.series_name, TV_Channel.Country, TV_series.Channel",
            "select TV_Channel.series_name, TV_Channel.Country, TV_Channel.Content",
            "select to.c1, TV_Channel.Country",
            "select t 0.c1, TV_Channel.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the series name and country of all TV channels that are playing cartoons directed by Ben Jones and cartoons directed by Michael Chang?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Michael, Ben), c3: director_lastname (Chang, Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            "",
            "",
            "TV_Channel Cartoon TV_series Cartoon",
            "TV_Channel Cartoon TV_series"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: find the id of tv channels that do not play any cartoon directed by Ben Jones., database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-HESITATION-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: find the id of tv channels that do not play any cartoon directed by Ben Jones., database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select TV_Channel.id",
        "real_label": "select TV_Channel.id",
        "topk_preds": [
            "select TV_Channel.id",
            "select TV_Channel.id, Cartoon.Channel",
            "select TV_Channel.id, TV_Channel.series_name",
            "select TV_Channel.series_name",
            "select Cartoon.Channel",
            "select TV_Channel.id, TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.id defeat Cartoon.Channel",
            "select TV_Channel.id, TV_Channel.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: find the id of tv channels that do not play any cartoon directed by Ben Jones., database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the ids of the TV channels that do not have any cartoons directed by Ben Jones?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM_EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2014EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the ids of the TV channels that do not have any cartoons directed by Ben Jones?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select TV_Channel.id",
        "real_label": "select TV_Channel.id",
        "topk_preds": [
            "select TV_Channel.id",
            "select TV_Channel.id, Cartoon.Channel",
            "select TV_Channel.id, TV_Channel.series_name",
            "select TV_Channel.series_name",
            "select Cartoon.Channel",
            "select TV_Channel.series_name, TV_Channel.Country",
            "select TV_Channel.id, Cartoon.Title0",
            "select TV_Channel.series_name, TV_Channel.id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the ids of the TV channels that do not have any cartoons directed by Ben Jones?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: find the package option of the tv channel that do not have any cartoon directed by Ben Jones., database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE.",
            "SELECT-FROM_EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: find the package option of the tv channel that do not have any cartoon directed by Ben Jones., database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "select t0.c8",
        "label": "select t0.c8",
        "score": true,
        "real_pred": "select TV_Channel.Package_Option",
        "real_label": "select TV_Channel.Package_Option",
        "topk_preds": [
            "select TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, Cartoon.director_firstname, Cartoon.director_lastname",
            "select TV_Channel.Package_Option, Cartoon.Channel",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, Cartoon.Title0",
            "select TV_Channel.Package_Option, TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.Package_Option, TV_Channel.Pay_per_view_PPV",
            "select TV_Channel.Package_Option, t0.c9"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: find the package option of the tv channel that do not have any cartoon directed by Ben Jones., database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the package options of all tv channels that are not playing any cartoons directed by Ben Jones?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the package options of all tv channels that are not playing any cartoons directed by Ben Jones?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "select t0.c8",
        "label": "select t0.c8",
        "score": true,
        "real_pred": "select TV_Channel.Package_Option",
        "real_label": "select TV_Channel.Package_Option",
        "topk_preds": [
            "select TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, Cartoon.director_firstname, Cartoon.director_lastname",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, Cartoon.Channel",
            "select Cartoon.Channel, TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, t0.c9",
            "select TV_Channel.Package_Option, TV_Channel.Pay_per_view_PPV",
            "select TV_Channel.Package_Option, Cartoon.Title0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the package options of all tv channels that are not playing any cartoons directed by Ben Jones?, database: Database: tvshow_5. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_month, c3: air_day, c4: air_year, c5: rating, c6: share, c7: 18_49_rating_share, c8: viewers_m, c9: weekly_rank, c10: channel). t2: cartoon(c0: id, c1: title, c2: director_firstname (Ben), c3: director_lastname (Jones), c4: written_by, c5: air_month, c6: air_day, c7: air_year, c8: production_code, c9: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "",
            "",
            "",
            "",
            "",
            "TV_Channel TV_series Cartoon",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of poker players?, database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-INTERSECT-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of poker players?, database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "select t1.c2, t1.c3",
        "label": "select t1.c2, t1.c3",
        "score": true,
        "real_pred": "select people.first_name, people.last_name",
        "real_label": "select people.first_name, people.last_name",
        "topk_preds": [
            "select people.first_name, people.last_name",
            "select distinct people.first_name, people.last_name",
            "select people.People_ID, people.first_name, people.last_name",
            "select people.first_name, people.last_name, people.Birth_Date",
            "select poker_people.first_name, people.last_name",
            "select the people.first_name, people.last_name",
            "select people.Nationality, people.last_name",
            "select people.first_name, people.last_name, people.People_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of poker players?, database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the names of all the poker players., database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-INTERSECT-SELECT-FROM",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the names of all the poker players., database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "select t1.c2, t1.c3",
        "label": "select t1.c2, t1.c3",
        "score": true,
        "real_pred": "select people.first_name, people.last_name",
        "real_label": "select people.first_name, people.last_name",
        "topk_preds": [
            "select people.first_name, people.last_name",
            "select distinct people.first_name, people.last_name",
            "select people.People_ID, people.first_name, people.last_name",
            "select unique people.first_name, people.last_name",
            "select separate people.first_name, people.last_name",
            "select people.first_name, people.last_name, people.Birth_Date",
            "select the people.first_name, people.last_name",
            "select people.Nationality, people.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the names of all the poker players., database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of poker players whose earnings is higher than 300000?, database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of poker players whose earnings is higher than 300000?, database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "select t1.c2, t1.c3",
        "label": "select t1.c2, t1.c3",
        "score": true,
        "real_pred": "select people.first_name, people.last_name",
        "real_label": "select people.first_name, people.last_name",
        "topk_preds": [
            "select people.first_name, people.last_name",
            "select people.People_ID, people.first_name, people.last_name",
            "select people.Nationality, people.last_name",
            "select people.first_name, people.last_name, people.People_ID",
            "select people.first_name, people.last_name, people.Birth_Date",
            "select t1.c 2, people.last_name",
            "select people.last_name, people.first_name",
            "select people.first_name, people.last_name, people.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of poker players whose earnings is higher than 300000?, database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give the names of poker players who have earnings above 300000., database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C2, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give the names of poker players who have earnings above 300000., database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "select t1.c2, t1.c3",
        "label": "select t1.c2, t1.c3",
        "score": true,
        "real_pred": "select people.first_name, people.last_name",
        "real_label": "select people.first_name, people.last_name",
        "topk_preds": [
            "select people.first_name, people.last_name",
            "select people.People_ID, people.first_name, people.last_name",
            "select people.Nationality, people.last_name",
            "select people.first_name, people.last_name, people.People_ID",
            "select t1.c 2, people.last_name",
            "select distinct people.first_name, people.last_name",
            "select people.first_name, people.last_name, people.Birth_Date",
            "select people.first_name-, people.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give the names of poker players who have earnings above 300000., database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of poker players ordered by the final tables made in ascending order., database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c2, t1.c3",
            "SELECT-FROM-ORDER BY t0.c1, t1.c2, t1.c3",
            "SELECT-FROM-ORDER BY t0.c2, t1.c3",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1, SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1, t1.c3",
            "SELECT-FROM-ORDER BY t0.c1 - t1.c2, t1.c3"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of poker players ordered by the final tables made in ascending order., database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "select t1.c2, t1.c3",
        "label": "select t1.c2, t1.c3",
        "score": true,
        "real_pred": "select people.first_name, people.last_name",
        "real_label": "select people.first_name, people.last_name",
        "topk_preds": [
            "select people.first_name, people.last_name",
            "select people.People_ID, people.first_name, people.last_name",
            "select people.first_name, people.last_name, people.Birth_Date",
            "select people.first_name, people.last_name, poker_player.Final_Table_Made",
            "select people.first_name, people.last_name, people.People_ID",
            "select people.Nationality, people.last_name",
            "select distinct people.first_name, people.last_name",
            "select people.first_name, people.last_name, t1.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of poker players ordered by the final tables made in ascending order., database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of poker players, ordered ascending by the number of final tables they have made?, database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1, SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c2, t1.c3",
            "SELECT-FROM-ORDER BY t0.c1, t1.c2, t1.c3",
            "SELECT-FROM-ORDER BY t0.c1, t1.c3",
            "SELECT-FROM-ORDER BY t0.c2, t1.c3",
            "SELECT-FROM-ORDER BY (t1.c2), SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c2, SELECT-FROM-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of poker players, ordered ascending by the number of final tables they have made?, database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "select t1.c2, t1.c3",
        "label": "select t1.c2, t1.c3",
        "score": true,
        "real_pred": "select people.first_name, people.last_name",
        "real_label": "select people.first_name, people.last_name",
        "topk_preds": [
            "select people.first_name, people.last_name",
            "select people.People_ID, people.first_name, people.last_name",
            "select people.first_name, people.last_name, people.Birth_Date",
            "select people.Nationality, people.last_name",
            "select people.first_name, people.last_name, people.People_ID",
            "select distinct people.first_name, people.last_name",
            "select people.first_name, people.last_name, poker_player.Final_Table_Made",
            "select people.first_name, people.last_name, people.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of poker players, ordered ascending by the number of final tables they have made?, database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of poker players in descending order of earnings?, database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c2, t1.c3",
            "SELECT-FROM-ORDER BY t0.c1, t1.c2, t1.c3",
            "SELECT-FROM-ORDER BY (t0.c2), SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t1.c2), SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1, t1.c3",
            "SELECT-FROM-ORDER BY t0.c1, SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c2, t1.c3"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of poker players in descending order of earnings?, database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "select t1.c2, t1.c3",
        "label": "select t1.c2, t1.c3",
        "score": true,
        "real_pred": "select people.first_name, people.last_name",
        "real_label": "select people.first_name, people.last_name",
        "topk_preds": [
            "select people.first_name, people.last_name",
            "select people.People_ID, people.first_name, people.last_name",
            "select distinct people.first_name, people.last_name",
            "select people.first_name, people.last_name, people.Birth_Date",
            "select people.Nationality, people.last_name",
            "select people.first_name, people.last_name, poker_player.Earnings",
            "select people.first_name, people.last_name, people.People_ID",
            "select people.first_name, people.last_name, people.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of poker players in descending order of earnings?, database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the names of poker players sorted by their earnings descending., database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c2, t1.c3",
            "SELECT-FROM-ORDER BY t0.c1, t1.c3",
            "SELECT-FROM-ORDER BY t0.c1, t1.c2, t1.c3",
            "SELECT-FROM-ORDER BY t0.c1, SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c2, t1.c3",
            "SELECT-FROM-ORDER BY t0.c2, SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the names of poker players sorted by their earnings descending., database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "select t1.c2, t1.c3",
        "label": "select t1.c2, t1.c3",
        "score": true,
        "real_pred": "select people.first_name, people.last_name",
        "real_label": "select people.first_name, people.last_name",
        "topk_preds": [
            "select people.first_name, people.last_name",
            "select people.People_ID, people.first_name, people.last_name",
            "select distinct people.first_name, people.last_name",
            "select people.first_name, people.last_name, people.People_ID",
            "select people.first_name, people.last_name, people.Birth_Date",
            "select people.Nationality, people.last_name",
            "select people.first_name, people.last_name, poker_player.Earnings",
            "select people.first_name, people.last_name, people.Height"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the names of poker players sorted by their earnings descending., database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names and birth dates of people in ascending alphabetical order of name., database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c2, t1.c3, t1.c4",
            "SELECT-FROM-ORDER BY (t1.c2), t1.c3, t1.c4",
            "SELECT-FROM-ORDER BY (T1.c2), t1.c3, t1.c4",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t1.c2, t1.c3, t1.c4",
            "SELECT-FROM-ORDER BY (T1.c2), SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t1.c2), t1.c3"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names and birth dates of people in ascending alphabetical order of name., database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "select t1.c2, t1.c3, t1.c4",
        "label": "select t1.c2, t1.c3, t1.c4",
        "score": true,
        "real_pred": "select people.first_name, people.last_name, people.Birth_Date",
        "real_label": "select people.first_name, people.last_name, people.Birth_Date",
        "topk_preds": [
            "select people.first_name, people.last_name, people.Birth_Date",
            "select people.first_name-, people.last_name, people.Birth_Date",
            "select people.last_name, people.first_name, people.Birth_Date",
            "select t2.c2, people.last_name, people.Birth_Date",
            "select t1.c 2, people.last_name, people.Birth_Date",
            "select people.first_name/, people.last_name, people.Birth_Date",
            "select people.first_name, people.last_name, people.Birth_Date",
            "select people.first_name, people.last_name, t1.c 4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names and birth dates of people in ascending alphabetical order of name., database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names and birth dates of people, ordered by their names in alphabetical order?, database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c2, t1.c3, t1.c4",
            "SELECT-FROM-ORDER BY (T1.c2), SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t1.c2), t1.c3, t1.c4",
            "SELECT-FROM-ORDER BY t1.C2, t1.c3, t1.c4",
            "SELECT-FROM-ORDER BY (t1.c2), SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c2, t1.c3"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names and birth dates of people, ordered by their names in alphabetical order?, database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "select t1.c2, t1.c3, t1.c4",
        "label": "select t1.c2, t1.c3, t1.c4",
        "score": true,
        "real_pred": "select people.first_name, people.last_name, people.Birth_Date",
        "real_label": "select people.first_name, people.last_name, people.Birth_Date",
        "topk_preds": [
            "select people.first_name, people.last_name, people.Birth_Date",
            "select people.first_name, people.last_name, people.Birth_Date, people.People_ID",
            "select people.first_name-, people.last_name, people.Birth_Date",
            "select people.first_name, people.last_name, people.Birth_Date, t1.c8",
            "select people.first_name, people.last_name, people.Birth_Date, t1.c6",
            "select t2.c2, people.last_name, people.Birth_Date",
            "select people.last_name, people.first_name, people.Birth_Date",
            "select people.first_name, people.last_name, people.Birth_Date, people.Height"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names and birth dates of people, ordered by their names in alphabetical order?, database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show names of people whose nationality is not \"Russia\"., database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C2, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show names of people whose nationality is not \"Russia\"., database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "select t1.c2, t1.c3",
        "label": "select t1.c2, t1.c3",
        "score": true,
        "real_pred": "select people.first_name, people.last_name",
        "real_label": "select people.first_name, people.last_name",
        "topk_preds": [
            "select people.first_name, people.last_name",
            "select people.People_ID, people.first_name, people.last_name",
            "select people.first_name, people.last_name, people.Birth_Date",
            "select people.Nationality, people.last_name",
            "select people.first_name-, people.last_name",
            "select people.first_name, people.last_name, people.People_ID",
            "select people.last_name, people.first_name",
            "select people.first_name, people.last_name, people.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show names of people whose nationality is not \"Russia\"., database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of people who are not from Russia?, database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of people who are not from Russia?, database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "select t1.c2, t1.c3",
        "label": "select t1.c2, t1.c3",
        "score": true,
        "real_pred": "select people.first_name, people.last_name",
        "real_label": "select people.first_name, people.last_name",
        "topk_preds": [
            "select people.first_name, people.last_name",
            "select people.People_ID, people.first_name, people.last_name",
            "select people.first_name, people.last_name, people.Birth_Date",
            "select people.last_name, people.first_name",
            "select people.first_name-, people.last_name",
            "select people.first_name, people.last_name, people.first_name",
            "select people.Nationality, people.last_name",
            "select t1.c 2, people.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of people who are not from Russia?, database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of people that are not poker players., database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHICH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of people that are not poker players., database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "select t1.c2, t1.c3",
        "label": "select t1.c2, t1.c3",
        "score": true,
        "real_pred": "select people.first_name, people.last_name",
        "real_label": "select people.first_name, people.last_name",
        "topk_preds": [
            "select people.first_name, people.last_name",
            "select people.People_ID, people.first_name, people.last_name",
            "select distinct people.first_name, people.last_name",
            "select people.first_name, people.last_name, people.Birth_Date",
            "select people.Nationality, people.last_name",
            "select t1.c 2, people.last_name",
            "select people.last_name, people.first_name",
            "select people.first_name-, people.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of people that are not poker players., database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of people who do not play poker?, database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHICH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHAT-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of people who do not play poker?, database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "select t1.c2, t1.c3",
        "label": "select t1.c2, t1.c3",
        "score": true,
        "real_pred": "select people.first_name, people.last_name",
        "real_label": "select people.first_name, people.last_name",
        "topk_preds": [
            "select people.first_name, people.last_name",
            "select people.People_ID, people.first_name, people.last_name",
            "select people.first_name, people.last_name, people.Birth_Date",
            "select people.Nationality, people.last_name",
            "select distinct people.first_name, people.last_name",
            "select t1.c 2, people.last_name",
            "select people.first_name-, people.last_name",
            "select people.last_name, people.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of people who do not play poker?, database: Database: poker_player_0. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: first_name, c3: last_name, c4: birth_date, c5: height).",
        "prediction": "t0 t1",
        "label": "t1",
        "score": false,
        "real_pred": "poker_player people",
        "real_label": "people",
        "topk_preds": [
            "poker_player people",
            "people",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the contestant numbers and names, ordered by contestant name descending., database: Database: voter_1_0. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name, c2: last_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c0, t1.c1, t1.c2",
            "SELECT-FROM-ORDER BY contestant.c0, t1.c1, t1.c2",
            "SELECT-FROM-ORDER BY contestant t1.c0, t1.c1, t1.c2",
            "SELECT-FROM-ORDER BY contestant numbers, t1.c1, t1.c2",
            "SELECT-FROM-ORDER BY contestant numbers, SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY contestant.c0, SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the contestant numbers and names, ordered by contestant name descending., database: Database: voter_1_0. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name, c2: last_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "select t1.c0, t1.c1, t1.c2",
        "label": "select t1.c0, t1.c1, t1.c2",
        "score": true,
        "real_pred": "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
        "real_label": "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
        "topk_preds": [
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select VOTES.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name, t1.c3",
            "select CONTESTANTS.contestant_number-, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select t1.c3, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select VOTES.vote_id, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name, in-t1.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the contestant numbers and names, ordered by contestant name descending., database: Database: voter_1_0. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name, c2: last_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "CONTESTANTS",
        "real_label": "CONTESTANTS",
        "topk_preds": [
            "CONTESTANTS",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the contestants whose names are not 'Jessie Alloway', database: Database: voter_1_0. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name (Jessie), c2: last_name (Alloway)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the contestants whose names are not 'Jessie Alloway', database: Database: voter_1_0. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name (Jessie), c2: last_name (Alloway)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select CONTESTANTS.first_name, CONTESTANTS.last_name",
        "real_label": "select CONTESTANTS.first_name, CONTESTANTS.last_name",
        "topk_preds": [
            "select CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select CONTESTANTS.first_name.c1, CONTESTANTS.last_name",
            "select distinct CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select CONTESTANTS.first_name, CONTESTANTS.last_name, CONTESTANTS.contestant_number",
            "select t1.c 1, CONTESTANTS.last_name",
            "select other CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select CONTESTANTS.first_name, CONTESTANTS.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the contestants whose names are not 'Jessie Alloway', database: Database: voter_1_0. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name (Jessie), c2: last_name (Alloway)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "CONTESTANTS",
        "real_label": "CONTESTANTS",
        "topk_preds": [
            "CONTESTANTS",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the distinct states and create time of all votes?, database: Database: voter_1_0. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name, c2: last_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM (distinct t2.c2), SELECT-FROM",
            "SELECT-FROM distinct t2.c2, t2.c7",
            "SELECT-FROM (distinct t2.c2, t2.c7",
            "SELECT-FROM (distinct t2.c2), t2.c7",
            "SELECT-FROM (distinct t2.c2), distinct t2.c7",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM (distinct t2.c2, t2.c7)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the distinct states and create time of all votes?, database: Database: voter_1_0. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name, c2: last_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "select distinct t2.c2, t2.c7",
        "label": "select distinct t2.c2, t2.c4, t2.c5, t2.c6, t2.c7",
        "score": false,
        "real_pred": "select distinct VOTES.state, VOTES.created_time",
        "real_label": "select distinct VOTES.state, VOTES.created_year, VOTES.created_month, VOTES.created_day, VOTES.created_time",
        "topk_preds": [
            "select distinct VOTES.state, VOTES.created_time",
            "select distinct VOTES.state, distinct VOTES.created_time",
            "select distinct VOTES.state.c2, VOTES.created_time",
            "select distinct VOTES.state, VOTES.created_time, VOTES.vote_id",
            "select distinct VOTES.state, VOTES.vote_id7",
            "select distinct VOTES.state, VOTES.created_time)",
            "select distinct VOTES.state, VOTES.created_time, VOTES.created_time",
            "select distinct VOTES.state, VOTES.created_time, t2.c8"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the distinct states and create time of all votes?, database: Database: voter_1_0. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name, c2: last_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "VOTES",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the contestant numbers and names of the contestants who had at least two votes?, database: Database: voter_1_0. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name, c2: last_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the contestant numbers and names of the contestants who had at least two votes?, database: Database: voter_1_0. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name, c2: last_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "select t1.c0, t1.c1, t1.c2",
        "label": "select t1.c0, t1.c1, t1.c2",
        "score": true,
        "real_pred": "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
        "real_label": "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
        "topk_preds": [
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select VOTES.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select VOTES.state, CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select VOTES.vote_id, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select VOTES.phone_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select VOTES.contestant_number), CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name, CONTESTANTS.contestant_number",
            "select VOTES.phone_number, CONTESTANTS.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the contestant numbers and names of the contestants who had at least two votes?, database: Database: voter_1_0. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name, c2: last_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "CONTESTANTS VOTES",
        "real_label": "CONTESTANTS VOTES",
        "topk_preds": [
            "CONTESTANTS VOTES",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Of all the contestants who got voted, what is the contestant number and name of the contestant who got least votes?, database: Database: voter_1_0. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name, c2: last_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-C3 - SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Of all the contestants who got voted, what is the contestant number and name of the contestant who got least votes?, database: Database: voter_1_0. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name, c2: last_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "select t1.c0, t1.c1, t1.c2",
        "label": "select t1.c0, t1.c1, t1.c2",
        "score": true,
        "real_pred": "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
        "real_label": "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
        "topk_preds": [
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select VOTES.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select VOTES.state, CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select t1.c3, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name, CONTESTANTS.contestant_number",
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name, t1.c3",
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name-, CONTESTANTS.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Of all the contestants who got voted, what is the contestant number and name of the contestant who got least votes?, database: Database: voter_1_0. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name, c2: last_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "CONTESTANTS VOTES",
        "real_label": "CONTESTANTS VOTES",
        "topk_preds": [
            "CONTESTANTS VOTES",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the create dates, states, and phone numbers of the votes that were for the contestant named 'Tabatha Gehling'?, database: Database: voter_1_0. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name (Tabatha), c2: last_name (Gehling)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT.C4, SELECT.C2, SELECT-FROM-WHERE",
            "SELECT.C4, SELECT.C2, SELECT.C1",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT.C4, SELECT.C6, SELECT.C1",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the create dates, states, and phone numbers of the votes that were for the contestant named 'Tabatha Gehling'?, database: Database: voter_1_0. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name (Tabatha), c2: last_name (Gehling)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "select t2.c4, t2.c2, t2.c1",
        "label": "select t2.c4, t2.c5, t2.c6, t2.c7, t2.c2, t2.c1",
        "score": false,
        "real_pred": "select VOTES.created_year, VOTES.state, VOTES.phone_number",
        "real_label": "select VOTES.created_year, VOTES.created_month, VOTES.created_day, VOTES.created_time, VOTES.state, VOTES.phone_number",
        "topk_preds": [
            "select VOTES.created_year, VOTES.state, VOTES.phone_number",
            "select VOTES.created_day, VOTES.state, VOTES.phone_number",
            "select VOTES.created_time, VOTES.state, VOTES.phone_number",
            "select VOTES.created_year, VOTES.created_month, VOTES.phone_number",
            "select VOTES.created_year, VOTES.created_day, VOTES.phone_number",
            "select VOTES.created_month, VOTES.state, VOTES.phone_number",
            "select VOTES.vote_id, VOTES.state, VOTES.phone_number",
            "select VOTES.created_day, VOTES.created_time, VOTES.phone_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the create dates, states, and phone numbers of the votes that were for the contestant named 'Tabatha Gehling'?, database: Database: voter_1_0. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name (Tabatha), c2: last_name (Gehling)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "CONTESTANTS VOTES",
        "real_label": "CONTESTANTS VOTES",
        "topk_preds": [
            "CONTESTANTS VOTES",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the area codes in which voters voted both for the contestant 'Tabatha Gehling' and the contestant 'Kelly Clauss'., database: Database: voter_1_0. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name (Tabatha, Kelly), c2: last_name (Gehling, Clauss)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM- WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT\u2013FROM-WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the area codes in which voters voted both for the contestant 'Tabatha Gehling' and the contestant 'Kelly Clauss'., database: Database: voter_1_0. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name (Tabatha, Kelly), c2: last_name (Gehling, Clauss)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "select t2.c2",
        "label": "select t0.c0",
        "score": false,
        "real_pred": "select VOTES.state",
        "real_label": "select AREA_CODE_STATE.area_code",
        "topk_preds": [
            "select VOTES.state",
            "select AREA_CODE_STATE.area_code",
            "select VOTES.vote_id",
            "select AREA_CODE_STATE.state",
            "select VOTES.phone_number",
            "select t0.c2",
            "select VOTES.state3",
            "select t02.c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the area codes in which voters voted both for the contestant 'Tabatha Gehling' and the contestant 'Kelly Clauss'., database: Database: voter_1_0. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name (Tabatha, Kelly), c2: last_name (Gehling, Clauss)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "AREA_CODE_STATE CONTESTANTS VOTES",
        "real_label": "AREA_CODE_STATE CONTESTANTS VOTES",
        "topk_preds": [
            "AREA_CODE_STATE CONTESTANTS VOTES",
            "CONTESTANTS VOTES",
            "",
            "",
            "",
            "VOTES",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the distinct states and create time of all votes?, database: Database: voter_1_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM (distinct t2.c2), SELECT-FROM",
            "SELECT-FROM distinct t2.c2, t2.c7",
            "SELECT-FROM (distinct t2.c2, t2.c7",
            "SELECT-FROM (distinct t2.c2), t2.c7",
            "SELECT-FROM (distinct t2.c2), distinct t2.c7",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM (distinct t2.c2, t2.c7)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the distinct states and create time of all votes?, database: Database: voter_1_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "select distinct t2.c2, t2.c7",
        "label": "select distinct t2.c2, t2.c4, t2.c5, t2.c6, t2.c7",
        "score": false,
        "real_pred": "select distinct VOTES.state, VOTES.created_time",
        "real_label": "select distinct VOTES.state, VOTES.created_year, VOTES.created_month, VOTES.created_day, VOTES.created_time",
        "topk_preds": [
            "select distinct VOTES.state, VOTES.created_time",
            "select distinct VOTES.state, distinct VOTES.created_time",
            "select distinct VOTES.state.c2, VOTES.created_time",
            "select distinct VOTES.state, VOTES.vote_id7",
            "select distinct VOTES.state, VOTES.created_time)",
            "select distinct VOTES.state-, VOTES.created_time",
            "select distinct VOTES.state, VOTES.created_time,",
            "select distinct t2.c 2, VOTES.created_time"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the distinct states and create time of all votes?, database: Database: voter_1_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "VOTES",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the create dates, states, and phone numbers of the votes that were for the contestant named 'Tabatha Gehling'?, database: Database: voter_1_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name (Tabatha Gehling)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the create dates, states, and phone numbers of the votes that were for the contestant named 'Tabatha Gehling'?, database: Database: voter_1_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name (Tabatha Gehling)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "select t2.c4, t2.c2, t2.c1",
        "label": "select t2.c4, t2.c5, t2.c6, t2.c7, t2.c2, t2.c1",
        "score": false,
        "real_pred": "select VOTES.created_year, VOTES.state, VOTES.phone_number",
        "real_label": "select VOTES.created_year, VOTES.created_month, VOTES.created_day, VOTES.created_time, VOTES.state, VOTES.phone_number",
        "topk_preds": [
            "select VOTES.created_year, VOTES.state, VOTES.phone_number",
            "select VOTES.created_day, VOTES.state, VOTES.phone_number",
            "select VOTES.created_time, VOTES.state, VOTES.phone_number",
            "select VOTES.created_month, VOTES.state, VOTES.phone_number",
            "select VOTES.created_year, VOTES.created_month, VOTES.phone_number",
            "select VOTES.created_year, VOTES.created_day, VOTES.phone_number",
            "select VOTES.created_day, VOTES.created_time, VOTES.phone_number",
            "select VOTES.vote_id, VOTES.state, VOTES.phone_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the create dates, states, and phone numbers of the votes that were for the contestant named 'Tabatha Gehling'?, database: Database: voter_1_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name (Tabatha Gehling)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_year, c5: created_month, c6: created_day, c7: created_time).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "CONTESTANTS VOTES",
        "real_label": "CONTESTANTS VOTES",
        "topk_preds": [
            "CONTESTANTS VOTES",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the distinct states and create time of all votes?, database: Database: voter_1_4. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM (distinct t2.c2), SELECT-FROM",
            "SELECT-FROM distinct t2.c2, t2.c5",
            "SELECT-FROM (distinct t2.c2, t2.c5",
            "SELECT-FROM (distinct t2.c2), distinct t2.c5",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM (distinct t2.c2), t2.c5",
            "SELECT-FROM-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the distinct states and create time of all votes?, database: Database: voter_1_4. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "select distinct t2.c2, t2.c5",
        "label": "select distinct t2.c2, t2.c4, t2.c5",
        "score": false,
        "real_pred": "select distinct VOTES.state, VOTES.created_time",
        "real_label": "select distinct VOTES.state, VOTES.created_date, VOTES.created_time",
        "topk_preds": [
            "select distinct VOTES.state, VOTES.created_time",
            "select distinct VOTES.state, distinct VOTES.created_time",
            "select distinct VOTES.state, VOTES.created_time, VOTES.vote_id",
            "select distinct VOTES.state.c2, VOTES.created_time",
            "select distinct VOTES.state, VOTES.created_time, VOTES.created_date",
            "select distinct VOTES.state, VOTES.created_time, t2.c6",
            "select distinct t2.c 2, VOTES.created_time",
            "select distinct VOTES.state-, VOTES.created_time"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the distinct states and create time of all votes?, database: Database: voter_1_4. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "VOTES",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the create dates, states, and phone numbers of the votes that were for the contestant named 'Tabatha Gehling'?, database: Database: voter_1_4. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name (Tabatha Gehling)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT.C4, t2.c2, t2.c1",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SQL-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SQL-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the create dates, states, and phone numbers of the votes that were for the contestant named 'Tabatha Gehling'?, database: Database: voter_1_4. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name (Tabatha Gehling)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "select t2.c4, t2.c2, t2.c1",
        "label": "select t2.c4, t2.c5, t2.c2, t2.c1",
        "score": false,
        "real_pred": "select VOTES.created_date, VOTES.state, VOTES.phone_number",
        "real_label": "select VOTES.created_date, VOTES.created_time, VOTES.state, VOTES.phone_number",
        "topk_preds": [
            "select VOTES.created_date, VOTES.state, VOTES.phone_number",
            "select VOTES.created_date, VOTES.state.c1, VOTES.phone_number",
            "select VOTES.created_date, VOTES.state, VOTES.phone_number",
            "select VOTES.created_date, VOTES.state, VOTES.phone_number",
            "select VOTES.created_date, VOTES.phone_number, VOTES.state",
            "select VOTES.created_date, VOTES.contestant_number, VOTES.phone_number",
            "select VOTES.created_date, VOTES.created_time, VOTES.phone_number",
            "select VOTES.created_date, t2.c6, VOTES.phone_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the create dates, states, and phone numbers of the votes that were for the contestant named 'Tabatha Gehling'?, database: Database: voter_1_4. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name (Tabatha Gehling)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "CONTESTANTS VOTES",
        "real_label": "CONTESTANTS VOTES",
        "topk_preds": [
            "CONTESTANTS VOTES",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the contestant numbers and names, ordered by contestant name descending., database: Database: voter_1_7. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name, c2: last_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c0, t1.c1, t1.c2",
            "SELECT-FROM-ORDER BY contestant.c0, t1.c1, t1.c2",
            "SELECT-FROM-ORDER BY contestant t1.c0, t1.c1, t1.c2",
            "SELECT-FROM-ORDER BY contestant numbers, t1.c1, t1.c2",
            "SELECT-FROM-ORDER BY contestant numbers, SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY contestant.c0, SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the contestant numbers and names, ordered by contestant name descending., database: Database: voter_1_7. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name, c2: last_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "select t1.c0, t1.c1, t1.c2",
        "label": "select t1.c0, t1.c1, t1.c2",
        "score": true,
        "real_pred": "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
        "real_label": "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
        "topk_preds": [
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select VOTES.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name, t1.c3",
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select t1.c3, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select CONTESTANTS.contestant_number-, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select VOTES.vote_id, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name, in-t1.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the contestant numbers and names, ordered by contestant name descending., database: Database: voter_1_7. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name, c2: last_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "CONTESTANTS",
        "real_label": "CONTESTANTS",
        "topk_preds": [
            "CONTESTANTS",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the contestants whose names are not 'Jessie Alloway', database: Database: voter_1_7. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name (Jessie), c2: last_name (Alloway)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the contestants whose names are not 'Jessie Alloway', database: Database: voter_1_7. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name (Jessie), c2: last_name (Alloway)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select CONTESTANTS.first_name, CONTESTANTS.last_name",
        "real_label": "select CONTESTANTS.first_name, CONTESTANTS.last_name",
        "topk_preds": [
            "select CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select distinct CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select CONTESTANTS.first_name.c1, CONTESTANTS.last_name",
            "select CONTESTANTS.first_name, CONTESTANTS.last_name, CONTESTANTS.contestant_number",
            "select t1.c 1, CONTESTANTS.last_name",
            "select other CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select the CONTESTANTS.first_name, CONTESTANTS.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the contestants whose names are not 'Jessie Alloway', database: Database: voter_1_7. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name (Jessie), c2: last_name (Alloway)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "CONTESTANTS",
        "real_label": "CONTESTANTS",
        "topk_preds": [
            "CONTESTANTS",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the distinct states and create time of all votes?, database: Database: voter_1_7. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name, c2: last_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM (distinct t2.c2), SELECT-FROM",
            "SELECT-FROM distinct t2.c2, t2.c5",
            "SELECT-FROM (distinct t2.c2, t2.c5",
            "SELECT-FROM (distinct t2.c2), distinct t2.c5",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM (distinct t2.c2), t2.c5",
            "SELECT-FROM-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the distinct states and create time of all votes?, database: Database: voter_1_7. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name, c2: last_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "select distinct t2.c2, t2.c5",
        "label": "select distinct t2.c2, t2.c4, t2.c5",
        "score": false,
        "real_pred": "select distinct VOTES.state, VOTES.created_time",
        "real_label": "select distinct VOTES.state, VOTES.created_date, VOTES.created_time",
        "topk_preds": [
            "select distinct VOTES.state, VOTES.created_time",
            "select distinct VOTES.state, distinct VOTES.created_time",
            "select distinct VOTES.state.c2, VOTES.created_time",
            "select distinct VOTES.state, VOTES.created_time, VOTES.vote_id",
            "select distinct VOTES.state, VOTES.created_time, VOTES.created_date",
            "select distinct VOTES.state, VOTES.created_time, t2.c6",
            "select distinct VOTES.state-, VOTES.created_time",
            "select distinct VOTES.state, VOTES.created_time,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the distinct states and create time of all votes?, database: Database: voter_1_7. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name, c2: last_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "VOTES",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the contestant numbers and names of the contestants who had at least two votes?, database: Database: voter_1_7. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name, c2: last_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the contestant numbers and names of the contestants who had at least two votes?, database: Database: voter_1_7. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name, c2: last_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "select t1.c0, t1.c1, t1.c2",
        "label": "select t1.c0, t1.c1, t1.c2",
        "score": true,
        "real_pred": "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
        "real_label": "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
        "topk_preds": [
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select VOTES.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select VOTES.state, CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select VOTES.vote_id, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select VOTES.phone_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name, CONTESTANTS.contestant_number",
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name, t1.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the contestant numbers and names of the contestants who had at least two votes?, database: Database: voter_1_7. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name, c2: last_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "CONTESTANTS VOTES",
        "real_label": "CONTESTANTS VOTES",
        "topk_preds": [
            "CONTESTANTS VOTES",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Of all the contestants who got voted, what is the contestant number and name of the contestant who got least votes?, database: Database: voter_1_7. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name, c2: last_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-C3 - SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Of all the contestants who got voted, what is the contestant number and name of the contestant who got least votes?, database: Database: voter_1_7. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name, c2: last_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "select t1.c0, t1.c1, t1.c2",
        "label": "select t1.c0, t1.c1, t1.c2",
        "score": true,
        "real_pred": "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
        "real_label": "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
        "topk_preds": [
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select VOTES.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select VOTES.state, CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name, t1.c3",
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name, CONTESTANTS.contestant_number",
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name, CONTESTANTS.last_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name-, CONTESTANTS.last_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Of all the contestants who got voted, what is the contestant number and name of the contestant who got least votes?, database: Database: voter_1_7. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name, c2: last_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "CONTESTANTS VOTES",
        "real_label": "CONTESTANTS VOTES",
        "topk_preds": [
            "CONTESTANTS VOTES",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the create dates, states, and phone numbers of the votes that were for the contestant named 'Tabatha Gehling'?, database: Database: voter_1_7. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name (Tabatha), c2: last_name (Gehling)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT.C4, t2.c2, t2.c1",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the create dates, states, and phone numbers of the votes that were for the contestant named 'Tabatha Gehling'?, database: Database: voter_1_7. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name (Tabatha), c2: last_name (Gehling)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "select t2.c4, t2.c2, t2.c1",
        "label": "select t2.c4, t2.c5, t2.c2, t2.c1",
        "score": false,
        "real_pred": "select VOTES.created_date, VOTES.state, VOTES.phone_number",
        "real_label": "select VOTES.created_date, VOTES.created_time, VOTES.state, VOTES.phone_number",
        "topk_preds": [
            "select VOTES.created_date, VOTES.state, VOTES.phone_number",
            "select VOTES.created_date, VOTES.state.c1, VOTES.phone_number",
            "select VOTES.created_date, VOTES.state, VOTES.phone_number",
            "select VOTES.created_date, VOTES.state, VOTES.phone_number",
            "select VOTES.created_date, VOTES.phone_number, VOTES.state",
            "select VOTES.created_date, t2.c6, VOTES.phone_number",
            "select VOTES.created_date, VOTES.created_time, VOTES.phone_number",
            "select VOTES.created_date, VOTES.contestant_number, VOTES.phone_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the create dates, states, and phone numbers of the votes that were for the contestant named 'Tabatha Gehling'?, database: Database: voter_1_7. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name (Tabatha), c2: last_name (Gehling)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "CONTESTANTS VOTES",
        "real_label": "CONTESTANTS VOTES",
        "topk_preds": [
            "CONTESTANTS VOTES",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the area codes in which voters voted both for the contestant 'Tabatha Gehling' and the contestant 'Kelly Clauss'., database: Database: voter_1_7. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name (Tabatha, Kelly), c2: last_name (Gehling, Clauss)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM- WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT\u2013FROM-WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the area codes in which voters voted both for the contestant 'Tabatha Gehling' and the contestant 'Kelly Clauss'., database: Database: voter_1_7. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name (Tabatha, Kelly), c2: last_name (Gehling, Clauss)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select AREA_CODE_STATE.area_code",
        "real_label": "select AREA_CODE_STATE.area_code",
        "topk_preds": [
            "select AREA_CODE_STATE.area_code",
            "select VOTES.state",
            "select VOTES.vote_id",
            "select VOTES.phone_number",
            "select AREA_CODE_STATE.state",
            "select t0.c2",
            "select VOTES.contestant_number",
            "select VOTES.state3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the area codes in which voters voted both for the contestant 'Tabatha Gehling' and the contestant 'Kelly Clauss'., database: Database: voter_1_7. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: first_name (Tabatha, Kelly), c2: last_name (Gehling, Clauss)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created_date, c5: created_time).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "AREA_CODE_STATE CONTESTANTS VOTES",
        "real_label": "AREA_CODE_STATE CONTESTANTS VOTES",
        "topk_preds": [
            "AREA_CODE_STATE CONTESTANTS VOTES",
            "CONTESTANTS VOTES",
            "",
            "",
            "",
            "VOTES",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of conductors in ascending order of age., database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY (t0.c1), SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t0.c1) - SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t0.c1), t0.c2",
            "SELECT-FROM-ORDER BY conductor.c1, t0.c2",
            "SELECT-FROM-ORDER BY t0.c1, t0.c2"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of conductors in ascending order of age., database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.birthyear",
            "select conductor.Conductor_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name in conductor.birthyear",
            "select conductor.first_name, conductor.last_name, conductor.birthyear",
            "select conductor.first_name, conductor.last_name dependant on conductor.birthyear",
            "select conductor.first_name, conductor.last_name and conductor.birthyear",
            "select conductor.first_name, conductor.last_name or conductor.birthyear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of conductors in ascending order of age., database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of conductors, ordered by age?, database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY (SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY ",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of conductors, ordered by age?, database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.birthyear",
            "select conductor.Conductor_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name in conductor.birthyear",
            "select conductor.first_name, conductor.last_name or conductor.birthyear",
            "select conductor.first_name, conductor.last_name, conductor.birthyear",
            "select conductor.first_name, conductor.last_name-ORDER BY",
            "select conductor.first_name, conductor.last_name in descending order"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of conductors, ordered by age?, database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of conductors whose nationalities are not \"USA\"?, database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality (USA), c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of conductors whose nationalities are not \"USA\"?, database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality (USA), c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select conductor.Conductor_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Nationality",
            "select conductor.first_name, conductor.last_name, conductor.birthyear",
            "select conductor.first_name., conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Nationality",
            "select conductor.first_name), conductor.last_name",
            "select conductor.first_name, conductor.last_name,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of conductors whose nationalities are not \"USA\"?, database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality (USA), c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the names of conductors that do not have the nationality \"USA\"., database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality (USA), c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the names of conductors that do not have the nationality \"USA\"., database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality (USA), c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select conductor.Conductor_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Nationality",
            "select conductor.first_name, conductor.last_name, conductor.birthyear",
            "select conductor.first_name., conductor.last_name",
            "select conductor.first_name, conductor.last_name,",
            "select conductor.first_name, conductor.last_name",
            "select conductor.first_name), conductor.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the names of conductors that do not have the nationality \"USA\"., database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality (USA), c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List names of conductors in descending order of years of work., database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY conductor.c1, t0.c2",
            "SELECT-FROM-ORDER BY Conductor.c1, t0.c2",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List names of conductors in descending order of years of work., database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select conductor.Conductor_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.year_start_to_work",
            "select conductor.first_name, conductor.last_name, conductor.birthyear",
            "select conductor.first_name, conductor.last_name, conductor.birthyear, conductor.year_start_to_work",
            "select conductor.first_name, conductor.last_name, conductor.birthyear, conductor.year_start_to_work",
            "select conductor.first_name, conductor.last_name, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.birthyear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List names of conductors in descending order of years of work., database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of conductors, sorted descending by the number of years they have worked?, database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0",
            "SELECT-FROM-ORDER BY conductor.c1, t0.c2",
            "SELECT-FROM-ORDER BY t0.C1, t0.c2",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY (SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of conductors, sorted descending by the number of years they have worked?, database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.birthyear",
            "select conductor.Conductor_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.year_start_to_work",
            "select conductor.first_name, conductor.last_name, conductor.birthyear, conductor.year_start_to_work",
            "select conductor.first_name, conductor.last_name, conductor.birthyear",
            "select conductor.first_name, conductor.last_name, conductor.birthyear, conductor.year_start_to_work",
            "select conductor.first_name, conductor.last_name (ordered conductor.Conductor_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of conductors, sorted descending by the number of years they have worked?, database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the name of the conductor with the most years of work., database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the name of the conductor with the most years of work., database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select conductor.Conductor_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.birthyear",
            "select conductor.first_name.c1, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.year_start_to_work",
            "select conductor.first_name, conductor.last_name, conductor.birthyear",
            "select conductor.first_name, conductor.last_name",
            "select conductor.last_name, conductor.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the name of the conductor with the most years of work., database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the conductor who has worked the greatest number of years?, database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the conductor who has worked the greatest number of years?, database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select conductor.Conductor_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.birthyear",
            "select conductor.first_name.c1, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.year_start_to_work",
            "select conductor.first_name, conductor.last_name",
            "select conductor.first_name., conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.birthyear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the conductor who has worked the greatest number of years?, database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "conductor orchestra performance",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of conductors and the orchestras they have conducted., database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM -ORDER BY",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM ORDER BY",
            "SELECT-FROM, ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of conductors and the orchestras they have conducted., database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2, t1.c1",
        "label": "select t0.c1, t0.c2, t1.c1",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name, orchestra.Orchestra",
        "real_label": "select conductor.first_name, conductor.last_name, orchestra.Orchestra",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name, orchestra.Orchestra",
            "select orchestra.Orchestra, conductor.first_name",
            "select conductor.first_name, conductor.last_name",
            "select show.Performance_ID, conductor.last_name, orchestra.Orchestra",
            "select performance.Performance_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, orchestra.Orchestra_ID",
            "select t.c1, conductor.last_name, orchestra.Orchestra",
            "select conductor.first_name, conductor.last_name, orchesorchestra.Orchestra"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of conductors and the orchestras they have conducted., database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of conductors as well as the corresonding orchestras that they have conducted?, database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-C1, SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-C1, t0.c2"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of conductors as well as the corresonding orchestras that they have conducted?, database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2, t1.c1",
        "label": "select t0.c1, t0.c2, t1.c1",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name, orchestra.Orchestra",
        "real_label": "select conductor.first_name, conductor.last_name, orchestra.Orchestra",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name, orchestra.Orchestra",
            "select conductor.first_name, conductor.last_name, corresponding orchestra.Orchestra",
            "select conductor.first_name, conductor.last_name, correspnding orchestra.Orchestra",
            "select orchestra.Orchestra, conductor.first_name",
            "select conductor.first_name, conductor.last_name, correspnt orchestra.Orchestra",
            "select conductor.first_name, conductor.last_name",
            "select show.Performance_ID, conductor.last_name, orchestra.Orchestra",
            "select conductor.first_name, conductor.last_name as well as orchestra.Orchestra"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of conductors as well as the corresonding orchestras that they have conducted?, database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of conductors that have conducted more than one orchestras., database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GATHER-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GEM-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of conductors that have conducted more than one orchestras., database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select orchestra.Conductor_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Conductor_ID",
            "select conductor.first_name, conductor.last_name, conductor.birthyear",
            "select conductor.first_name.c1, conductor.last_name",
            "select t 0.c1, conductor.last_name",
            "select t0-c1, conductor.last_name",
            "select t.c1, conductor.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of conductors that have conducted more than one orchestras., database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of conductors who have conducted at more than one orchestra?, database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GATHER-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-PROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of conductors who have conducted at more than one orchestra?, database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select orchestra.Conductor_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Conductor_ID",
            "select conductor.first_name, conductor.last_name, conductor.birthyear",
            "select conductor.first_name, conductor.last_name, conductor.Conductor_ID",
            "select t 0.c1, conductor.last_name",
            "select to.c1, conductor.last_name",
            "select t0-c1, conductor.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of conductors who have conducted at more than one orchestra?, database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the name of the conductor that has conducted the most number of orchestras., database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the name of the conductor that has conducted the most number of orchestras., database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select conductor.Conductor_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.birthyear",
            "select conductor.first_name.c1, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Conductor_ID",
            "select t.0.c1, conductor.last_name",
            "select t0.c 1, conductor.last_name",
            "select t 0.c1, conductor.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the name of the conductor that has conducted the most number of orchestras., database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the conductor who has conducted the most orchestras?, database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the conductor who has conducted the most orchestras?, database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select conductor.Conductor_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.birthyear",
            "select conductor.first_name.c1, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Conductor_ID",
            "select t0.c 1, conductor.last_name",
            "select conductor.first_name, conductor.last_name",
            "select t 0.c1, conductor.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the conductor who has conducted the most orchestras?, database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please show the name of the conductor that has conducted orchestras founded after 2008., database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-CONDUCTOR",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please show the name of the conductor that has conducted orchestras founded after 2008., database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.birthyear",
            "select distinct conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Conductor_ID",
            "select conductor.first_name., conductor.last_name",
            "select t 0.c1, conductor.last_name",
            "select conductor.first_name, conductor.last_name",
            "select t0-c1, conductor.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please show the name of the conductor that has conducted orchestras founded after 2008., database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of conductors who have conducted orchestras founded after the year 2008?, database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of conductors who have conducted orchestras founded after the year 2008?, database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select orchestra.Conductor_ID, conductor.first_name, conductor.last_name",
            "select distinct conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.birthyear",
            "select conductor.first_name, conductor.last_name, conductor.Conductor_ID",
            "select t0-c1, conductor.last_name",
            "select show.Performance_ID, conductor.last_name",
            "select t 0.c1, conductor.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of conductors who have conducted orchestras founded after the year 2008?, database: Database: orchestra_0. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: birthyear, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: day, c4: month, c5: official_ratings_in_millions, c6: weekly_rank, c7: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the record companies of orchestras in descending order of years in which they were founded?, database: Database: orchestra_1. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_existence, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (CLIENT-WHERE-ORDER BY",
            "SELECT-FROM-ORDER BY (CLIENT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c3",
            "SELECT-FROM-ORDER BY (CLIENT-PROFILE-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the record companies of orchestras in descending order of years in which they were founded?, database: Database: orchestra_1. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_existence, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select orchestra.Record_Company",
        "real_label": "select orchestra.Record_Company",
        "topk_preds": [
            "select orchestra.Record_Company",
            "select orchestra.Record_Company, orchestra.year_of_existence",
            "select orchestra.Record_Company (orchestrated orchestra.year_of_existence)",
            "select orchestra.Record_Company (orchestrator_orchestra.year_of_existence)",
            "select orchestra.Record_Company (orchestrator_orchestra.Record_Company)",
            "select orchestra.Record_Company (orchestration_orchestra.year_of_existence)",
            "select orchestra.Record_Company (orchestration_id)",
            "select orchestra.Record_Company (orchestrator.c4)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the record companies of orchestras in descending order of years in which they were founded?, database: Database: orchestra_1. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_existence, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the record companies of orchestras, sorted descending by the years in which they were founded., database: Database: orchestra_1. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_existence, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c3",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM\u2013ORDER BY",
            "SELECT-FROM,-ORDER BY",
            "SELECT-FROM- ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the record companies of orchestras, sorted descending by the years in which they were founded., database: Database: orchestra_1. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_existence, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select orchestra.Record_Company",
        "real_label": "select orchestra.Record_Company",
        "topk_preds": [
            "select orchestra.Record_Company",
            "select orchestra.Record_Company, orchestra.year_of_existence",
            "select orchestra.Record_Company (ordered orchestra.year_of_existence)",
            "select orchestra.Record_Company (ordered orchestra.Conductor_ID)",
            "select orchestra.Record_Company, orchestra.year_of_existence",
            "select orchestra.Record_Company de-facto-ORDER BY",
            "select orchestra.Record_Company de-facto-ordered",
            "select orchestra.Record_Company (ordered orchestra.Major_Record_Format)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the record companies of orchestras, sorted descending by the years in which they were founded., database: Database: orchestra_1. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_existence, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List names of conductors in descending order of years of work., database: Database: orchestra_1. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_existence, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY (t0.c1)",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY t0.c1"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List names of conductors in descending order of years of work., database: Database: orchestra_1. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_existence, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.year_start_to_work",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, t0.c5",
            "select conductor.Name, t0.c6",
            "select conductor.Name (ORDER BY"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List names of conductors in descending order of years of work., database: Database: orchestra_1. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_existence, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of conductors, sorted descending by the number of years they have worked?, database: Database: orchestra_1. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_existence, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1",
            "SELECT-FROM-ORDER BY t0",
            "SELECT-FROM-ORDER BY (t0.c1)",
            "SELECT-FROM-ORDER BY (CLIENT-WHERE-ORDER BY",
            "SELECT-FROM-ORDER BY (CLIENT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of conductors, sorted descending by the number of years they have worked?, database: Database: orchestra_1. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_existence, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.year_start_to_work",
            "select conductor.Name, conductor.Age",
            "select conductor.Name (ordered conductor.Conductor_ID)",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name (ordered conductor.Age)",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name (ordered conductor.year_start_to_work)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of conductors, sorted descending by the number of years they have worked?, database: Database: orchestra_1. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_existence, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the name of the conductor with the most years of work., database: Database: orchestra_1. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_existence, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the name of the conductor with the most years of work., database: Database: orchestra_1. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_existence, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.year_start_to_work",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name - conductor.Age",
            "select conductor.Name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the name of the conductor with the most years of work., database: Database: orchestra_1. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_existence, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the conductor who has worked the greatest number of years?, database: Database: orchestra_1. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_existence, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the conductor who has worked the greatest number of years?, database: Database: orchestra_1. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_existence, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.year_start_to_work",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, t0.c6",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name, t0.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the conductor who has worked the greatest number of years?, database: Database: orchestra_1. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_existence, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List names of conductors in descending order of years of work., database: Database: orchestra_2. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t0.c1)",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY t0.c1"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List names of conductors in descending order of years of work., database: Database: orchestra_2. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.year_start_to_work",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, t0.c5",
            "select conductor.Name, t0.c6",
            "select conductor.Name (ORDER BY"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List names of conductors in descending order of years of work., database: Database: orchestra_2. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of conductors, sorted descending by the number of years they have worked?, database: Database: orchestra_2. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1",
            "SELECT-FROM-ORDER BY t0",
            "SELECT-FROM-ORDER BY (t0.c1)",
            "SELECT-FROM-ORDER BY (CLIENT-WHERE-ORDER BY",
            "SELECT-FROM-ORDER BY (CLIENT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of conductors, sorted descending by the number of years they have worked?, database: Database: orchestra_2. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.year_start_to_work",
            "select conductor.Name, conductor.Age",
            "select conductor.Name (ordered conductor.Conductor_ID)",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name (ordered conductor.Age)",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name (ordered conductor.year_start_to_work)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of conductors, sorted descending by the number of years they have worked?, database: Database: orchestra_2. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the name of the conductor with the most years of work., database: Database: orchestra_2. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the name of the conductor with the most years of work., database: Database: orchestra_2. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.year_start_to_work",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name - conductor.Age",
            "select conductor.Name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the name of the conductor with the most years of work., database: Database: orchestra_2. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the conductor who has worked the greatest number of years?, database: Database: orchestra_2. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the conductor who has worked the greatest number of years?, database: Database: orchestra_2. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.year_start_to_work",
            "select conductor.Name, t0.c6",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name, t0.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the conductor who has worked the greatest number of years?, database: Database: orchestra_2. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of conductors in ascending order of age., database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-ORDER BY.",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY (SELECT-FROM\u2013ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of conductors in ascending order of age., database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Age",
            "select conductor.Conductor_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name in conductor.Age",
            "select conductor.first_name, conductor.last_name, conductor.Age",
            "select conductor.first_name, conductor.last_name, conductor.Age",
            "select conductor.first_name, conductor.last_name and conductor.Age",
            "select conductor.first_name, conductor.last_name or conductor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of conductors in ascending order of age., database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of conductors, ordered by age?, database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-ORDER BY (SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY (SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of conductors, ordered by age?, database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Age",
            "select conductor.Conductor_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Age",
            "select conductor.first_name, conductor.last_name or conductor.Age",
            "select conductor.first_name, conductor.last_name and conductor.Age",
            "select conductor.first_name, conductor.last_name, conductor.Age",
            "select conductor.first_name, conductor.last_name in conductor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of conductors, ordered by age?, database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of conductors whose nationalities are not \"USA\"?, database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality (USA), c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of conductors whose nationalities are not \"USA\"?, database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality (USA), c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select conductor.Conductor_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Nationality",
            "select conductor.first_name, conductor.last_name, conductor.Age",
            "select conductor.first_name., conductor.last_name",
            "select conductor.first_name), conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Nationality",
            "select conductor.first_name, conductor.last_name,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of conductors whose nationalities are not \"USA\"?, database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality (USA), c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the names of conductors that do not have the nationality \"USA\"., database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality (USA), c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the names of conductors that do not have the nationality \"USA\"., database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality (USA), c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select conductor.Conductor_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Age",
            "select conductor.first_name, conductor.last_name, conductor.Nationality",
            "select conductor.first_name., conductor.last_name",
            "select conductor.first_name, conductor.last_name,",
            "select conductor.first_name), conductor.last_name",
            "select conductor.first_name, conductor.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the names of conductors that do not have the nationality \"USA\"., database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality (USA), c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List names of conductors in descending order of years of work., database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY conductor.c1, t0.c2",
            "SELECT-FROM-ORDER BY Conductor.c1, t0.c2",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List names of conductors in descending order of years of work., database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Age",
            "select conductor.Conductor_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.year_start_to_work",
            "select conductor.first_name, conductor.last_name, conductor.Conductor_ID",
            "select conductor.first_name, conductor.last_name in conductor.year_start_to_work",
            "select conductor.first_name.c1, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List names of conductors in descending order of years of work., database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of conductors, sorted descending by the number of years they have worked?, database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0",
            "SELECT-FROM-ORDER BY conductor.c1, t0.c2",
            "SELECT-FROM-ORDER BY t0.C1, t0.c2",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of conductors, sorted descending by the number of years they have worked?, database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select conductor.Conductor_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Age",
            "select conductor.first_name, conductor.last_name, conductor.year_start_to_work",
            "select conductor.first_name, conductor.last_name, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Age, conductor.year_start_to_work",
            "select conductor.first_name, conductor.last_name, conductor.Conductor_ID",
            "select conductor.first_name, conductor.last_name, ord(conductor.Conductor_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of conductors, sorted descending by the number of years they have worked?, database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the name of the conductor with the most years of work., database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the name of the conductor with the most years of work., database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select conductor.Conductor_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Age",
            "select conductor.first_name.c1, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.year_start_to_work",
            "select conductor.first_name, conductor.last_name",
            "select conductor.first_name), conductor.last_name",
            "select conductor.last_name, conductor.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the name of the conductor with the most years of work., database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the conductor who has worked the greatest number of years?, database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the conductor who has worked the greatest number of years?, database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select conductor.Conductor_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Age",
            "select conductor.first_name, conductor.last_name, conductor.year_start_to_work",
            "select conductor.first_name.c1, conductor.last_name",
            "select conductor.first_name, conductor.last_name",
            "select conductor.first_name., conductor.last_name",
            "select conductor.first_name), conductor.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the conductor who has worked the greatest number of years?, database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            "conductor orchestra performance"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of conductors and the orchestras they have conducted., database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM -ORDER BY",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM, ORDER BY",
            "SELECT-FROM ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of conductors and the orchestras they have conducted., database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2, t1.c1",
        "label": "select t0.c1, t0.c2, t1.c1",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name, orchestra.Orchestra",
        "real_label": "select conductor.first_name, conductor.last_name, orchestra.Orchestra",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name, orchestra.Orchestra",
            "select orchestra.Orchestra, conductor.first_name",
            "select conductor.first_name, conductor.last_name",
            "select show.Performance_ID, conductor.last_name, orchestra.Orchestra",
            "select performance.Performance_ID, conductor.first_name, conductor.last_name",
            "select orchestra.Conductor_ID, conductor.first_name",
            "select conductor.first_name, conductor.last_name, orchestra.Orchestra_ID",
            "select t.c1, conductor.last_name, orchestra.Orchestra"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of conductors and the orchestras they have conducted., database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of conductors as well as the corresonding orchestras that they have conducted?, database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-C1, SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of conductors as well as the corresonding orchestras that they have conducted?, database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2, t1.c1",
        "label": "select t0.c1, t0.c2, t1.c1",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name, orchestra.Orchestra",
        "real_label": "select conductor.first_name, conductor.last_name, orchestra.Orchestra",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name, orchestra.Orchestra",
            "select conductor.first_name, conductor.last_name, corresponding orchestra.Orchestra",
            "select conductor.first_name, conductor.last_name, correspnding orchestra.Orchestra",
            "select orchestra.Conductor_ID, conductor.first_name",
            "select show.Performance_ID, conductor.last_name, orchestra.Orchestra",
            "select orchestra.Orchestra, conductor.first_name",
            "select orchestra.Conductor_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of conductors as well as the corresonding orchestras that they have conducted?, database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of conductors that have conducted more than one orchestras., database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GATHER-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GEM-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of conductors that have conducted more than one orchestras., database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select orchestra.Conductor_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Conductor_ID",
            "select conductor.first_name, conductor.last_name, conductor.Age",
            "select t 0.c1, conductor.last_name",
            "select show.Performance_ID, conductor.last_name",
            "select t0-c1, conductor.last_name",
            "select t.c1, conductor.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of conductors that have conducted more than one orchestras., database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of conductors who have conducted at more than one orchestra?, database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GATHER-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-PROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of conductors who have conducted at more than one orchestra?, database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select orchestra.Conductor_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Conductor_ID",
            "select conductor.first_name, conductor.last_name, conductor.Age",
            "select show.Performance_ID, conductor.last_name",
            "select t 0.c1, conductor.last_name",
            "select t0-c1, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Conductor_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of conductors who have conducted at more than one orchestra?, database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the name of the conductor that has conducted the most number of orchestras., database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the name of the conductor that has conducted the most number of orchestras., database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select conductor.Conductor_ID, conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Age",
            "select conductor.first_name.c1, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Conductor_ID",
            "select t.0.c1, conductor.last_name",
            "select t0.c 1, conductor.last_name",
            "select t 0.c1, conductor.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the name of the conductor that has conducted the most number of orchestras., database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the conductor who has conducted the most orchestras?, database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the conductor who has conducted the most orchestras?, database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Age",
            "select conductor.first_name, conductor.last_name, conductor.Conductor_ID",
            "select conductor.first_name.c1, conductor.last_name",
            "select t0.c 1, conductor.last_name",
            "select t.0.c1, conductor.last_name",
            "select t 0.c1, conductor.last_name",
            "select conductor.first_name, conductor.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the conductor who has conducted the most orchestras?, database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please show the name of the conductor that has conducted orchestras founded after 2008., database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-CONDUCTOR",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please show the name of the conductor that has conducted orchestras founded after 2008., database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Age",
            "select distinct conductor.first_name, conductor.last_name",
            "select conductor.first_name.c1, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Conductor_ID",
            "select show.Performance_ID, conductor.last_name",
            "select t 0.c1, conductor.last_name",
            "select performance.Orchestra_ID, conductor.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please show the name of the conductor that has conducted orchestras founded after 2008., database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of conductors who have conducted orchestras founded after the year 2008?, database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of conductors who have conducted orchestras founded after the year 2008?, database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select conductor.first_name, conductor.last_name",
        "real_label": "select conductor.first_name, conductor.last_name",
        "topk_preds": [
            "select conductor.first_name, conductor.last_name",
            "select orchestra.Conductor_ID, conductor.first_name, conductor.last_name",
            "select distinct conductor.first_name, conductor.last_name",
            "select conductor.first_name, conductor.last_name, conductor.Conductor_ID",
            "select conductor.first_name, conductor.last_name, conductor.Age",
            "select the conductor.first_name, conductor.last_name",
            "select show.Performance_ID, conductor.last_name",
            "select t0-c1, conductor.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of conductors who have conducted orchestras founded after the year 2008?, database: Database: orchestra_3. t0: conductor(c0: conductor_id, c1: first_name, c2: last_name, c3: age, c4: nationality, c5: year_start_to_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the record companies of orchestras in descending order of years in which they were founded?, database: Database: orchestra_4. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_existence, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (CLIENT-QUEST-SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (CLIENT-WHERE-ORDER BY",
            "SELECT-FROM-ORDER BY (CLIENT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (CLIENT-PROFILE-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c3",
            "SELECT-FROM-ORDER BY (SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the record companies of orchestras in descending order of years in which they were founded?, database: Database: orchestra_4. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_existence, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select orchestra.Record_Company",
        "real_label": "select orchestra.Record_Company",
        "topk_preds": [
            "select orchestra.Record_Company",
            "select orchestra.Record_Company, orchestra.year_of_existence",
            "select orchestra.Record_Company (orchestrated orchestra.year_of_existence)",
            "select orchestra.Record_Company (orchestrator_orchestra.Record_Company)",
            "select orchestra.Record_Company (orchestration_orchestra.year_of_existence)",
            "select orchestra.Record_Company (orchestrator_orchestra.year_of_existence)",
            "select orchestra.Record_Company (orchestral_orchestra.Record_Company)",
            "select orchestra.Record_Company (orchestration_id)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the record companies of orchestras in descending order of years in which they were founded?, database: Database: orchestra_4. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_existence, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the record companies of orchestras, sorted descending by the years in which they were founded., database: Database: orchestra_4. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_existence, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c3",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM\u2013ORDER BY",
            "SELECT-FROM,-ORDER BY",
            "SELECT-FROM- ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the record companies of orchestras, sorted descending by the years in which they were founded., database: Database: orchestra_4. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_existence, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select orchestra.Record_Company",
        "real_label": "select orchestra.Record_Company",
        "topk_preds": [
            "select orchestra.Record_Company",
            "select orchestra.Record_Company, orchestra.year_of_existence",
            "select orchestra.Record_Company (ordered orchestra.year_of_existence)",
            "select orchestra.Record_Company (ordered orchestra.Conductor_ID)",
            "select orchestra.Record_Company, orchestra.year_of_existence",
            "select orchestra.Record_Company de-facto-ORDER BY",
            "select orchestra.Record_Company de-facto-ordered",
            "select orchestra.Record_Company (ordered orchestra.Record_Company)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the record companies of orchestras, sorted descending by the years in which they were founded., database: Database: orchestra_4. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_existence, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the date of each treatment, together with the first name of the professional who operated it., database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id,",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM, SELECT-FROM",
            "SELECT-FROM -GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the date of each treatment, together with the first name of the professional who operated it., database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional",
        "prediction": "select t7.c13, t6.c2",
        "label": "select t7.c4, t7.c5, t6.c2",
        "score": false,
        "real_pred": "select Treatments.dog_id3, Professionals.first_name",
        "real_label": "select Treatments.date_of_treatment, Treatments.time_of_treatment, Professionals.first_name",
        "topk_preds": [
            "select Treatments.dog_id3, Professionals.first_name",
            "select Treatments.dog_id2, Professionals.first_name",
            "select Treatments.time_of_treatment, Professionals.first_name",
            "select Treatments.dog_id, Professionals.first_name",
            "select Treatments.treatment_type_code, Professionals.first_name",
            "select Treatments.dog_id5, Professionals.first_name",
            "select Treatments.professional_id3, Professionals.first_name",
            "select Treatments.dog_id4, Professionals.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the date of each treatment, together with the first name of the professional who operated it., database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, ",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Charges Professionals Treatments",
            "Breeds Professionals Treatments",
            "Sizes Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the date and the operating professional's first name of each treatment?, database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-PROCESS-UNION-SELECT-FROM",
            "SELECT-FROM-PROCESS-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-PROCESS-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the date and the operating professional's first name of each treatment?, database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id",
        "prediction": "select t7.c13, t6.c2",
        "label": "select t7.c4, t7.c5, t6.c2",
        "score": false,
        "real_pred": "select Treatments.dog_id3, Professionals.first_name",
        "real_label": "select Treatments.date_of_treatment, Treatments.time_of_treatment, Professionals.first_name",
        "topk_preds": [
            "select Treatments.dog_id3, Professionals.first_name",
            "select Treatments.dog_id2, Professionals.first_name",
            "select Treatments.time_of_treatment, Professionals.first_name",
            "select Treatments.dog_id5, Professionals.first_name",
            "select Treatments.dog_id4, Professionals.first_name",
            "select Treatments.dog_id, Professionals.first_name",
            "select Treatments.treatment_type_code, Professionals.first_name",
            "select Treatments.professional_id3, Professionals.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the date and the operating professional's first name of each treatment?, database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3:",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Sizes Professionals Treatments",
            "Charges Professionals Treatments",
            "Breeds Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of the dogs of the rarest breed and the treatment dates of them., database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id,",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of the dogs of the rarest breed and the treatment dates of them., database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional",
        "prediction": "select t5.c5, t7.c3",
        "label": "select t5.c5, t7.c4, t7.c5",
        "score": false,
        "real_pred": "select Dogs.name, Treatments.treatment_type_code",
        "real_label": "select Dogs.name, Treatments.date_of_treatment, Treatments.time_of_treatment",
        "topk_preds": [
            "select Dogs.name, Treatments.treatment_type_code",
            "select Dogs.name, Treatments.dog_id3",
            "select Dogs.name, Treatments.dog_id2",
            "select Dogs.name, Treatments.dog_id",
            "select Dogs.name, Treatments.treatment_type_code0",
            "select Dogs.name, Treatments.professional_id",
            "select Dogs.name, Treatments.dog_id5",
            "select Dogs.name, Treatments.dog_id4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of the dogs of the rarest breed and the treatment dates of them., database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, ",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Breeds Dogs Treatments",
            "Charges Dogs Treatments",
            "Sizes Dogs Treatments",
            "Treatment_Types Dogs Treatments",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which dogs are of the rarest breed? Show their names and treatment dates., database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which dogs are of the rarest breed? Show their names and treatment dates., database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_i",
        "prediction": "select t5.c5, t7.c13",
        "label": "select t5.c5, t7.c4, t7.c5",
        "score": false,
        "real_pred": "select Dogs.name, Treatments.dog_id3",
        "real_label": "select Dogs.name, Treatments.date_of_treatment, Treatments.time_of_treatment",
        "topk_preds": [
            "select Dogs.name, Treatments.dog_id3",
            "select Dogs.name, Treatments.treatment_type_code",
            "select Dogs.name, Treatments.dog_id2",
            "select Dogs.name, Treatments.dog_id",
            "select Dogs.name, Treatments.professional_id",
            "select Dogs.name, Treatments.dog_id4",
            "select Dogs.name, Treatments.dog_id5",
            "select Dogs.name, Treatments.date_of_treatment"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which dogs are of the rarest breed? Show their names and treatment dates., database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Breeds Dogs Treatments",
            "Breeds Charges Dogs Treatments",
            "Charges Dogs Treatments",
            "Treatment_Types Dogs Treatments",
            "Sizes Dogs Treatments",
            "Breeds Charges Sizes Dogs Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the arriving date and the departing date of the dogs who have gone through a treatment?, database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_i",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM (t5.c0 - t5.c13), SELECT-FROM",
            "SELECT-FROM (t5.c0, t5.c13, t5.c16",
            "SELECT-FROM (t5.c0 - t5.c13) - SELECT-FROM",
            "SELECT-FROM (t5.c0 - t5.c13 - t5.c16",
            "SELECT-FROM (t5.c0 - t5.c10) - SELECT-FROM",
            "SELECT-FROM (t5.c0, t5.c12, t5.c16",
            "SELECT-FROM (t5.c0 - t5.c13 - t5.c16)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the arriving date and the departing date of the dogs who have gone through a treatment?, database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2",
        "prediction": "select t5.c13, t5.c16",
        "label": "select distinct t5.c10, t5.c11, t5.c12, t5.c13, t5.c16, t5.c17",
        "score": false,
        "real_pred": "select Dogs.time_arrived, Dogs.date_departed",
        "real_label": "select distinct Dogs.year_arrived, Dogs.month_arrived, Dogs.day_arrived, Dogs.time_arrived, Dogs.date_departed, Dogs.time_departed",
        "topk_preds": [
            "select Dogs.time_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.day_arrived, Dogs.date_departed",
            "select Dogs.day_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.day_arrived",
            "select Dogs.dog_id, Dogs.time_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.owner_id, Dogs.date_departed",
            "select Dogs.year_arrived, Dogs.date_departed",
            "select Dogs.year_arrived, Dogs.month_arrived"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the arriving date and the departing date of the dogs who have gone through a treatment?, database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Dogs Professionals Treatments",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the arriving date and the departing date of the dogs that received a treatment., database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, ",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-ATTACH-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-ATTACH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the arriving date and the departing date of the dogs that received a treatment., database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_",
        "prediction": "select t5.c13, t5.c16",
        "label": "select distinct t5.c10, t5.c11, t5.c12, t5.c13, t5.c16, t5.c17",
        "score": false,
        "real_pred": "select Dogs.time_arrived, Dogs.date_departed",
        "real_label": "select distinct Dogs.year_arrived, Dogs.month_arrived, Dogs.day_arrived, Dogs.time_arrived, Dogs.date_departed, Dogs.time_departed",
        "topk_preds": [
            "select Dogs.time_arrived, Dogs.date_departed",
            "select Dogs.day_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.day_arrived, Dogs.date_departed",
            "select Dogs.year_arrived, Dogs.date_departed",
            "select Dogs.year_arrived, Dogs.month_arrived",
            "select Dogs.dog_id, Dogs.day_arrived",
            "select Dogs.owner_id, Dogs.date_departed",
            "select Dogs.year_arrived, Dogs.time_arrived"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the arriving date and the departing date of the dogs that received a treatment., database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Dogs Professionals Treatments",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the arriving date and the departing date of all the dogs?, database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3:",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM (UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the arriving date and the departing date of all the dogs?, database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id,",
        "prediction": "select t5.c10, t5.c16",
        "label": "select t5.c10, t5.c11, t5.c12, t5.c13, t5.c16, t5.c17",
        "score": false,
        "real_pred": "select Dogs.year_arrived, Dogs.date_departed",
        "real_label": "select Dogs.year_arrived, Dogs.month_arrived, Dogs.day_arrived, Dogs.time_arrived, Dogs.date_departed, Dogs.time_departed",
        "topk_preds": [
            "select Dogs.year_arrived, Dogs.date_departed",
            "select Dogs.time_arrived, Dogs.date_departed",
            "select Dogs.day_arrived, Dogs.date_departed",
            "select Dogs.owner_id, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.day_arrived",
            "select Dogs.dog_id, Dogs.owner_id",
            "select Dogs.dog_id, Dogs.abandoned_yn",
            "select Dogs.year_arrived, Dogs.month_arrived"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the arriving date and the departing date of all the dogs?, database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the arrival date and the departure date for all the dogs., database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT.C10, SELECT.C16",
            "SELECT-FROM (UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY",
            "SELECT.C10, SELECT-C16"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the arrival date and the departure date for all the dogs., database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c",
        "prediction": "select t5.c10, t5.c16",
        "label": "select t5.c10, t5.c11, t5.c12, t5.c13, t5.c16, t5.c17",
        "score": false,
        "real_pred": "select Dogs.year_arrived, Dogs.date_departed",
        "real_label": "select Dogs.year_arrived, Dogs.month_arrived, Dogs.day_arrived, Dogs.time_arrived, Dogs.date_departed, Dogs.time_departed",
        "topk_preds": [
            "select Dogs.year_arrived, Dogs.date_departed",
            "select Dogs.time_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.owner_id, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.owner_id, Dogs.abandoned_yn",
            "select Dogs.dog_id, Dogs.day_arrived",
            "select Dogs.dog_id, Dogs.year_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.day_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.time_arrived, Dogs.date_departed"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the arrival date and the departure date for all the dogs., database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How much does the most recent treatment cost?, database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code,",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, t1.c2"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How much does the most recent treatment cost?, database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_",
        "prediction": "select t1.c2",
        "label": "select t7.c6",
        "score": false,
        "real_pred": "select Charges.charge_amount",
        "real_label": "select Treatments.cost_of_treatment",
        "topk_preds": [
            "select Charges.charge_amount",
            "select Treatments.treatment_id, Charges.charge_amount",
            "select Treatments.date_of_treatment",
            "select t8.c0, Charges.charge_amount",
            "select Treatments.dog_id, Charges.charge_amount",
            "select Treatments.time_of_treatment",
            "select Treatments.time_of_treatment, Charges.charge_amount",
            "select Treatments.treatment_type_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How much does the most recent treatment cost?, database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, ",
        "prediction": "t1 t7",
        "label": "t7",
        "score": false,
        "real_pred": "Charges Treatments",
        "real_label": "Treatments",
        "topk_preds": [
            "Charges Treatments",
            "Charges",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the cost of the most recently performed treatment., database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the cost of the most recently performed treatment., database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3:",
        "prediction": "select t1.c2",
        "label": "select t7.c6",
        "score": false,
        "real_pred": "select Charges.charge_amount",
        "real_label": "select Treatments.cost_of_treatment",
        "topk_preds": [
            "select Charges.charge_amount",
            "select Treatments.time_of_treatment, Charges.charge_amount",
            "select Treatments.treatment_id, Charges.charge_amount",
            "select Treatments.dog_id, Charges.charge_amount",
            "select Charges.charge_id, Charges.charge_amount",
            "select Treatments.treatment_type_code, Charges.charge_amount",
            "select Charges.charge_type, Charges.charge_amount",
            "select Treatments.time_of_treatment, Treatments.cost_of_treatment"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the cost of the most recently performed treatment., database: Database: dog_kennels_0. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: time_adopted, c16: date_departed, c17: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code",
        "prediction": "t1 t7",
        "label": "t7",
        "score": false,
        "real_pred": "Charges Treatments",
        "real_label": "Treatments",
        "topk_preds": [
            "Charges Treatments",
            "",
            "",
            "",
            "",
            "",
            "",
            "Breeds Charges Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the date of each treatment, together with the first name of the professional who operated it., database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day_of",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM, SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the date of each treatment, together with the first name of the professional who operated it., database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6",
        "prediction": "select t7.c5, t6.c2",
        "label": "select t7.c4, t7.c5, t7.c6, t7.c7, t6.c2",
        "score": false,
        "real_pred": "select Treatments.month_of_treatment, Professionals.first_name",
        "real_label": "select Treatments.year_of_treatment, Treatments.month_of_treatment, Treatments.day_of_treatment, Treatments.time_of_treatment, Professionals.first_name",
        "topk_preds": [
            "select Treatments.month_of_treatment, Professionals.first_name",
            "select Treatments.year_of_treatment, Professionals.first_name",
            "select Treatments.treatment_type_code, Professionals.first_name",
            "select Treatments.month_of_treatment, Professionals.role_code",
            "select Treatments.month_of_treatment, Professionals.zip_code",
            "select Treatments.day_of_treatment, Professionals.first_name",
            "select t0.c5, Professionals.first_name",
            "select Treatments.dog_id, Professionals.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the date of each treatment, together with the first name of the professional who operated it., database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day_of_",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Breeds Professionals Treatments",
            "Charges Professionals Treatments",
            "Sizes Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the date and the operating professional's first name of each treatment?, database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day_of_treatment,",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-PROCESS-UNION-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-PROCESS-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-PROCESS-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the date and the operating professional's first name of each treatment?, database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day_",
        "prediction": "select t7.c6, t6.c2",
        "label": "select t7.c4, t7.c5, t7.c6, t7.c7, t6.c2",
        "score": false,
        "real_pred": "select Treatments.day_of_treatment, Professionals.first_name",
        "real_label": "select Treatments.year_of_treatment, Treatments.month_of_treatment, Treatments.day_of_treatment, Treatments.time_of_treatment, Professionals.first_name",
        "topk_preds": [
            "select Treatments.day_of_treatment, Professionals.first_name",
            "select Treatments.month_of_treatment, Professionals.first_name",
            "select Treatments.treatment_type_code, Professionals.first_name",
            "select Treatments.year_of_treatment, Professionals.first_name",
            "select t0.c6, Professionals.first_name",
            "select Treatments.dog_id, Professionals.first_name",
            "select Treatments.day_of_treatment, t06.c2",
            "select Treatments.day_of_treatment, Professionals.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the date and the operating professional's first name of each treatment?, database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day_of_treatment, ",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Charges Professionals Treatments",
            "Breeds Professionals Treatments",
            "Sizes Professionals Treatments",
            "Sizes Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of the dogs of the rarest breed and the treatment dates of them., database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day_of",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of the dogs of the rarest breed and the treatment dates of them., database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6",
        "prediction": "select t5.c5, t7.c4",
        "label": "select t5.c5, t7.c4, t7.c5, t7.c6, t7.c7",
        "score": false,
        "real_pred": "select Dogs.name, Treatments.year_of_treatment",
        "real_label": "select Dogs.name, Treatments.year_of_treatment, Treatments.month_of_treatment, Treatments.day_of_treatment, Treatments.time_of_treatment",
        "topk_preds": [
            "select Dogs.name, Treatments.year_of_treatment",
            "select Dogs.name, Treatments.treatment_type_code",
            "select Dogs.name, Treatments.month_of_treatment",
            "select Dogs.name, Treatments.day_of_treatment",
            "select Dogs.name, Treatments.professional_id",
            "select Dogs.name, Treatments.dog_id",
            "select Dogs.name, t7.5.c4",
            "select Dogs.name, t07.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of the dogs of the rarest breed and the treatment dates of them., database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day_of_",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Breeds Dogs Treatments",
            "Breeds Charges Dogs Treatments",
            "Charges Dogs Treatments",
            "Sizes Dogs Treatments",
            "Breeds Charges Sizes Dogs Treatments",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which dogs are of the rarest breed? Show their names and treatment dates., database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day_of_treatment",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which dogs are of the rarest breed? Show their names and treatment dates., database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day",
        "prediction": "select t5.c5, t7.c6",
        "label": "select t5.c5, t7.c4, t7.c5, t7.c6, t7.c7",
        "score": false,
        "real_pred": "select Dogs.name, Treatments.day_of_treatment",
        "real_label": "select Dogs.name, Treatments.year_of_treatment, Treatments.month_of_treatment, Treatments.day_of_treatment, Treatments.time_of_treatment",
        "topk_preds": [
            "select Dogs.name, Treatments.day_of_treatment",
            "select Dogs.name, Treatments.year_of_treatment",
            "select Dogs.name, Treatments.treatment_type_code",
            "select Dogs.name, Treatments.month_of_treatment",
            "select Dogs.name, Treatments.dog_id",
            "select Dogs.name, Treatments.professional_id",
            "select Dogs.name, Treatments.cost_of_treatment",
            "select Dogs.name, Treatments.time_of_treatment"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which dogs are of the rarest breed? Show their names and treatment dates., database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day_of_treatment,",
        "prediction": "t0 t5 t7",
        "label": "t5 t7",
        "score": false,
        "real_pred": "Breeds Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Breeds Dogs Treatments",
            "Dogs Treatments",
            "Breeds Charges Dogs Treatments",
            "Charges Dogs Treatments",
            "Sizes Dogs Treatments",
            "Treatment_Types Dogs Treatments",
            "Breeds Charges Sizes Dogs Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the arriving date and the departing date of the dogs who have gone through a treatment?, database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM (t5.c0 - t5.c10) - SELECT-FROM",
            "SELECT-FROM (t5.c0 - t5.c10), SELECT-FROM",
            "SELECT-FROM (t5.c10), SELECT-FROM",
            "SELECT-FROM (t5.c0 - t5.c13",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM (t5.c10), SELECT-FROM (t5.c13"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the arriving date and the departing date of the dogs who have gone through a treatment?, database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, ",
        "prediction": "select t5.c10, t5.c13",
        "label": "select distinct t5.c10, t5.c11, t5.c13",
        "score": false,
        "real_pred": "select Dogs.date_arrived, Dogs.date_departed",
        "real_label": "select distinct Dogs.date_arrived, Dogs.time_arrived, Dogs.date_departed",
        "topk_preds": [
            "select Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.date_departed",
            "select Dogs.date_of_birth, Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.owner_id, Dogs.date_departed",
            "select Dogs.weight, Dogs.date_departed",
            "select Dogs.date_departed, Dogs.date_arrived",
            "select Dogs.date_arrived, Dogs.date_departed, Dogs.dog_id",
            "select Dogs.date_arrived, Dogs.date_departed, Treatments.dog_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the arriving date and the departing date of the dogs who have gone through a treatment?, database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day_",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Dogs Professionals Treatments",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the arriving date and the departing date of the dogs that received a treatment., database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day_of_",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ATTACH-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the arriving date and the departing date of the dogs that received a treatment., database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6:",
        "prediction": "select t5.c10, t5.c13",
        "label": "select distinct t5.c10, t5.c11, t5.c13",
        "score": false,
        "real_pred": "select Dogs.date_arrived, Dogs.date_departed",
        "real_label": "select distinct Dogs.date_arrived, Dogs.time_arrived, Dogs.date_departed",
        "topk_preds": [
            "select Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.date_departed",
            "select Dogs.date_of_birth, Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.owner_id, Dogs.date_departed",
            "select Dogs.weight, Dogs.date_departed",
            "select distinct Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.date_departed, Dogs.date_arrived",
            "select Dogs.date_arrived, Dogs.date_departed, Treatments.dog_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the arriving date and the departing date of the dogs that received a treatment., database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day_of_treatment",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Dogs Professionals Treatments",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the arriving date and the departing date of all the dogs?, database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day_of_treatment, ",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM (UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT.C10, SELECT.C13",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT.C10, SELECT-C13"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the arriving date and the departing date of all the dogs?, database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day_of",
        "prediction": "select t5.c10, t5.c13",
        "label": "select t5.c10, t5.c11, t5.c13",
        "score": false,
        "real_pred": "select Dogs.date_arrived, Dogs.date_departed",
        "real_label": "select Dogs.date_arrived, Dogs.time_arrived, Dogs.date_departed",
        "topk_preds": [
            "select Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.date_departed",
            "select Dogs.owner_id, Dogs.date_departed",
            "select Dogs.weight, Dogs.date_departed",
            "select Dogs.age, Dogs.date_departed",
            "select Dogs.date_of_birth, Dogs.date_departed",
            "select Dogs.name, Dogs.date_departed",
            "select Dogs.owner_id, Dogs.breed_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the arriving date and the departing date of all the dogs?, database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day_of_treatment, c",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the arrival date and the departure date for all the dogs., database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day_of_treatment, c7",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT.C10, SELECT.C13",
            "SELECT-FROM (UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY",
            "SELECT.C10, SELECT-C13"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the arrival date and the departure date for all the dogs., database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day_of_treatment",
        "prediction": "select t5.c10, t5.c13",
        "label": "select t5.c10, t5.c11, t5.c13",
        "score": false,
        "real_pred": "select Dogs.date_arrived, Dogs.date_departed",
        "real_label": "select Dogs.date_arrived, Dogs.time_arrived, Dogs.date_departed",
        "topk_preds": [
            "select Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.date_departed",
            "select Dogs.owner_id, Dogs.date_departed",
            "select Dogs.weight, Dogs.date_departed",
            "select Dogs.age, Dogs.date_departed",
            "select Dogs.date_of_birth, Dogs.date_departed",
            "select Dogs.name, Dogs.date_departed",
            "select Dogs.gender, Dogs.weight"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the arrival date and the departure date for all the dogs., database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day_of_treatment, c7:",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How much does the most recent treatment cost?, database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day_of_treatment, c7: time_of",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How much does the most recent treatment cost?, database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day_of_treatment, c7",
        "prediction": "select t1.c2",
        "label": "select t7.c8",
        "score": false,
        "real_pred": "select Charges.charge_amount",
        "real_label": "select Treatments.cost_of_treatment",
        "topk_preds": [
            "select Charges.charge_amount",
            "select Treatments.treatment_id, Charges.charge_amount",
            "select t8.c0, Charges.charge_amount",
            "select Treatments.month_of_treatment",
            "select Treatments.month_of_treatment, Charges.charge_amount",
            "select Treatments.treatment_id, sum(Charges.charge_amount)",
            "select max(Charges.charge_amount)",
            "select Treatments.year_of_treatment"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How much does the most recent treatment cost?, database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day_of_treatment, c7: time_of_",
        "prediction": "t1 t7",
        "label": "t7",
        "score": false,
        "real_pred": "Charges Treatments",
        "real_label": "Treatments",
        "topk_preds": [
            "Charges Treatments",
            "Breeds Charges Treatments",
            "",
            "Charges",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the cost of the most recently performed treatment., database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day_of_treatment, c7: time",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the cost of the most recently performed treatment., database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day_of_treatment, ",
        "prediction": "select t1.c2",
        "label": "select t7.c8",
        "score": false,
        "real_pred": "select Charges.charge_amount",
        "real_label": "select Treatments.cost_of_treatment",
        "topk_preds": [
            "select Charges.charge_amount",
            "select Treatments.month_of_treatment, Charges.charge_amount",
            "select Charges.charge_id, Charges.charge_amount",
            "select t7.c9, Charges.charge_amount",
            "select Treatments.treatment_id, Charges.charge_amount",
            "select Charges.charge_type, Charges.charge_amount",
            "select Treatments.time_of_treatment, Charges.charge_amount",
            "select Treatments.month_of_treatment, Treatments.day_of_treatment"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the cost of the most recently performed treatment., database: Database: dog_kennels_1. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: date_adopted, c13: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: year_of_treatment, c5: month_of_treatment, c6: day_of_treatment, c7: time_",
        "prediction": "t1 t7",
        "label": "t7",
        "score": false,
        "real_pred": "Charges Treatments",
        "real_label": "Treatments",
        "topk_preds": [
            "Charges Treatments",
            "Breeds Charges Treatments",
            "",
            "",
            "Charges",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the arriving date and the departing date of the dogs who have gone through a treatment?, database: Database: dog_kennels_4. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: date_departed, c16: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM (t5.c0 - t5.c13), SELECT-FROM",
            "SELECT-FROM (t5.c0 - t5.c13) - SELECT-FROM",
            "SELECT-FROM (t5.c0 - t5.c12 - t5.c15",
            "SELECT-FROM (t5.c0 - t5.c13 - t5.c15",
            "SELECT-FROM (t5.c0 - t5.c12) - SELECT-FROM",
            "SELECT-FROM (t5.c0, t5.c13, t5.c15",
            "SELECT-FROM (t5.c0 - t5.c13) SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the arriving date and the departing date of the dogs who have gone through a treatment?, database: Database: dog_kennels_4. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: date_departed, c16: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment",
        "prediction": "select t5.c13, t5.c15",
        "label": "select distinct t5.c10, t5.c11, t5.c12, t5.c13, t5.c15, t5.c16",
        "score": false,
        "real_pred": "select Dogs.time_arrived, Dogs.date_departed",
        "real_label": "select distinct Dogs.year_arrived, Dogs.month_arrived, Dogs.day_arrived, Dogs.time_arrived, Dogs.date_departed, Dogs.time_departed",
        "topk_preds": [
            "select Dogs.time_arrived, Dogs.date_departed",
            "select Dogs.year_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.day_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.time_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.day_arrived",
            "select Dogs.day_arrived, Dogs.date_departed",
            "select Dogs.time_arrived, Dogs.date_adopted"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the arriving date and the departing date of the dogs who have gone through a treatment?, database: Database: dog_kennels_4. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: date_departed, c16: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code,",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Dogs Professionals Treatments",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the arriving date and the departing date of the dogs that received a treatment., database: Database: dog_kennels_4. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: date_departed, c16: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-ATTACH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-ATTACH-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the arriving date and the departing date of the dogs that received a treatment., database: Database: dog_kennels_4. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: date_departed, c16: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_",
        "prediction": "select t5.c13, t5.c15",
        "label": "select distinct t5.c10, t5.c11, t5.c12, t5.c13, t5.c15, t5.c16",
        "score": false,
        "real_pred": "select Dogs.time_arrived, Dogs.date_departed",
        "real_label": "select distinct Dogs.year_arrived, Dogs.month_arrived, Dogs.day_arrived, Dogs.time_arrived, Dogs.date_departed, Dogs.time_departed",
        "topk_preds": [
            "select Dogs.time_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.day_arrived, Dogs.date_departed",
            "select Dogs.day_arrived, Dogs.date_departed",
            "select Dogs.year_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.time_arrived, Dogs.date_departed",
            "select Dogs.time_arrived, Dogs.date_adopted",
            "select Dogs.dog_id, Dogs.day_arrived, Dogs.time_arrived",
            "select Dogs.dog_id, Dogs.date_departed"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the arriving date and the departing date of the dogs that received a treatment., database: Database: dog_kennels_4. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: date_departed, c16: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Dogs Professionals Treatments",
            "Owners Dogs Treatments",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the arriving date and the departing date of all the dogs?, database: Database: dog_kennels_4. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: date_departed, c16: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM (UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the arriving date and the departing date of all the dogs?, database: Database: dog_kennels_4. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: date_departed, c16: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, ",
        "prediction": "select t5.c10, t5.c15",
        "label": "select t5.c10, t5.c11, t5.c12, t5.c13, t5.c15, t5.c16",
        "score": false,
        "real_pred": "select Dogs.year_arrived, Dogs.date_departed",
        "real_label": "select Dogs.year_arrived, Dogs.month_arrived, Dogs.day_arrived, Dogs.time_arrived, Dogs.date_departed, Dogs.time_departed",
        "topk_preds": [
            "select Dogs.year_arrived, Dogs.date_departed",
            "select Dogs.time_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.date_departed",
            "select Dogs.day_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.owner_id, Dogs.date_departed",
            "select Dogs.owner_id, Dogs.date_departed",
            "select Dogs.time_arrived, Dogs.date_adopted",
            "select Dogs.dog_id, Dogs.day_arrived, Dogs.date_departed"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the arriving date and the departing date of all the dogs?, database: Database: dog_kennels_4. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: date_departed, c16: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the arrival date and the departure date for all the dogs., database: Database: dog_kennels_4. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: date_departed, c16: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM (UNION-SELECT-FROM",
            "SELECT.C10, SELECT.C15",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY",
            "SELECT.C10, SELECT-C15"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the arrival date and the departure date for all the dogs., database: Database: dog_kennels_4. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: date_departed, c16: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4",
        "prediction": "select t5.c10, t5.c15",
        "label": "select t5.c10, t5.c11, t5.c12, t5.c13, t5.c15, t5.c16",
        "score": false,
        "real_pred": "select Dogs.year_arrived, Dogs.date_departed",
        "real_label": "select Dogs.year_arrived, Dogs.month_arrived, Dogs.day_arrived, Dogs.time_arrived, Dogs.date_departed, Dogs.time_departed",
        "topk_preds": [
            "select Dogs.year_arrived, Dogs.date_departed",
            "select Dogs.time_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.owner_id, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.year_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.day_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.time_arrived, Dogs.date_departed",
            "select Dogs.time_arrived, Dogs.date_adopted"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the arrival date and the departure date for all the dogs., database: Database: dog_kennels_4. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: year_arrived, c11: month_arrived, c12: day_arrived, c13: time_arrived, c14: date_adopted, c15: date_departed, c16: time_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the date of each treatment, together with the first name of the professional who operated it., database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM -GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the date of each treatment, together with the first name of the professional who operated it., database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3",
        "prediction": "select t7.c13, t6.c2",
        "label": "select t7.c4, t7.c5, t6.c2",
        "score": false,
        "real_pred": "select Treatments.dog_id3, Professionals.first_name",
        "real_label": "select Treatments.date_of_treatment, Treatments.time_of_treatment, Professionals.first_name",
        "topk_preds": [
            "select Treatments.dog_id3, Professionals.first_name",
            "select Treatments.treatment_type_code, Professionals.first_name",
            "select Treatments.time_of_treatment, Professionals.first_name",
            "select Treatments.dog_id2, Professionals.first_name",
            "select Treatments.dog_id, Professionals.first_name",
            "select Treatments.dog_id5, Professionals.first_name",
            "select Treatments.dog_id4, Professionals.first_name",
            "select Treatments.professional_id3, Professionals.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the date of each treatment, together with the first name of the professional who operated it., database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Charges Professionals Treatments",
            "Sizes Professionals Treatments",
            "Breeds Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the date and the operating professional's first name of each treatment?, database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code,",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-PROCESS-UNION-SELECT-FROM",
            "SELECT-FROM-PROCESS-GROUP BY-HAVING",
            "SELECT-FROM-PROCESS-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-PROCESS-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the date and the operating professional's first name of each treatment?, database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_",
        "prediction": "select t7.c13, t6.c2",
        "label": "select t7.c4, t7.c5, t6.c2",
        "score": false,
        "real_pred": "select Treatments.dog_id3, Professionals.first_name",
        "real_label": "select Treatments.date_of_treatment, Treatments.time_of_treatment, Professionals.first_name",
        "topk_preds": [
            "select Treatments.dog_id3, Professionals.first_name",
            "select Treatments.time_of_treatment, Professionals.first_name",
            "select Treatments.treatment_type_code, Professionals.first_name",
            "select Treatments.dog_id2, Professionals.first_name",
            "select Treatments.dog_id, Professionals.first_name",
            "select Treatments.dog_id4, Professionals.first_name",
            "select Treatments.dog_id5, Professionals.first_name",
            "select Treatments.professional_id3, Professionals.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the date and the operating professional's first name of each treatment?, database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, ",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Sizes Professionals Treatments",
            "Charges Professionals Treatments",
            "Breeds Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of the dogs of the rarest breed and the treatment dates of them., database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of the dogs of the rarest breed and the treatment dates of them., database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3",
        "prediction": "select t5.c5, t7.c3",
        "label": "select t5.c5, t7.c4, t7.c5",
        "score": false,
        "real_pred": "select Dogs.name, Treatments.treatment_type_code",
        "real_label": "select Dogs.name, Treatments.date_of_treatment, Treatments.time_of_treatment",
        "topk_preds": [
            "select Dogs.name, Treatments.treatment_type_code",
            "select Dogs.name, Treatments.dog_id3",
            "select Dogs.name, Treatments.dog_id2",
            "select Dogs.name, Treatments.treatment_type_code0",
            "select Dogs.name, Treatments.dog_id",
            "select Dogs.name, Treatments.professional_id",
            "select Dogs.name, Treatments.date_of_treatment",
            "select Dogs.name, Treatments.time_of_treatment"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of the dogs of the rarest breed and the treatment dates of them., database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Breeds Dogs Treatments",
            "Sizes Dogs Treatments",
            "Charges Dogs Treatments",
            "Treatment_Types Dogs Treatments",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which dogs are of the rarest breed? Show their names and treatment dates., database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which dogs are of the rarest breed? Show their names and treatment dates., database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment",
        "prediction": "select t5.c5, t7.c3",
        "label": "select t5.c5, t7.c4, t7.c5",
        "score": false,
        "real_pred": "select Dogs.name, Treatments.treatment_type_code",
        "real_label": "select Dogs.name, Treatments.date_of_treatment, Treatments.time_of_treatment",
        "topk_preds": [
            "select Dogs.name, Treatments.treatment_type_code",
            "select Dogs.name, t07.c3",
            "select Dogs.name, Dogs.breed_code",
            "select Dogs.name, t7.5.c3",
            "select Dogs.name, t 7.c3",
            "select Dogs.name, Treatments.professional_id",
            "select Dogs.name, Treatments.treatment_type_code,",
            "select Dogs.name, t7.0.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which dogs are of the rarest breed? Show their names and treatment dates., database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code,",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Breeds Dogs Treatments",
            "Breeds Charges Dogs Treatments",
            "Charges Dogs Treatments",
            "Treatment_Types Dogs Treatments",
            "Sizes Dogs Treatments",
            "Breeds Charges Sizes Dogs Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the arriving date and the departing date of the dogs who have gone through a treatment?, database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM (t5.c0 - t5.c10) - SELECT-FROM",
            "SELECT-FROM (t5.c0 - t5.c10), SELECT-FROM",
            "SELECT-FROM (t5.c10), SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM (t5.c0 - t5.c16",
            "SELECT-FROM (t5.c0 - t5.c10)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the arriving date and the departing date of the dogs who have gone through a treatment?, database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, ",
        "prediction": "select t5.c10, t5.c16",
        "label": "select distinct t5.c10, t5.c11, t5.c16",
        "score": false,
        "real_pred": "select Dogs.date_arrived, Dogs.date_departed",
        "real_label": "select distinct Dogs.date_arrived, Dogs.time_arrived, Dogs.date_departed",
        "topk_preds": [
            "select Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.date_departed",
            "select Dogs.weight, Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.owner_id, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.age",
            "select Dogs.weight, Dogs.date_departed",
            "select Dogs.owner_id, Dogs.abandoned_yn",
            "select Dogs.date_arrived, Dogs.date_departed, Treatments.dog_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the arriving date and the departing date of the dogs who have gone through a treatment?, database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Dogs Professionals Treatments",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the arriving date and the departing date of the dogs that received a treatment., database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-ATTACH-SELECT-FROM",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the arriving date and the departing date of the dogs that received a treatment., database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3:",
        "prediction": "select t5.c10, t5.c16",
        "label": "select distinct t5.c10, t5.c11, t5.c16",
        "score": false,
        "real_pred": "select Dogs.date_arrived, Dogs.date_departed",
        "real_label": "select distinct Dogs.date_arrived, Dogs.time_arrived, Dogs.date_departed",
        "topk_preds": [
            "select Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.date_departed",
            "select Dogs.weight, Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.owner_id, Dogs.date_departed",
            "select distinct Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.weight, Dogs.date_departed",
            "select Dogs.owner_id, Dogs.abandoned_yn",
            "select Dogs.dog_id, Dogs.age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the arriving date and the departing date of the dogs that received a treatment., database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Dogs Professionals Treatments",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the arriving date and the departing date of all the dogs?, database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, ",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM (UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT.C10, SELECT.C16",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT.C10, SELECT-C16",
            "SELECT-FROM (*) SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the arriving date and the departing date of all the dogs?, database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type",
        "prediction": "select t5.c10, t5.c16",
        "label": "select t5.c10, t5.c11, t5.c16",
        "score": false,
        "real_pred": "select Dogs.date_arrived, Dogs.date_departed",
        "real_label": "select Dogs.date_arrived, Dogs.time_arrived, Dogs.date_departed",
        "topk_preds": [
            "select Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.date_departed",
            "select Dogs.weight, Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.owner_id, Dogs.abandoned_yn",
            "select Dogs.owner_id, Dogs.date_departed",
            "select Dogs.weight, Dogs.date_departed",
            "select Dogs.date_arrived, Dogs.date_departed, Dogs.dog_id",
            "select Dogs.dog_id, Dogs.age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the arriving date and the departing date of all the dogs?, database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the arrival date and the departure date for all the dogs., database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT.C10, SELECT.C16",
            "SELECT-FROM (UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY",
            "SELECT.C10, SELECT-C16"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the arrival date and the departure date for all the dogs., database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code",
        "prediction": "select t5.c10, t5.c16",
        "label": "select t5.c10, t5.c11, t5.c16",
        "score": false,
        "real_pred": "select Dogs.date_arrived, Dogs.date_departed",
        "real_label": "select Dogs.date_arrived, Dogs.time_arrived, Dogs.date_departed",
        "topk_preds": [
            "select Dogs.date_arrived, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.date_departed",
            "select Dogs.owner_id, Dogs.abandoned_yn",
            "select Dogs.weight, Dogs.date_departed",
            "select Dogs.dog_id, Dogs.age",
            "select Dogs.weight, Dogs.date_arrived",
            "select Dogs.dog_id, Dogs.owner_id",
            "select Dogs.owner_id, Dogs.date_departed"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the arrival date and the departure date for all the dogs., database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4:",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How much does the most recent treatment cost?, database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How much does the most recent treatment cost?, database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4",
        "prediction": "select t1.c2",
        "label": "select t7.c6",
        "score": false,
        "real_pred": "select Charges.charge_amount",
        "real_label": "select Treatments.cost_of_treatment",
        "topk_preds": [
            "select Charges.charge_amount",
            "select Treatments.treatment_id, Charges.charge_amount",
            "select Treatments.time_of_treatment",
            "select t8.c0, Charges.charge_amount",
            "select Treatments.dog_id, Charges.charge_amount",
            "select Treatments.treatment_id, sum(Charges.charge_amount)",
            "select Treatments.time_of_treatment, Charges.charge_amount",
            "select Treatments.date_of_treatment"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How much does the most recent treatment cost?, database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_",
        "prediction": "t1 t7",
        "label": "t7",
        "score": false,
        "real_pred": "Charges Treatments",
        "real_label": "Treatments",
        "topk_preds": [
            "Charges Treatments",
            "Breeds Charges Treatments",
            "",
            "Charges",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the cost of the most recently performed treatment., database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the cost of the most recently performed treatment., database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, ",
        "prediction": "select t1.c2",
        "label": "select t7.c6",
        "score": false,
        "real_pred": "select Charges.charge_amount",
        "real_label": "select Treatments.cost_of_treatment",
        "topk_preds": [
            "select Charges.charge_amount",
            "select Treatments.treatment_id, Charges.charge_amount",
            "select Treatments.dog_id, Charges.charge_amount",
            "select Treatments.time_of_treatment, Charges.charge_amount",
            "select Charges.charge_id, Charges.charge_amount",
            "select t7.c9, Charges.charge_amount",
            "select Charges.charge_type, Charges.charge_amount",
            "select Treatments.time_of_treatment, Treatments.cost_of_treatment"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the cost of the most recently performed treatment., database: Database: dog_kennels_5. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: time_arrived, c12: year_adopted, c13: month_adopted, c14: day_adopted, c15: time_adopted, c16: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_",
        "prediction": "t1 t7",
        "label": "t7",
        "score": false,
        "real_pred": "Charges Treatments",
        "real_label": "Treatments",
        "topk_preds": [
            "Charges Treatments",
            "Breeds Charges Treatments",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the name of singers in ascending order of net worth., database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t0.c1), SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-ORDER BY (t0.c1) - SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t0.c1), t0.c2",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the name of singers in ascending order of net worth., database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name",
        "real_label": "select singer.first_name, singer.last_name",
        "topk_preds": [
            "select singer.first_name, singer.last_name",
            "select singer.Singer_ID, singer.first_name, singer.last_name",
            "select singer.first_name, singer.last_name, singer.Net_Worth_Millions",
            "select singer.first_name.c1, singer.last_name",
            "select t0.c 1, singer.last_name",
            "select singer.first_name, singer.last_name in singer.Net_Worth_Millions",
            "select singer.first_name, singer.last_name, singer.age",
            "select singer.first_name, singer.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the name of singers in ascending order of net worth., database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of singers ordered by ascending net worth?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t0.c1), SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-ORDER BY (t0.c1), t0.c2",
            "SELECT-FROM-ORDER BY (t0.c1), SELECT-FROM-ORDER BY (t0.c2)",
            "SELECT-FROM-ORDER BY (t0.c1), TL-CHECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t0.c1), SLECT-FROM-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of singers ordered by ascending net worth?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name",
        "real_label": "select singer.first_name, singer.last_name",
        "topk_preds": [
            "select singer.first_name, singer.last_name",
            "select singer.Singer_ID, singer.first_name, singer.last_name",
            "select singer.first_name, singer.last_name, singer.Net_Worth_Millions",
            "select singer.first_name.c1, singer.last_name",
            "select order(singer.first_name), singer.last_name",
            "select t0.c 1, singer.last_name",
            "select singesinger.first_name, singer.last_name",
            "select singer.first_name, singer.last_name, singer.age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of singers ordered by ascending net worth?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the name of singers whose citizenship is not \"France\"., database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the name of singers whose citizenship is not \"France\"., database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name",
        "real_label": "select singer.first_name, singer.last_name",
        "topk_preds": [
            "select singer.first_name, singer.last_name",
            "select singer.Singer_ID, singer.first_name, singer.last_name",
            "select singer.first_name, singer.last_name, singer.Citizenship",
            "select singer.first_name.c1, singer.last_name",
            "select distinct singer.first_name, singer.last_name",
            "select singer.first_name, singer.last_name, singer.age",
            "select singer.first_name., singer.last_name",
            "select t0.c 1, singer.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the name of singers whose citizenship is not \"France\"., database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the singers who are not French citizens?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the singers who are not French citizens?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name",
        "real_label": "select singer.first_name, singer.last_name",
        "topk_preds": [
            "select singer.first_name, singer.last_name",
            "select distinct singer.first_name, singer.last_name",
            "select singer.Singer_ID, singer.first_name, singer.last_name",
            "select singer.first_name, singer.last_name, singer.Citizenship",
            "select singer.first_name.c1, singer.last_name",
            "select singer.first_name., singer.last_name",
            "select t0.c 1, singer.last_name",
            "select singer.first_name, singer.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the singers who are not French citizens?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the singer with the largest net worth?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the singer with the largest net worth?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name",
        "real_label": "select singer.first_name, singer.last_name",
        "topk_preds": [
            "select singer.first_name, singer.last_name",
            "select singer.Singer_ID, singer.first_name, singer.last_name",
            "select singer.first_name, singer.last_name, singer.Net_Worth_Millions",
            "select singer.first_name.c1, singer.last_name",
            "select t0.c 1, singer.last_name",
            "select singer.last_name, singer.first_name",
            "select singer.first_name, singer.last_name, singer.age",
            "select singer.first_name, singer.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the singer with the largest net worth?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the singer who is worth the most?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the singer who is worth the most?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name",
        "real_label": "select singer.first_name, singer.last_name",
        "topk_preds": [
            "select singer.first_name, singer.last_name",
            "select singer.Singer_ID, singer.first_name, singer.last_name",
            "select singer.first_name, singer.last_name, singer.Net_Worth_Millions",
            "select singer.first_name.c1, singer.last_name",
            "select t0.c 1, singer.last_name",
            "select singer.last_name, singer.first_name",
            "select singer.first_name, singer.last_name",
            "select singer.first_name), singer.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the singer who is worth the most?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show titles of songs and names of singers., database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM INTERSECT-SELECT-FROM",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM-INTERSECT-SELECT-FROM",
            "SELECT-FROM (UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show titles of songs and names of singers., database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t1.c1, t0.c1, t0.c2",
        "label": "select t1.c1, t0.c1, t0.c2",
        "score": true,
        "real_pred": "select song.Title, singer.first_name, singer.last_name",
        "real_label": "select song.Title, singer.first_name, singer.last_name",
        "topk_preds": [
            "select song.Title, singer.first_name, singer.last_name",
            "select song.Title, singer.last_name",
            "select song.Title, singer.first_name",
            "select song.Title, t0.c 1, singer.last_name",
            "select song.Title, singer.first_name, singer.last_name",
            "select song.Title, singer.age, singer.last_name",
            "select song.Title, t 0.c1, singer.last_name",
            "select song.Title, singer.first_name& singer.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show titles of songs and names of singers., database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the song titles and singer names?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM (UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the song titles and singer names?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t1.c1, t0.c1, t0.c2",
        "label": "select t1.c1, t0.c1, t0.c2",
        "score": true,
        "real_pred": "select song.Title, singer.first_name, singer.last_name",
        "real_label": "select song.Title, singer.first_name, singer.last_name",
        "topk_preds": [
            "select song.Title, singer.first_name, singer.last_name",
            "select song.Title, singer.last_name",
            "select song.Title, singer.first_name",
            "select song.Title, singer.age, singer.last_name",
            "select song.Title, t0.c 1, singer.last_name",
            "select song.Title, singer.first_name, singer.last_name",
            "select song.Title, singer.first_name& singer.last_name",
            "select song.Title, singer.first_name & singer.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the song titles and singer names?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show distinct names of singers that have songs with sales more than 300000., database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DIFFERENT",
            "SELECT-FROM-WHERE-SEPARATE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show distinct names of singers that have songs with sales more than 300000., database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select distinct t0.c1, t0.c2",
        "label": "select distinct t0.c1, t0.c2",
        "score": true,
        "real_pred": "select distinct singer.first_name, singer.last_name",
        "real_label": "select distinct singer.first_name, singer.last_name",
        "topk_preds": [
            "select distinct singer.first_name, singer.last_name",
            "select singer.first_name, singer.last_name",
            "select distinct t2.c1, singer.last_name",
            "select distinct t.0.c1, singer.last_name",
            "select distinct t3.c1, singer.last_name",
            "select distinct singer.first_name., singer.last_name",
            "select distinct t 0.c1, singer.last_name",
            "select distinct singer.first_name, singer.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show distinct names of singers that have songs with sales more than 300000., database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: what are the different names of the singers that have sales more than 300000?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: what are the different names of the singers that have sales more than 300000?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select distinct t0.c1, t0.c2",
        "label": "select distinct t0.c1, t0.c2",
        "score": true,
        "real_pred": "select distinct singer.first_name, singer.last_name",
        "real_label": "select distinct singer.first_name, singer.last_name",
        "topk_preds": [
            "select distinct singer.first_name, singer.last_name",
            "select distinct singer.first_name.c1, singer.last_name",
            "select count(distinct singer.first_name), singer.last_name",
            "select distinct singer.first_name, singer.last_name, singer.age",
            "select distinct singer.first_name, singer.last_name, singer.Singer_ID",
            "select different singer.first_name, singer.last_name",
            "select distinctive singer.first_name, singer.last_name",
            "select distinct singer.first_name., singer.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: what are the different names of the singers that have sales more than 300000?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of singers that have more than one song., database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of singers that have more than one song., database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name",
        "real_label": "select singer.first_name, singer.last_name",
        "topk_preds": [
            "select singer.first_name, singer.last_name",
            "select singer.first_name, singer.last_name, singer.Singer_ID",
            "select singer.first_name.c1, singer.last_name",
            "select singer.first_name, singer.last_name, singer.age",
            "select song.Title, singer.last_name",
            "select t 0.c1, singer.last_name",
            "select t.c1, singer.last_name",
            "select t0-c1, singer.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of singers that have more than one song., database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the singers that have more than one songs?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the singers that have more than one songs?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name",
        "real_label": "select singer.first_name, singer.last_name",
        "topk_preds": [
            "select singer.first_name, singer.last_name",
            "select singer.first_name, singer.last_name, singer.Singer_ID",
            "select singer.first_name, singer.last_name, singer.age",
            "select t 0.c1, singer.last_name",
            "select song.Title, singer.last_name",
            "select t.c1, singer.last_name",
            "select t3.c1, singer.last_name",
            "select t2.c1, singer.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the singers that have more than one songs?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of singers and the total sales of their songs., database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY t1.c2, sum(t1.c3)",
            "SELECT-FROM-GROUP BY TI1.C2, sum(t1.c3)",
            "SELECT-FROM-GROUP BY TI1.c2, sum(t1.c3)",
            "SELECT-FROM-GROUP BY (ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of singers and the total sales of their songs., database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2, sum(t1.c3)",
        "label": "select t0.c1, t0.c2, sum(t1.c3)",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name, sum(song.Sales)",
        "real_label": "select singer.first_name, singer.last_name, sum(song.Sales)",
        "topk_preds": [
            "select singer.first_name, singer.last_name, sum(song.Sales)",
            "select song.Singer_ID, sum(song.Sales)",
            "select t2.c2, sum(song.Sales)",
            "select t.c1, singer.last_name, sum(song.Sales)",
            "select t4.c1, singer.last_name, sum(song.Sales)",
            "select singer.first_name, singer.last_name, sum(song.Sales), song.Singer_ID",
            "select t3.c2, sum(song.Sales)",
            "select t10.c1, singer.last_name, sum(song.Sales)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of singers and the total sales of their songs., database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For each singer name, what is the total sales for their songs?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY (ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-GIG-GROUP BY",
            "SELECT-FROM-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For each singer name, what is the total sales for their songs?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2, sum(t1.c3)",
        "label": "select t0.c1, t0.c2, sum(t1.c3)",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name, sum(song.Sales)",
        "real_label": "select singer.first_name, singer.last_name, sum(song.Sales)",
        "topk_preds": [
            "select singer.first_name, singer.last_name, sum(song.Sales)",
            "select singer.first_name, singer.last_name sum(song.Sales)",
            "select sum(song.Sales), singer.first_name, singer.last_name",
            "select singer.first_name, singer.last_name, sum(song.Sales)",
            "select song.Singer_ID, sum(song.Sales)",
            "select t 0.c1, singer.last_name, sum(song.Sales)",
            "select singer.first_name, singer.last_name + sum(song.Sales)",
            "select singer.first_name, singer.last_name and sum(song.Sales)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For each singer name, what is the total sales for their songs?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the name of singers that do not have any song., database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the name of singers that do not have any song., database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name",
        "real_label": "select singer.first_name, singer.last_name",
        "topk_preds": [
            "select singer.first_name, singer.last_name",
            "select singer.Singer_ID, singer.first_name, singer.last_name",
            "select singer.first_name, singer.last_name, singer.age",
            "select singer.first_name.c1, singer.last_name",
            "select singer.first_name, singer.last_name, singer.Singer_ID",
            "select t0.c 1, singer.last_name",
            "select singer.first_name, singer.last_name",
            "select singer.first_name, singer.last_name, singer.age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the name of singers that do not have any song., database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            "singer song"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the sname of every sing that does not have any song?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the sname of every sing that does not have any song?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select singer.first_name, singer.last_name",
        "real_label": "select singer.first_name, singer.last_name",
        "topk_preds": [
            "select singer.first_name, singer.last_name",
            "select singer.Singer_ID, singer.first_name, singer.last_name",
            "select singer.first_name, singer.last_name, singer.Singer_ID",
            "select singer.first_name.c1, singer.last_name",
            "select singer.first_name, singer.last_name, singer.age",
            "select t0.c 1, singer.last_name",
            "select singer.last_name, singer.first_name",
            "select t0-c1, t0-c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the sname of every sing that does not have any song?, database: Database: singer_0. t0: singer(c0: singer_id, c1: first_name, c2: last_name, c3: age, c4: net_worth_millions, c5: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "singer song",
            ""
        ]
    }
]