[
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all song names by singers below the average age., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all song names by singers below the average age., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select singer.Song_Name",
        "real_label": "select singer.Song_Name",
        "topk_preds": [
            "select singer.Song_Name",
            "select singer.Song_Name, singer.Age",
            "select singer.Song_Name, singer.Song_release_year",
            "select singer.Song_Name, singer.Is_male",
            "select singer.Song_Name, singer.Country",
            "select singer.Song_Name, t1.c7",
            "select singer.Song_Name (singer.Song_release_year)",
            "select singer.Song_Name del.icio.us"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all song names by singers below the average age., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "singer singer_in_concert",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are all the song names by singers who are younger than average?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are all the song names by singers who are younger than average?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select singer.Song_Name",
        "real_label": "select singer.Song_Name",
        "topk_preds": [
            "select singer.Song_Name",
            "select singer.Song_Name, singer.Is_male",
            "select singer.Song_Name, singer.Age",
            "select singer.Song_Name, singer.Song_release_year",
            "select singer.Song_Name, singer.Country",
            "select singer.Song_Name, t1.c7",
            "select singer.Song_Name (singer.Song_release_year)",
            "select singer.Song_Name - singer.Is_male"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are all the song names by singers who are younger than average?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the number of pets whose weight is lighter than 10., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE NUM(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the number of pets whose weight is lighter than 10., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Pets.PetID",
            "select count(*), Pets.PetID",
            "select count(*), Pets.PetType",
            "select count(*), database: Pets.PetID",
            "select count(*), Pets.weight",
            "select count(*), http://Pets.PetID",
            "select count(*) the Pets.PetID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the number of pets whose weight is lighter than 10., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the first name and gender of student who have at least one pet., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM",
            "SELECT-FROM-WITH-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the first name and gender of student who have at least one pet., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select distinct t0.c2, t0.c4",
        "label": "select t0.c2, t0.c4",
        "score": false,
        "real_pred": "select distinct Student.Fname, Student.Sex",
        "real_label": "select Student.Fname, Student.Sex",
        "topk_preds": [
            "select distinct Student.Fname, Student.Sex",
            "select Student.Fname, Student.Sex",
            "select distinct Student.LName, Student.Sex",
            "select unique Student.Fname, Student.Sex",
            "select distinct Student.Sex, Student.Fname",
            "select distinctive Student.Fname, Student.Sex",
            "select distinct Student.Fname), Student.Sex",
            "select distinct Student.Fname, Student.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the first name and gender of student who have at least one pet., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Student Has_Pet",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet",
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "",
            "",
            "Student Pets"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the first name and gender of student who have at most one pet., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTRUCT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the first name and gender of student who have at most one pet., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t0.c2, t0.c4",
        "label": "select t0.c2, t0.c4",
        "score": true,
        "real_pred": "select Student.Fname, Student.Sex",
        "real_label": "select Student.Fname, Student.Sex",
        "topk_preds": [
            "select Student.Fname, Student.Sex",
            "select Student.StuID, Student.Fname, Student.Sex",
            "select distinct Student.Fname, Student.Sex",
            "select Student.LName, Student.Sex",
            "select Student.Sex, Student.Fname",
            "select Student.Fname, Student.Age, Student.Sex",
            "select min(Student.Fname), min(Student.Sex)",
            "select Student.Fname.c2, Student.Sex"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the first name and gender of student who have at most one pet., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Student Has_Pet",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet",
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "",
            "",
            "Student Pets"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the first name and gender of the all the students who have at least one pet?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-INTERSECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the first name and gender of the all the students who have at least one pet?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select distinct t0.c2, t0.c4",
        "label": "select t0.c2, t0.c4",
        "score": false,
        "real_pred": "select distinct Student.Fname, Student.Sex",
        "real_label": "select Student.Fname, Student.Sex",
        "topk_preds": [
            "select distinct Student.Fname, Student.Sex",
            "select Student.Fname, Student.Sex",
            "select distinct Student.Fname, Student.Age, Student.Sex",
            "select distinct Student.LName, Student.Sex",
            "select unique Student.Fname, Student.Sex",
            "select distinct Student.Sex, Student.Fname",
            "select distinct Student.Fname, Student.Sex, Student.StuID",
            "select distinctive Student.Fname, Student.Sex"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the first name and gender of the all the students who have at least one pet?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Student Has_Pet",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet",
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "",
            "",
            "Student Pets"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the first name and gender of the all the students who have at most one pet?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTENT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INT-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the first name and gender of the all the students who have at most one pet?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t0.c2, t0.c4",
        "label": "select t0.c2, t0.c4",
        "score": true,
        "real_pred": "select Student.Fname, Student.Sex",
        "real_label": "select Student.Fname, Student.Sex",
        "topk_preds": [
            "select Student.Fname, Student.Sex",
            "select distinct Student.Fname, Student.Sex",
            "select Student.StuID, Student.Fname, Student.Sex",
            "select Student.LName, Student.Sex",
            "select Student.Fname, Student.Age, Student.Sex",
            "select Student.Sex, Student.Fname",
            "select Student.Fname.c2, Student.Sex",
            "select Student.Fname, Student.Sex, min(t1.c3)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the first name and gender of the all the students who have at most one pet?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Student Has_Pet",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            "Student Pets",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the model of the car whose weight is over the average weight., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the model of the car whose weight is over the average weight., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c2",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select model_list.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select model_list.Model",
            "select car_names.Model",
            "select model_list.ModelId, model_list.Model",
            "select model_list.Model, car_names.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, model_list.Model",
            "select model_list.Maker",
            "select car_names.Model, t4.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the model of the car whose weight is over the average weight., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list car_names cars_data",
            "car_makers model_list car_names cars_data",
            "continents model_list car_names cars_data",
            "car_names cars_data",
            "countries car_names cars_data",
            "",
            "model_list cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the model for the car with a weight larger than the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING)",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the model for the car with a weight larger than the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c2",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select model_list.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select model_list.Model",
            "select model_list.ModelId, model_list.Model",
            "select model_list.Model, car_names.Model",
            "select car_names.Model",
            "select model_list.Model (or car_names.Model)",
            "select model_list.Model (car_names.Model)",
            "select model_list.Model (or model_list.Model)",
            "select model_list.ModelId, model_list.Maker"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the model for the car with a weight larger than the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list cars_data",
            "model_list car_names cars_data",
            "car_makers model_list cars_data",
            "countries car_names cars_data",
            "car_names cars_data",
            "car_makers model_list car_names cars_data",
            "continents model_list car_names cars_data",
            "car_makers car_names cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the model for the car with a weight at least the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the model for the car with a weight at least the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c2",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select model_list.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select model_list.Model",
            "select car_names.Model",
            "select model_list.ModelId, model_list.Model",
            "select model_list.Model, car_names.Model",
            "select car_names.Model, model_list.Model",
            "select car_names.Model, car_names.Make",
            "select model_list.Model (or car_names.Model)",
            "select model_list.Model (car_names.Model)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the model for the car with a weight at least the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list car_names cars_data",
            "model_list cars_data",
            "car_names cars_data",
            "car_makers model_list cars_data",
            "countries car_names cars_data",
            "car_makers model_list car_names cars_data",
            "car_makers car_names cars_data",
            "continents car_names cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which distinct car models are the produced before 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which distinct car models are the produced before 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select distinct t4.c1",
        "label": "select distinct t3.c2",
        "score": false,
        "real_pred": "select distinct car_names.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select distinct car_names.Model",
            "select distinct car_names.Model, car_names.Make",
            "select distinct model_list.Model",
            "select distinct car_names.Model",
            "select distinct car_names.Model, model_list.Model",
            "select distinct car_names.Model, t4.c3",
            "select distinct car_names.Model, car_names.MakeId",
            "select distinct car_names.Model, t4.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which distinct car models are the produced before 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4",
        "label": "t3 t4 t5",
        "score": false,
        "real_pred": "model_list car_names",
        "real_label": "model_list car_names cars_data",
        "topk_preds": [
            "model_list car_names",
            "car_names",
            "car_makers model_list car_names",
            "car_makers car_names",
            "countries car_names",
            "",
            "",
            "model_list car_names cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the different models for the cards produced before 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-DIFFERENT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the different models for the cards produced before 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select distinct t3.c2",
        "label": "select distinct t3.c2",
        "score": true,
        "real_pred": "select distinct model_list.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select distinct model_list.Model",
            "select distinct model_list.Model, model_list.ModelId",
            "select distinct model_list.Model, t3.c3",
            "select distinct model_list.Model, model_list.Maker",
            "select distinct model_list.Model.c2",
            "select distinct model_list.Model",
            "select distinct model_list.Model (model_list.ModelId)",
            "select different model_list.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the different models for the cards produced before 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t5",
        "label": "t3 t4 t5",
        "score": false,
        "real_pred": "model_list cars_data",
        "real_label": "model_list car_names cars_data",
        "topk_preds": [
            "model_list cars_data",
            "",
            "model_list car_names",
            "",
            "",
            "",
            "model_list",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the countries having more than one car maker? List name and id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the countries having more than one car maker? List name and id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1, t1.c0",
        "label": "select t1.c1, t1.c0",
        "score": true,
        "real_pred": "select countries.CountryName, countries.CountryId",
        "real_label": "select countries.CountryName, countries.CountryId",
        "topk_preds": [
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, car_makers.Id",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, car_makers.FullName",
            "select countries.CountryName, car_makers.Id3",
            "select countries.CountryName, car_makers.Maker",
            "select countries.CountryName, t01.c0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the countries having more than one car maker? List name and id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the countries having at most one car maker? List name and id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the countries having at most one car maker? List name and id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1, t1.c0",
        "label": "select t1.c1, t1.c0",
        "score": true,
        "real_pred": "select countries.CountryName, countries.CountryId",
        "real_label": "select countries.CountryName, countries.CountryId",
        "topk_preds": [
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, car_makers.Id",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, t1c0",
            "select countries.CountryName, t01.c0",
            "select countries.CountryName, t.c0",
            "select countries.CountryName, car_names.MakeId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the countries having at most one car maker? List name and id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names and ids of all countries with more than one car maker?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAGLE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names and ids of all countries with more than one car maker?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1, t1.c0",
        "label": "select t1.c1, t1.c0",
        "score": true,
        "real_pred": "select countries.CountryName, countries.CountryId",
        "real_label": "select countries.CountryName, countries.CountryId",
        "topk_preds": [
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, car_makers.Id",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, t01.c0",
            "select countries.CountryName., countries.CountryId",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, countries.CountryId0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names and ids of all countries with more than one car maker?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names and ids of all countries with at most one car maker?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names and ids of all countries with at most one car maker?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1, t1.c0",
        "label": "select t1.c1, t1.c0",
        "score": true,
        "real_pred": "select countries.CountryName, countries.CountryId",
        "real_label": "select countries.CountryName, countries.CountryId",
        "topk_preds": [
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, car_makers.Id",
            "select countries.CountryName, t01.c0",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, t1c0",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, countries.CountryId0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names and ids of all countries with at most one car maker?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of the cars with horsepower less than 150?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE -GROUP BY",
            "SELECT-FROM-WHERE - GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of the cars with horsepower less than 150?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.MPG, cars_data.Cylinders",
            "select count(*), cars_data.Id, cars_data.MPG",
            "select count(*) dependant on cars_data.Id",
            "select count(*), t5.dcars_data.Id",
            "select count(*) (cars_data.Id)",
            "select count(*), cars_data.MPG"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of the cars with horsepower less than 150?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "model_list cars_data",
            "",
            "",
            "car_makers cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of the cars with horsepower at least 150?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE -GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE_GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE - GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of the cars with horsepower at least 150?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.MPG, cars_data.Cylinders",
            "select count(*), cars_data.Id, cars_data.MPG",
            "select count(*) (cars_data.Id)",
            "select count(*), cars_data.Id, cars_data.Horsepower",
            "select count(*), cars_data.Id, cars_data.Edispl"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of the cars with horsepower at least 150?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "car_names cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of the cars with horsepower at most 150?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE -GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE_GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY at-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of the cars with horsepower at most 150?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.MPG, cars_data.Cylinders",
            "select count(*), cars_data.Id, cars_data.MPG",
            "select count(*) (cars_data.Id)",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.Id, cars_data.Edispl",
            "select count(*), t5.datum(cars_data.Id)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of the cars with horsepower at most 150?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "model_list cars_data",
            "",
            "car_makers cars_data",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of cars with a horsepower less than 150?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of cars with a horsepower less than 150?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.MPG",
            "select count(*) dependant on cars_data.Id",
            "select count(*) (cars_data.Id)",
            "select count(*), cars_data.Horsepower",
            "select count(*) dependant on cars_data.Horsepower",
            "select count(*),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of cars with a horsepower less than 150?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of cars with a horsepower at least 150?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE_GROUP BY-HAVING",
            "SELECT-FROM-WHERE_GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of cars with a horsepower at least 150?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), t5.dcars_data.Id",
            "select count(*) (cars_data.Id)",
            "select count(*) dependant on cars_data.Id",
            "select count(*), cars_data.MPG",
            "select count(*), t5.datum",
            "select count(*),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of cars with a horsepower at least 150?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of cars with a horsepower at most 150?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE_GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY max(t5.c4)",
            "SELECT-FROM-WHERE -GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of cars with a horsepower at most 150?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.MPG, cars_data.Cylinders",
            "select count(*), t5.datum(cars_data.Id)",
            "select count(*), cars_data.Id, cars_data.MPG",
            "select count(*) (cars_data.Id)",
            "select count(*), cars_data.Id, cars_data.Edispl",
            "select count(*), t5.datum(cars_data.Horsepower)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of cars with a horsepower at most 150?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "model_list cars_data",
            "car_makers cars_data",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which countries in europe have more than 3 car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GAGMENT-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which countries in europe have more than 3 car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, t0.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which countries in europe have more than 3 car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "",
            "",
            "countries car_makers",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which countries in europe have less than 3 car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GHOST-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GHOST-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which countries in europe have less than 3 car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, t0.c3",
            "select countries.CountryId, countries.CountryName",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, t0.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which countries in europe have less than 3 car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which countries in europe have at most 3 car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GHOST-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-CG-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which countries in europe have at most 3 car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, max(car_makers.Maker)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which countries in europe have at most 3 car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of all European countries with more than 3 manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GHOST-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of all European countries with more than 3 manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName, t0.c4",
            "select countries.CountryName de, continents.ContId",
            "select countries.CountryName de, continents.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of all European countries with more than 3 manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "continents car_makers",
            "countries car_makers",
            "continents countries",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of all European countries with less than 3 manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-CONDITION-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-CONDITION-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of all European countries with less than 3 manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName (continents.ContId)",
            "select countries.CountryName, t0.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of all European countries with less than 3 manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "continents countries",
            "countries car_makers",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of all European countries with at most 3 manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAUSS-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GHOST-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ATTAIN-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of all European countries with at most 3 manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, car_makers.Maker",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName, car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of all European countries with at most 3 manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "continents car_makers",
            "continents countries",
            "countries car_makers",
            "",
            "",
            "",
            "continents countries car_makers model_list"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the average horsepower of the cars after 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-AGGRESS-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the average horsepower of the cars after 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c4)",
        "label": "select avg(t5.c4)",
        "score": true,
        "real_pred": "select avg(cars_data.Horsepower)",
        "real_label": "select avg(cars_data.Horsepower)",
        "topk_preds": [
            "select avg(cars_data.Horsepower)",
            "select avg(avg(cars_data.Horsepower)",
            "select an avg(cars_data.Horsepower)",
            "select avg(cars_data.Horsepower), cars_data.Year",
            "select  avg(cars_data.Horsepower)",
            "select avg(cars_data.Horsepower)",
            "select the avg(cars_data.Horsepower)",
            "select Avg(cars_data.Horsepower)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the average horsepower of the cars after 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "model_list cars_data",
            "car_names cars_data",
            "car_makers cars_data",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the average horsepower for all cars produced after 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (Avg(t5.c4)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the average horsepower for all cars produced after 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c4)",
        "label": "select avg(t5.c4)",
        "score": true,
        "real_pred": "select avg(cars_data.Horsepower)",
        "real_label": "select avg(cars_data.Horsepower)",
        "topk_preds": [
            "select avg(cars_data.Horsepower)",
            "select avg(avg(cars_data.Horsepower)",
            "select an avg(cars_data.Horsepower)",
            "select  avg(cars_data.Horsepower)",
            "select Avg(cars_data.Horsepower)",
            "select avg(cars_data.Horsepower)",
            "select the avg(cars_data.Horsepower)",
            "select avg(cars_data.Accelerate)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the average horsepower for all cars produced after 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "model_list cars_data",
            "car_names cars_data",
            "car_makers cars_data",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many cars have less than 4 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many cars have less than 4 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Cylinders",
            "select count(*), cars_data.Id",
            "select count(*) (cars_data.Id)",
            "select count(*), t5.dcars_data.Id",
            "select count(*), t5.dcars_data.Cylinders",
            "select count(*), cars_data.MPG",
            "select count(*), t5.dcars_data.MPG"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many cars have less than 4 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many cars have at least 4 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INSERT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many cars have at least 4 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.Cylinders",
            "select count(*) (cars_data.Id)",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.MPG",
            "select count(*), t5.dcars_data.Cylinders",
            "select count(*),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many cars have at least 4 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many cars have at most 4 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many cars have at most 4 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*) (cars_data.Id)",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.Cylinders",
            "select count(*), cars_data.MPG",
            "select count(*), t5.dcars_data.Cylinders",
            "select count(*),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many cars have at most 4 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of cars with less than 4 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE(count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of cars with less than 4 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Cylinders",
            "select count(*), cars_data.Id",
            "select count(*) (cars_data.Id)",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.MPG",
            "select count(*), t5.dcars_data.Cylinders",
            "select count(*), t5.dcars_data.MPG"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of cars with less than 4 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of cars with at least 4 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE_GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY HAVING",
            "SELECT-FROM-WHERE_GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of cars with at least 4 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.Cylinders",
            "select count(*), cars_data.MPG, cars_data.Cylinders",
            "select count(*) (cars_data.Id)",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.Id, cars_data.Cylinders",
            "select count(*), cars_data.MPG"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of cars with at least 4 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of cars with at most 4 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of cars with at most 4 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.MPG, cars_data.Cylinders",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.Id, cars_data.Cylinders",
            "select count(*) (cars_data.Id)",
            "select count(*), cars_data.Cylinders",
            "select count(*), t5.datum(cars_data.Id)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of cars with at most 4 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which makers designed less than 3 car models? List full name and the id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING, SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which makers designed less than 3 car models? List full name and the id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2, t2.c0",
        "label": "select t2.c2, t2.c0",
        "score": true,
        "real_pred": "select car_makers.FullName, car_makers.Id",
        "real_label": "select car_makers.FullName, car_makers.Id",
        "topk_preds": [
            "select car_makers.FullName, car_makers.Id",
            "select car_makers.Maker, car_makers.FullName, car_makers.Id",
            "select car_makers.FullName, model_list.Maker, model_list.ModelId",
            "select car_makers.FullName, car_names.Model, car_makers.Id",
            "select t2.c4, car_makers.FullName, car_makers.Id",
            "select car_makers.FullName, model_list.Maker, car_makers.Id",
            "select car_makers.FullName, model_list.Maker, car_names.MakeId",
            "select car_makers.Maker, car_makers.FullName, model_list.Maker"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which makers designed less than 3 car models? List full name and the id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t2 t3",
        "score": false,
        "real_pred": "car_makers model_list car_names",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "car_makers model_list car_names",
            "car_makers model_list",
            "",
            "",
            "",
            "",
            "countries model_list car_names",
            "car_makers car_names"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which makers designed at least 3 car models? List full name and the id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which makers designed at least 3 car models? List full name and the id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2, t2.c0",
        "label": "select t2.c2, t2.c0",
        "score": true,
        "real_pred": "select car_makers.FullName, car_makers.Id",
        "real_label": "select car_makers.FullName, car_makers.Id",
        "topk_preds": [
            "select car_makers.FullName, car_makers.Id",
            "select car_makers.Maker, car_makers.FullName, car_makers.Id",
            "select car_makers.FullName, model_list.Maker, model_list.ModelId",
            "select car_makers.FullName, car_names.Model, car_makers.Id",
            "select t2.c4, car_makers.FullName, car_makers.Id",
            "select car_makers.Maker, car_makers.FullName, model_list.ModelId",
            "select car_makers.Maker, car_makers.FullName, model_list.Maker",
            "select car_makers.FullName, model_list.Maker, car_names.MakeId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which makers designed at least 3 car models? List full name and the id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t2 t3",
        "score": false,
        "real_pred": "car_makers model_list car_names",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "car_makers model_list car_names",
            "countries car_makers model_list car_names",
            "",
            "",
            "car_makers model_list",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which makers designed at most 3 car models? List full name and the id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM gROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which makers designed at most 3 car models? List full name and the id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2, t2.c0",
        "label": "select t2.c2, t2.c0",
        "score": true,
        "real_pred": "select car_makers.FullName, car_makers.Id",
        "real_label": "select car_makers.FullName, car_makers.Id",
        "topk_preds": [
            "select car_makers.FullName, car_makers.Id",
            "select car_makers.Maker, car_makers.FullName, car_makers.Id",
            "select car_makers.FullName, model_list.Maker, model_list.ModelId",
            "select car_makers.FullName, car_names.Model, car_makers.Id",
            "select car_makers.Maker, car_makers.FullName, model_list.ModelId",
            "select car_makers.FullName, car_makers.Maker, model_list.ModelId",
            "select t2.c4, car_makers.FullName, car_makers.Id",
            "select car_makers.FullName, model_list.Maker, car_names.MakeId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which makers designed at most 3 car models? List full name and the id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t2 t3",
        "score": false,
        "real_pred": "car_makers model_list car_names",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "car_makers model_list car_names",
            "",
            "",
            "countries model_list car_names",
            "",
            "",
            "car_makers model_list",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names and ids of all makers with less than 3 models?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING DIRECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names and ids of all makers with less than 3 models?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2, t2.c0",
        "label": "select t2.c2, t2.c0",
        "score": true,
        "real_pred": "select car_makers.FullName, car_makers.Id",
        "real_label": "select car_makers.FullName, car_makers.Id",
        "topk_preds": [
            "select car_makers.FullName, car_makers.Id",
            "select car_makers.FullName, model_list.Maker",
            "select car_makers.FullName, model_list.ModelId",
            "select car_makers.Maker, model_list.ModelId",
            "select car_makers.Maker, model_list.Maker",
            "select car_makers.Maker, car_makers.Id",
            "select car_makers.FullName, car_names.Model",
            "select model_list.Maker, model_list.ModelId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names and ids of all makers with less than 3 models?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "car_makers model_list",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "car_makers model_list",
            "car_makers model_list car_names",
            "",
            "",
            "",
            "",
            "",
            "countries model_list car_names"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names and ids of all makers with at least 3 models?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING DIRECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names and ids of all makers with at least 3 models?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2, t2.c0",
        "label": "select t2.c2, t2.c0",
        "score": true,
        "real_pred": "select car_makers.FullName, car_makers.Id",
        "real_label": "select car_makers.FullName, car_makers.Id",
        "topk_preds": [
            "select car_makers.FullName, car_makers.Id",
            "select car_makers.FullName, model_list.Maker",
            "select car_makers.Maker, model_list.Maker",
            "select car_makers.Maker, car_makers.Id",
            "select car_makers.FullName, model_list.ModelId",
            "select car_makers.Maker, model_list.ModelId",
            "select car_makers.FullName, car_names.Model",
            "select model_list.Maker, car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names and ids of all makers with at least 3 models?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "car_makers model_list",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "car_makers model_list",
            "car_makers model_list car_names",
            "",
            "",
            "",
            "continents car_makers model_list car_names",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names and ids of all makers with at most 3 models?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROMGROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names and ids of all makers with at most 3 models?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2, t2.c0",
        "label": "select t2.c2, t2.c0",
        "score": true,
        "real_pred": "select car_makers.FullName, car_makers.Id",
        "real_label": "select car_makers.FullName, car_makers.Id",
        "topk_preds": [
            "select car_makers.FullName, car_makers.Id",
            "select car_makers.FullName, model_list.Maker",
            "select car_makers.Maker, model_list.ModelId",
            "select car_makers.FullName, model_list.ModelId",
            "select car_makers.Maker, car_makers.Id",
            "select car_makers.Maker, model_list.Maker",
            "select car_makers.FullName, model_list.Maker, model_list.ModelId",
            "select car_makers.FullName, car_names.Model, car_names.MakeId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names and ids of all makers with at most 3 models?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t2 t3",
        "score": false,
        "real_pred": "car_makers model_list car_names",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "car_makers model_list car_names",
            "car_makers model_list",
            "",
            "",
            "countries model_list car_names",
            "",
            "",
            "model_list car_names"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which distinctive models are produced by maker with the full name General Motors or weighing less than 3500?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which distinctive models are produced by maker with the full name General Motors or weighing less than 3500?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select distinct t3.c2",
        "label": "select distinct t3.c2",
        "score": true,
        "real_pred": "select distinct model_list.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select distinct model_list.Model",
            "select distinct model_list.Model, car_makers.Maker",
            "select distinct model_list.Model-list(distinct model_list.Model)",
            "select distinctive model_list.Model",
            "select distinct model_list.Model, model_list.Maker",
            "select distinct model_list.Model.c2",
            "select distinct model_list.Model",
            "select distinct model_list.Model, car_makers.Id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which distinctive models are produced by maker with the full name General Motors or weighing less than 3500?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers model_list cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers model_list cars_data",
            "car_makers model_list car_names",
            "car_makers model_list car_makers cars_data",
            "countries car_makers model_list cars_data",
            "countries car_makers model_list car_names",
            "car_makers model_list car_makers car_names",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which distinctive models are produced by maker with the full name General Motors or weighing at most 3500?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which distinctive models are produced by maker with the full name General Motors or weighing at most 3500?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select distinct t3.c2",
        "label": "select distinct t3.c2",
        "score": true,
        "real_pred": "select distinct model_list.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select distinct model_list.Model",
            "select distinct model_list.Model, car_makers.Maker",
            "select distinctive model_list.Model",
            "select distinct model_list.Model, model_list.Maker",
            "select distinct model_list.Model-list(distinct model_list.Model)",
            "select distinct model_list.Model.c2",
            "select distinct model_list.Model",
            "select distinct model_list.Model, car_makers.Id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which distinctive models are produced by maker with the full name General Motors or weighing at most 3500?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers model_list car_names",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers model_list car_names",
            "car_makers model_list cars_data",
            "car_makers model_list car_makers cars_data",
            "countries car_makers model_list cars_data",
            "countries car_makers model_list car_names",
            "car_makers model_list car_makers model_list cars_data",
            "car_makers model_list car_makers car_names",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the different models created by either the car maker General Motors or weighed less than 3500?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM cars-WHERE",
            "SELECT-FROM-WHERE-UNITED-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the different models created by either the car maker General Motors or weighed less than 3500?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select distinct t3.c2",
        "label": "select distinct t3.c2",
        "score": true,
        "real_pred": "select distinct model_list.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select distinct model_list.Model",
            "select distinct model_list.Model, car_makers.Maker",
            "select count(distinct model_list.Model)",
            "select distinct model_list.Model, car_makers.Maker, cars_data.Weight",
            "select distinct model_list.Model, car_makers.Maker, t4.c5",
            "select distinct model_list.Model, car_makers.Maker, car_makers.FullName",
            "select distinct model_list.Model, car_makers.FullName",
            "select distinct model_list.Model.c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the different models created by either the car maker General Motors or weighed less than 3500?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers model_list cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers model_list cars_data",
            "car_makers model_list car_names",
            "car_makers model_list car_names cars_data",
            "countries car_makers model_list cars_data",
            "continents car_makers model_list cars_data",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the different models created by either the car maker General Motors or weighed at most 3500?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM cars-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the different models created by either the car maker General Motors or weighed at most 3500?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select distinct t3.c2",
        "label": "select distinct t3.c2",
        "score": true,
        "real_pred": "select distinct model_list.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select distinct model_list.Model",
            "select count(distinct model_list.Model)",
            "select distinct model_list.Model, car_makers.Maker",
            "select distinct model_list.Model.c2",
            "select distinct model_list.Model, model_list.Maker",
            "select model_list.Model",
            "select distinct model_list.Model",
            "select distinct model_list.Model, car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the different models created by either the car maker General Motors or weighed at most 3500?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers model_list cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers model_list cars_data",
            "car_makers model_list car_names",
            "countries car_makers model_list cars_data",
            "car_makers model_list car_makers cars_data",
            "countries car_makers model_list car_names",
            "car_makers model_list car_names cars_data",
            "car_makers model_list car_makers car_names",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many countries has less than 2 car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many countries has less than 2 car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), car_makers.Country",
            "select count(*), countries.CountryName",
            "select count(*), countries.CountryId",
            "select count(1, car_makers.Country)",
            "select count(countries.CountryName)",
            "select count(distinct countries.CountryName)",
            "select count(countries.CountryName, car_makers.Country)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many countries has less than 2 car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "countries car_makers model_list",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many countries has at least 2 car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many countries has at least 2 car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(distinct car_makers.Country)",
            "select count(distinct countries.CountryName)",
            "select count(*), countries.CountryName",
            "select count(countries.CountryName)",
            "select count(1, car_makers.Country)",
            "select count(*), car_makers.Country",
            "select count(*), countries.CountryId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many countries has at least 2 car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "countries car_makers model_list",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many countries has at most 2 car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-INSIST-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many countries has at most 2 car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), car_makers.Country",
            "select count(*), countries.CountryName",
            "select count(distinct countries.CountryName)",
            "select count(1, car_makers.Country)",
            "select count(countries.CountryName)",
            "select count(*), countries.CountryId",
            "select count(countries.CountryName, car_makers.Country)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many countries has at most 2 car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "countries car_makers model_list",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of countries with less than 2 car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WITH-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups by-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of countries with less than 2 car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), car_makers.Country",
            "select count(*), countries.CountryName",
            "select count(*), countries.CountryId",
            "select count(1, car_makers.Country)",
            "select count(countries.CountryName)",
            "select count(distinct countries.CountryName)",
            "select count(*),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of countries with less than 2 car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "countries car_makers model_list",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of countries with at least 2 car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups by-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of countries with at least 2 car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), car_makers.Country",
            "select count(*), countries.CountryName",
            "select count(distinct car_makers.Country)",
            "select count(1, car_makers.Country)",
            "select count(countries.CountryName)",
            "select count(*), countries.CountryId",
            "select count(distinct countries.CountryName)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of countries with at least 2 car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "car_makers",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of countries with at most 2 car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of countries with at most 2 car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), countries.CountryName",
            "select count(*), car_makers.Country",
            "select count(*), countries.CountryId",
            "select count(1, car_makers.Country)",
            "select count(countries.CountryName)",
            "select count(distinct countries.CountryName)",
            "select count(1, countries.CountryId)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of countries with at most 2 car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            "countries car_makers model_list"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many cars has below 6 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many cars has below 6 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Cylinders",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.Cylinders, cars_data.Edispl",
            "select count(*) (cars_data.Id)",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.MPG, cars_data.Cylinders",
            "select count(*), t5.dcars_data.Cylinders"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many cars has below 6 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of carsw ith below 6 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE -GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of carsw ith below 6 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Cylinders",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.Cylinders, cars_data.Edispl",
            "select count(*), cars_data.MPG, cars_data.Cylinders",
            "select count(*) (cars_data.Id)",
            "select count(*), cars_data.Id, cars_data.Cylinders",
            "select count(*), t5.dcars_data.Id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of carsw ith below 6 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which models are heavier than 3500 but not built by the 'Ford Motor Company'?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname (Ford Motor Company), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE,-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE.E-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHEREE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE but-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which models are heavier than 3500 but not built by the 'Ford Motor Company'?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname (Ford Motor Company), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c2",
        "label": "select distinct t3.c2",
        "score": false,
        "real_pred": "select model_list.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select model_list.Model",
            "select car_names.Make",
            "select car_names.Model",
            "select car_makers.Maker, car_makers.FullName",
            "select model_list.Maker",
            "select car_makers.Maker, model_list.Model",
            "select car_names.Model, car_makers.FullName",
            "select model_list.Model, car_makers.Maker"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which models are heavier than 3500 but not built by the 'Ford Motor Company'?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname (Ford Motor Company), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers model_list cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers model_list cars_data",
            "countries car_makers model_list cars_data",
            "continents car_makers model_list cars_data",
            "",
            "",
            "",
            "car_makers model_list",
            "car_makers car_names cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the different models wthat are heavier than 3500 but were not built by the Ford Motor Company?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname (Ford Motor Company), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE,-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE but-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE BUT-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2014EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE- EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the different models wthat are heavier than 3500 but were not built by the Ford Motor Company?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname (Ford Motor Company), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select distinct t3.c2",
        "label": "select distinct t3.c2",
        "score": true,
        "real_pred": "select distinct model_list.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select distinct model_list.Model",
            "select distinct car_names.Model",
            "select distinct car_names.Make",
            "select distinct car_makers.Maker, car_makers.FullName",
            "select distinct model_list.Model, car_makers.Maker",
            "select distinct model_list.Maker",
            "select distinct car_names.Model, car_makers.FullName",
            "select distinct car_makers.Maker, model_list.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the different models wthat are heavier than 3500 but were not built by the Ford Motor Company?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname (Ford Motor Company), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers model_list cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers model_list cars_data",
            "countries car_makers model_list cars_data",
            "continents car_makers model_list cars_data",
            "car_makers model_list car_names",
            "",
            "",
            "car_makers model_list",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the id and names of the countries which have less than 3 car makers or produce the 'fiat' model?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING or-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-2-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING OR-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING,-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING/UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the id and names of the countries which have less than 3 car makers or produce the 'fiat' model?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c0, t1.c1",
        "label": "select t1.c0, t1.c1",
        "score": true,
        "real_pred": "select countries.CountryId, countries.CountryName",
        "real_label": "select countries.CountryId, countries.CountryName",
        "topk_preds": [
            "select countries.CountryId, countries.CountryName",
            "select car_makers.Id, countries.CountryName",
            "select countries.CountryId, countries.CountryName, car_makers.Country",
            "select t1, car_makers.Id, countries.CountryName",
            "select countries.CountryId, countries.CountryName,",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryId, countries.CountryName,",
            "select countries.CountryId-, countries.CountryName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the id and names of the countries which have less than 3 car makers or produce the 'fiat' model?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2 t3 t4",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "countries car_makers model_list car_names",
        "real_label": "countries car_makers model_list",
        "topk_preds": [
            "countries car_makers model_list car_names",
            "countries car_makers model_list",
            "countries car_makers",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the id and names of the countries which have at least 3 car makers or produce the 'fiat' model?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING or-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GWHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING OR-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the id and names of the countries which have at least 3 car makers or produce the 'fiat' model?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c0, t1.c1",
        "label": "select t1.c0, t1.c1",
        "score": true,
        "real_pred": "select countries.CountryId, countries.CountryName",
        "real_label": "select countries.CountryId, countries.CountryName",
        "topk_preds": [
            "select countries.CountryId, countries.CountryName",
            "select car_makers.Id, countries.CountryName",
            "select countries.CountryId, countries.CountryName, car_makers.Country",
            "select car_names.Model, countries.CountryId, countries.CountryName",
            "select t1, car_makers.Id, countries.CountryName",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryId, countries.CountryName,",
            "select car_names.Model, countries.CountryId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the id and names of the countries which have at least 3 car makers or produce the 'fiat' model?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2 t3 t4",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "countries car_makers model_list car_names",
        "real_label": "countries car_makers model_list",
        "topk_preds": [
            "countries car_makers model_list car_names",
            "countries car_makers model_list",
            "countries car_makers car_names",
            "",
            "countries car_makers",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the id and names of the countries which have at most 3 car makers or produce the 'fiat' model?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING or-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING,-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING OR-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-WHERE",
            "SELECT-FROM-HAVING-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the id and names of the countries which have at most 3 car makers or produce the 'fiat' model?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c0, t1.c1",
        "label": "select t1.c0, t1.c1",
        "score": true,
        "real_pred": "select countries.CountryId, countries.CountryName",
        "real_label": "select countries.CountryId, countries.CountryName",
        "topk_preds": [
            "select countries.CountryId, countries.CountryName",
            "select car_makers.Id, countries.CountryName",
            "select car_names.Model, countries.CountryId, countries.CountryName",
            "select countries.CountryId, countries.CountryName, car_makers.Country",
            "select t1, car_makers.Id, countries.CountryName",
            "select countries.CountryId, countries.CountryName, min(car_makers.Maker)",
            "select countries.CountryId, countries.CountryName, min(car_makers.Id)",
            "select countries.CountryId, countries.CountryName, min(car_makers.Country)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the id and names of the countries which have at most 3 car makers or produce the 'fiat' model?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2 t3 t4",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "countries car_makers model_list car_names",
        "real_label": "countries car_makers model_list",
        "topk_preds": [
            "countries car_makers model_list car_names",
            "countries car_makers model_list",
            "countries car_makers",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the ids and names of all countries that either have less than 3 car makers or produce fiat model?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-HAVE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the ids and names of all countries that either have less than 3 car makers or produce fiat model?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c0, t1.c1",
        "label": "select t1.c0, t1.c1",
        "score": true,
        "real_pred": "select countries.CountryId, countries.CountryName",
        "real_label": "select countries.CountryId, countries.CountryName",
        "topk_preds": [
            "select countries.CountryId, countries.CountryName",
            "select car_makers.Id, countries.CountryName",
            "select car_names.Model, countries.CountryId, countries.CountryName",
            "select countries.CountryId, countries.CountryName, car_makers.Country",
            "select t1, car_makers.Id, countries.CountryName",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryId, countries.CountryName,",
            "select countries.CountryId, countries.CountryName, countries.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the ids and names of all countries that either have less than 3 car makers or produce fiat model?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2 t3 t4",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "countries car_makers model_list car_names",
        "real_label": "countries car_makers model_list",
        "topk_preds": [
            "countries car_makers model_list car_names",
            "countries car_makers model_list",
            "countries model_list car_names",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the ids and names of all countries that either have at least 3 car makers or produce fiat model?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-3-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-HAVE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the ids and names of all countries that either have at least 3 car makers or produce fiat model?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c0, t1.c1",
        "label": "select t1.c0, t1.c1",
        "score": true,
        "real_pred": "select countries.CountryId, countries.CountryName",
        "real_label": "select countries.CountryId, countries.CountryName",
        "topk_preds": [
            "select countries.CountryId, countries.CountryName",
            "select car_names.Model, countries.CountryId, countries.CountryName",
            "select car_makers.Id, countries.CountryName",
            "select countries.CountryId, countries.CountryName, car_makers.Country",
            "select t1, car_makers.Id, countries.CountryName",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryId, countries.CountryName,",
            "select countries.CountryId, countries.CountryName, countries.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the ids and names of all countries that either have at least 3 car makers or produce fiat model?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2 t3 t4",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "countries car_makers model_list car_names",
        "real_label": "countries car_makers model_list",
        "topk_preds": [
            "countries car_makers model_list car_names",
            "countries car_makers model_list",
            "",
            "countries model_list car_names",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the ids and names of all countries that either have at most 3 car makers or produce fiat model?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-2-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GWHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the ids and names of all countries that either have at most 3 car makers or produce fiat model?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c0, t1.c1",
        "label": "select t1.c0, t1.c1",
        "score": true,
        "real_pred": "select countries.CountryId, countries.CountryName",
        "real_label": "select countries.CountryId, countries.CountryName",
        "topk_preds": [
            "select countries.CountryId, countries.CountryName",
            "select car_makers.Id, countries.CountryName",
            "select car_names.Model, countries.CountryId, countries.CountryName",
            "select countries.CountryId, countries.CountryName, car_makers.Country",
            "select t1, car_makers.Id, countries.CountryName",
            "select countries.CountryId, countries.CountryName, min(car_makers.Id)",
            "select countries.CountryId, countries.CountryName, countries.Continent",
            "select countries.CountryId, countries.CountryName,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the ids and names of all countries that either have at most 3 car makers or produce fiat model?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2 t3 t4",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "countries car_makers model_list car_names",
        "real_label": "countries car_makers model_list",
        "topk_preds": [
            "countries car_makers model_list car_names",
            "countries car_makers model_list",
            "countries model_list car_names",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the names of stores whose number products is less than the average number of products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM'GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the names of stores whose number products is less than the average number of products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, shop.Manager_name",
            "select shop.Name, shop.District",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.Number_products",
            "select shop.Name, t1.c6",
            "select shop.Name - shop.Manager_name",
            "select shop.Name (or shop.Manager_name)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the names of stores whose number products is less than the average number of products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the names of stores whose number products is at most the average number of products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the names of stores whose number products is at most the average number of products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, shop.Manager_name",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.District",
            "select shop.Name, shop.Number_products",
            "select shop.Name, t1.c6",
            "select shop.Name (or shop.Manager_name)",
            "select shop.Name - shop.Number_products"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the names of stores whose number products is at most the average number of products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which shops' number products is below the average? Give me the shop names., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which shops' number products is below the average? Give me the shop names., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.District",
            "select shop.Name, shop.Number_products",
            "select shop.Name, shop.Manager_name",
            "select shop.Name, t1.c6",
            "select shop.Name, shop.Shop_ID",
            "select shop.Name, t1.c7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which shops' number products is below the average? Give me the shop names., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show ids for all templates that are used by at least one document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM",
            "SELECT-FROM-ATTACH-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show ids for all templates that are used by at least one document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Documents.Template_ID",
        "real_label": "select Documents.Template_ID",
        "topk_preds": [
            "select Documents.Template_ID",
            "select Documents.Template_ID, Templates.Template_ID",
            "select distinct Documents.Template_ID",
            "select Documents.Template_ID, Templates.Template_Type_Code",
            "select Documents.Template_ID, Templates.Template_Details",
            "select Documents.Template_ID, Documents.Document_Name",
            "select at least Documents.Template_ID",
            "select Documents.Template_ID, Templates.Date_Effective_From"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show ids for all templates that are used by at least one document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Documents",
        "real_label": "Documents",
        "topk_preds": [
            "Documents",
            "Templates Documents",
            "Ref_Template_Types Documents",
            "Ref_Template_Types Templates Documents",
            "",
            "Paragraphs Documents",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show ids for all templates that are used by at most one document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show ids for all templates that are used by at most one document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Documents.Template_ID",
        "real_label": "select Documents.Template_ID",
        "topk_preds": [
            "select Documents.Template_ID",
            "select Documents.Template_ID, Templates.Template_ID",
            "select Documents.Template_ID, Documents.Document_Name",
            "select Documents.Template_ID, Templates.Template_Type_Code",
            "select Documents.Template_ID, Templates.Template_Details",
            "select Documents.Template_ID, Templates.Version_Number",
            "select Documents.Template_ID, Templates.Date_Effective_From",
            "select Documents.Template_ID, Documents.Document_Description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show ids for all templates that are used by at most one document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Documents",
        "real_label": "Documents",
        "topk_preds": [
            "Documents",
            "Templates Documents",
            "",
            "Ref_Template_Types Documents",
            "",
            "",
            "Paragraphs Documents",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the template ids of any templates used in at least a single document?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAUSS-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-PROCESS-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSIST-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the template ids of any templates used in at least a single document?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Documents.Template_ID",
        "real_label": "select Documents.Template_ID",
        "topk_preds": [
            "select Documents.Template_ID",
            "select Documents.Template_ID, Documents.Document_Name",
            "select Documents.Template_ID, Documents.Document_Description",
            "select Documents.Template_ID, Templates.Template_Type_Code",
            "select Documents.Template_ID, Templates.Template_Details",
            "select Documents.Template_ID (at least Documents.Document_ID)",
            "select Documents.Template_ID, Templates.Template_ID",
            "select Documents.Template_ID (document_Documents.Document_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the template ids of any templates used in at least a single document?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Documents",
        "real_label": "Documents",
        "topk_preds": [
            "Documents",
            "Templates Documents",
            "",
            "",
            "",
            "",
            "Ref_Template_Types Documents",
            "Ref_Template_Types Templates Documents"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the template ids of any templates used in at most a single document?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the template ids of any templates used in at most a single document?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Documents.Template_ID",
        "real_label": "select Documents.Template_ID",
        "topk_preds": [
            "select Documents.Template_ID",
            "select Documents.Template_ID, Documents.Document_Name",
            "select Documents.Template_ID, Documents.Document_Description",
            "select Documents.Template_ID, Templates.Template_Details",
            "select Documents.Template_ID (or Documents.Document_Name)",
            "select Documents.Template_ID, Templates.Template_Type_Code",
            "select Documents.Template_ID, Templates.Template_ID",
            "select Documents.Template_ID, Documents.Other_Details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the template ids of any templates used in at most a single document?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Documents",
        "real_label": "Documents",
        "topk_preds": [
            "Documents",
            "Templates Documents",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the version numbers and template type codes of templates with a version number less than 5., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the version numbers and template type codes of templates with a version number less than 5., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select Templates.Version_Number, Templates.Template_Type_Code",
        "real_label": "select Templates.Version_Number, Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Version_Number, Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Version_Number.c2, Templates.Version_Number",
            "select Documents.Template_ID, Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Template_Type_Code",
            "select Templates.Version_Number, Templates.Template_Type_Code, Templates.Template_ID",
            "select Templates.Template_Type_Code, Templates.Version_Number",
            "select Templates.Version_Number, Templates.Template_Type_Code, Templates.Template_Details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the version numbers and template type codes of templates with a version number less than 5., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the version numbers and template type codes of templates with a version number at least 5., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the version numbers and template type codes of templates with a version number at least 5., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select Templates.Version_Number, Templates.Template_Type_Code",
        "real_label": "select Templates.Version_Number, Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Version_Number, Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Version_Number.c2, Templates.Version_Number",
            "select Documents.Template_ID, Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Template_Type_Code",
            "select Templates.Version_Number, Templates.Template_Type_Code, Templates.Template_ID",
            "select Templates.Template_Type_Code, Templates.Version_Number",
            "select Templates.Version_Number, Templates.Template_Type_Code, Templates.Template_Details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the version numbers and template type codes of templates with a version number at least 5., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the version numbers and template type codes of templates with a version number at most 5., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the version numbers and template type codes of templates with a version number at most 5., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select Templates.Version_Number, Templates.Template_Type_Code",
        "real_label": "select Templates.Version_Number, Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Version_Number, Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Version_Number, Templates.Template_Type_Code, Templates.Template_ID",
            "select Templates.Version_Number.c2, Templates.Version_Number",
            "select Documents.Template_ID, Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Template_Type_Code",
            "select Templates.Version_Number, Templates.Template_Type_Code, Templates.Template_Details",
            "select t1.c 1, Templates.Template_Type_Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the version numbers and template type codes of templates with a version number at most 5., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all template type codes with more than three templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-PROGRAM-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-IN-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all template type codes with more than three templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From, Templates.Date_Effective_To",
            "select Templates.Template_Type_Code (ref. Templates.Date_Effective_From)",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From, max(Templates.Date_Effective_To)",
            "select Templates.Template_Type_Code (ref. Templates.Version_Number)",
            "select Templates.Template_Type_Code, Templates.Template_Details",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From, Templates.Template_Details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all template type codes with more than three templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all template type codes with at least three templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSIST-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all template type codes with at least three templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From, Templates.Date_Effective_To",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From, Templates.Template_Details",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From, max(Templates.Date_Effective_To)",
            "select Templates.Template_Type_Code (ref. Templates.Date_Effective_From)",
            "select Templates.Template_Type_Code, Templates.Template_Details",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From, min(Templates.Date_Effective_To)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all template type codes with at least three templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all template type codes with at most three templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-PROGRAM-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-PROGRAM-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all template type codes with at most three templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, max(Templates.Template_Details)",
            "select Templates.Template_Type_Code, max(Templates.Date_Effective_From)",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Template_Type_Code, min(Templates.Template_Details)",
            "select Templates.Template_Type_Code, max(Templates.Date_Effective_To)",
            "select Templates.Template_Type_Code, max(Templates.Template_ID)",
            "select Templates.Template_Type_Code, max(t1.c6)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all template type codes with at most three templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all document ids with more than two paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all document ids with more than two paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Paragraphs.Document_ID",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID (Paragraphs.Paragraph_ID)",
            "select Paragraphs.Document_ID,",
            "select Paragraphs.Document_ID, Paragraphs.Other_Details",
            "select Paragraphs.Document_ID (Paragraphs.Paragraph_Text)",
            "select Paragraphs.Document_ID",
            "select Paragraphs.Document_ID.c1"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all document ids with more than two paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "Documents Paragraphs",
            "Templates Paragraphs",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all document ids with less than two paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all document ids with less than two paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Paragraphs.Document_ID",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID",
            "select Paragraphs.Document_ID (Paragraphs.Paragraph_ID)",
            "select Paragraphs.Document_ID (Paragraphs.Paragraph_Text)",
            "select Paragraphs.Document_ID,",
            "select Paragraphs.Paragraph_ID",
            "select Paragraphs.Document_ID, Paragraphs.Other_Details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all document ids with less than two paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "Documents Paragraphs",
            "Templates Paragraphs",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all document ids with at most two paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAGLE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups of at-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all document ids with at most two paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Paragraphs.Document_ID",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID (Paragraphs.Paragraph_ID)",
            "select Paragraphs.Document_ID (Paragraphs.Paragraph_Text)",
            "select Paragraphs.Document_ID, Paragraphs.Other_Details",
            "select Paragraphs.Document_ID,",
            "select Paragraphs.Document_ID",
            "select Documents.Document_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all document ids with at most two paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "Documents Paragraphs",
            "Templates Paragraphs",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the ids of documents that have 2 or less paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the ids of documents that have 2 or less paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c0",
        "label": "select t3.c1",
        "score": false,
        "real_pred": "select Documents.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Documents.Document_ID",
            "select Paragraphs.Document_ID",
            "select Documents.Document_ID, Paragraphs.Document_ID",
            "select Documents.Document_ID, Documents.Template_ID",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Paragraphs.Document_ID, Documents.Document_Name",
            "select Documents.Document_ID, Documents.Document_Description",
            "select Documents.Document_ID, Paragraphs.Document_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the ids of documents that have 2 or less paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t3",
        "score": false,
        "real_pred": "Documents Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "Paragraphs",
            "Ref_Template_Types Documents Paragraphs",
            "Templates Documents Paragraphs",
            "Templates Paragraphs",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show names of teachers that teach less than two courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show names of teachers that teach less than two courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, course.Course",
            "select teacher.Name, course.Staring_Date",
            "select teacher.Name, t0.c3",
            "select teacher.Name, course.Course_ID",
            "select teacher.Name (course.Course)",
            "select teacher.Name, course_arrange.Teacher_ID",
            "select teacher.Name,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show names of teachers that teach less than two courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show names of teachers that teach at most two courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show names of teachers that teach at most two courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, course.Course",
            "select teacher.Name, course.Staring_Date",
            "select teacher.Name, t0.c3",
            "select teacher.Name, course.Course_ID",
            "select teacher.Name (course.Course)",
            "select teacher.Name I, course.Course",
            "select teacher.Name,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show names of teachers that teach at most two courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the teachers who teach less than two courses?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the teachers who teach less than two courses?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, course.Course",
            "select teacher.Name, course.Staring_Date",
            "select teacher.Name, t0.c3",
            "select teacher.Name, course.Course_ID",
            "select teacher.Name, course_arrange.Teacher_ID",
            "select teacher.Name (course.Course)",
            "select teacher.Name, t0.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the teachers who teach less than two courses?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the teachers who teach at most two courses?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the teachers who teach at most two courses?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, course.Course",
            "select teacher.Name, course.Staring_Date",
            "select teacher.Name, t0.c3",
            "select teacher.Name, course.Course_ID",
            "select teacher.Name (course.Course)",
            "select teacher.Name, t0.c4",
            "select teacher.Name, course_arrange.Teacher_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the teachers who teach at most two courses?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the names of the visitors whose membership level is lower than 4, and order the results by the level from high to low., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-WHERE-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY t1.c1",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY (CLIENT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY.",
            "SELECT-FROM-WHERE-ORDER BY ",
            "SELECT-FROM-WHERE-ORDER BY(t1.c1)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the names of the visitors whose membership level is lower than 4, and order the results by the level from high to low., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select visitor.Name",
        "real_label": "select visitor.Name",
        "topk_preds": [
            "select visitor.Name",
            "select visitor.Name, visitor.Level_of_membership",
            "select visitor.Name, t1.c4",
            "select visitor.Name-ORDER BY",
            "select visitor.Name, visitor.Age",
            "select visitor.Name--ORDER BY",
            "select visitor.Name, t1.c6",
            "select visitor.Name-ordered"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the names of the visitors whose membership level is lower than 4, and order the results by the level from high to low., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the names of the visitors whose membership level is at most 4, and order the results by the level from high to low., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-WHERE-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY t1.c1",
            "SELECT-FROM-WHERE-ORDER BY ",
            "SELECT-FROM-WHERE-ORDER BY.",
            "SELECT-FROM-WHERE-ORDER BY(t1.c1)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the names of the visitors whose membership level is at most 4, and order the results by the level from high to low., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select visitor.Name",
        "real_label": "select visitor.Name",
        "topk_preds": [
            "select visitor.Name",
            "select visitor.Name, visitor.Level_of_membership",
            "select visitor.Name-ORDER BY",
            "select visitor.Name, t1.c4",
            "select visitor.Name, visitor.Age",
            "select visitor.Name-ordered",
            "select visitor.Name and visitor.Level_of_membership",
            "select visitor.Name in visitor.Level_of_membership"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the names of the visitors whose membership level is at most 4, and order the results by the level from high to low., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the name and membership level of the visitors whose membership level is lower than 4, and sort by their age from old to young., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-WHERE-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY t1.c1, t1.c2",
            "SELECT-FROM-WHERE-ORDER BY.",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY(t1.c1)",
            "SELECT-FROM-WHERE-ORDER BY ",
            "SELECT-FROM-WHERES-ORDER BY",
            "SELECT-FROM-WHERE\u2013ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the name and membership level of the visitors whose membership level is lower than 4, and sort by their age from old to young., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select visitor.Name, visitor.Level_of_membership",
        "real_label": "select visitor.Name, visitor.Level_of_membership",
        "topk_preds": [
            "select visitor.Name, visitor.Level_of_membership",
            "select visitor.Name, visitor.Level_of_membership, visitor.Age",
            "select visitor.Name, visitor.Level_of_membership sort by visitor.Age",
            "select visitor.Name, visitor.Level_of_membership sorting by visitor.Age",
            "select visitor.Name, visitor.Level_of_membership and visitor.Age",
            "select visitor.Name, visitor.Level_of_membership in visitor.Age",
            "select visitor.Name, visitor.Level_of_membership or visitor.Age",
            "select visitor.Name, visitor.Level_of_membership, visitor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the name and membership level of the visitors whose membership level is lower than 4, and sort by their age from old to young., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the name and membership level of the visitors whose membership level is at most 4, and sort by their age from old to young., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-WHERE-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY t1.c1, t1.c2",
            "SELECT-FROM-WHERE-ORDER BY.",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY ",
            "SELECT-FROM-WHERE-ORDER BY(t1.c1)",
            "SELECT-FROM-WHERE\u2013ORDER BY",
            "SELECT-FROM-WHERES-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the name and membership level of the visitors whose membership level is at most 4, and sort by their age from old to young., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select visitor.Name, visitor.Level_of_membership",
        "real_label": "select visitor.Name, visitor.Level_of_membership",
        "topk_preds": [
            "select visitor.Name, visitor.Level_of_membership",
            "select visitor.Name, visitor.Level_of_membership, visitor.Age",
            "select visitor.Name, visitor.Level_of_membership sort by visitor.Age",
            "select visitor.Name, visitor.Level_of_membership and visitor.Age",
            "select visitor.Name, visitor.Level_of_membership sorting by visitor.Age",
            "select visitor.Name, visitor.Level_of_membership in visitor.Age",
            "select visitor.Name, visitor.Level_of_membership or visitor.Age",
            "select visitor.Name, visitor.Level_of_membership, visitor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the name and membership level of the visitors whose membership level is at most 4, and sort by their age from old to young., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the average number of staff working for the museums that were open after 2009., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AVERAGE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the average number of staff working for the museums that were open after 2009., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select avg(t0.c2)",
        "label": "select avg(t0.c2)",
        "score": true,
        "real_pred": "select avg(museum.Num_of_Staff)",
        "real_label": "select avg(museum.Num_of_Staff)",
        "topk_preds": [
            "select avg(museum.Num_of_Staff)",
            "select avg(t0.c4)",
            "select an avg(museum.Num_of_Staff)",
            "select  avg(museum.Num_of_Staff)",
            "select avg(museum.Open_Year)",
            "select avg(t0.c6)",
            "select avg(museum.Num_of_Staff).",
            "select avg(t0.c5)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the average number of staff working for the museums that were open after 2009., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "museum",
        "real_label": "museum",
        "topk_preds": [
            "museum",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: find the names of museums which have more staff than the minimum staff number of all museums opened before 2010., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: find the names of museums which have more staff than the minimum staff number of all museums opened before 2010., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select museum.Name",
        "real_label": "select museum.Name",
        "topk_preds": [
            "select museum.Name",
            "select museum.Name, museum.Num_of_Staff",
            "select museum.Name, museum.Num_of_Staff, museum.Open_Year",
            "select museum.Name, museum.Num_of_Staff, museum.Open_Year",
            "select museum.Museum_ID, museum.Name",
            "select museum.Name, museum.Open_Year",
            "select museum.Name, museum.Num_of_Staff, museum.Open_Year",
            "select museum.Name (except museum.Num_of_Staff)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: find the names of museums which have more staff than the minimum staff number of all museums opened before 2010., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "museum",
        "real_label": "museum",
        "topk_preds": [
            "museum",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the number of visitors who did not visit any museum opened before 2010., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE (*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WITH-WHERE",
            "SELECT-FROM-WHERE(*)",
            "SELECT-FROM-WHERE (t1.c0)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the number of visitors who did not visit any museum opened before 2010., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), museum.Name",
            "select count(*), museum.Open_Year",
            "select count(*), museum.Museum_ID",
            "select count(*), museum.Num_of_Staff",
            "select count(distinct visit.visitor_ID)",
            "select count(distinct visitor.ID)",
            "select count(*), museum.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the number of visitors who did not visit any museum opened before 2010., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "museum visitor visit",
        "real_label": "museum visitor visit",
        "topk_preds": [
            "museum visitor visit",
            "museum visitor",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the name of tourney that has less than 10 matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the name of tourney that has less than 10 matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c20",
        "label": "select t1.c20",
        "score": true,
        "real_pred": "select matches.tourney_name",
        "real_label": "select matches.tourney_name",
        "topk_preds": [
            "select matches.tourney_name",
            "select matches.tourney_name, matches.winner_hand",
            "select matches.tourney_name, matches.tourney_date",
            "select matches.tourney_name, matches.winner_age",
            "select matches.tourney_name, matches.minutes",
            "select matches.tourney_name, matches.winner_entry",
            "select matches.tourney_name, matches.tourney_name",
            "select matches.tourney_name, matches.tourney_level"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the name of tourney that has less than 10 matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the name of tourney that has at most 10 matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the name of tourney that has at most 10 matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c20",
        "label": "select t1.c20",
        "score": true,
        "real_pred": "select matches.tourney_name",
        "real_label": "select matches.tourney_name",
        "topk_preds": [
            "select matches.tourney_name",
            "select matches.tourney_name, matches.winner_hand",
            "select matches.tourney_name, matches.tourney_date",
            "select matches.tourney_name, matches.minutes",
            "select matches.tourney_name, matches.winner_age",
            "select matches.tourney_name, matches.winner_entry",
            "select matches.tourney_name, matches.tourney_name",
            "select matches.tourney_name, matches.match_num"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the name of tourney that has at most 10 matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "matches rankings",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of tournaments that have less than 10 matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of tournaments that have less than 10 matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c20",
        "label": "select t1.c20",
        "score": true,
        "real_pred": "select matches.tourney_name",
        "real_label": "select matches.tourney_name",
        "topk_preds": [
            "select matches.tourney_name",
            "select matches.tourney_name, matches.winner_hand",
            "select matches.tourney_name, matches.tourney_date",
            "select matches.tourney_name, matches.winner_age",
            "select matches.tourney_name, matches.winner_entry",
            "select matches.tourney_name, matches.minutes",
            "select matches.best_of, matches.tourney_name",
            "select matches.tourney_name, matches.tourney_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of tournaments that have less than 10 matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of tournaments that have at most 10 matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of tournaments that have at most 10 matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c20",
        "label": "select t1.c20",
        "score": true,
        "real_pred": "select matches.tourney_name",
        "real_label": "select matches.tourney_name",
        "topk_preds": [
            "select matches.tourney_name",
            "select matches.tourney_name, matches.winner_hand",
            "select matches.tourney_name, matches.winner_age",
            "select matches.tourney_name, matches.tourney_date",
            "select matches.tourney_name, matches.winner_entry",
            "select matches.best_of, matches.tourney_name",
            "select matches.tourney_name, matches.minutes",
            "select matches.tourney_name, matches.match_num"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of tournaments that have at most 10 matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the codes of countries that have less than 50 players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the codes of countries that have less than 50 players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c5",
        "label": "select t0.c5",
        "score": true,
        "real_pred": "select players.country_code",
        "real_label": "select players.country_code",
        "topk_preds": [
            "select players.country_code",
            "select players.country_code, t0.c6",
            "select players.country_code, count(*)",
            "select players.country_code, max(players.country_code)",
            "select players.country_code, max(t0.c6)",
            "select players.country_code, max(players.birth_date)",
            "select players.country_code, max(players.player_id)",
            "select players.country_code, t0.c7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the codes of countries that have less than 50 players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            "players matches"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the codes of countries that have at most 50 players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING In-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the codes of countries that have at most 50 players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c5",
        "label": "select t0.c5",
        "score": true,
        "real_pred": "select players.country_code",
        "real_label": "select players.country_code",
        "topk_preds": [
            "select players.country_code",
            "select players.country_code, t0.c6",
            "select players.country_code, max(players.player_id)",
            "select players.country_code, max(players.birth_date)",
            "select players.country_code, max(players.country_code)",
            "select players.country_code, max(t0.c6)",
            "select players.country_code, max(*)",
            "select players.country_code, max(t0.c8)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the codes of countries that have at most 50 players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "players matches",
            "",
            "players rankings",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the codes of countries with less than 50 players?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the codes of countries with less than 50 players?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c5",
        "label": "select t0.c5",
        "score": true,
        "real_pred": "select players.country_code",
        "real_label": "select players.country_code",
        "topk_preds": [
            "select players.country_code",
            "select players.country_code, t0.c6",
            "select players.country_code, t0.c7",
            "select players.country_code, players.first_name",
            "select players.country_code, players.birth_date",
            "select players.country_code, players.last_name",
            "select players.country_code, players.hand",
            "select players.country_code, t0.c8"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the codes of countries with less than 50 players?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "players matches",
            "players rankings",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the codes of countries with at most 50 players?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the codes of countries with at most 50 players?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c5",
        "label": "select t0.c5",
        "score": true,
        "real_pred": "select players.country_code",
        "real_label": "select players.country_code",
        "topk_preds": [
            "select players.country_code",
            "select players.country_code, t0.c6",
            "select players.country_code, max(players.player_id)",
            "select players.country_code, max(players.birth_date)",
            "select players.country_code, max(players.country_code)",
            "select players.country_code, t0.c7",
            "select players.country_code, max(t0.c6)",
            "select players.country_code, players.birth_date"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the codes of countries with at most 50 players?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "players matches",
            "",
            "players rankings",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the ids and names of the battles that led to less than 10 people killed in total., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the ids and names of the battles that led to less than 10 people killed in total., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select t0.c0, t0.c1",
        "label": "select t0.c0, t0.c1",
        "score": true,
        "real_pred": "select battle.id, battle.name",
        "real_label": "select battle.id, battle.name",
        "topk_preds": [
            "select battle.id, battle.name",
            "select battle.name, battle.id",
            "select battle.date, battle.name",
            "select death.id, battle.name",
            "select t0.c, battle.name",
            "select battle.name, battle.date",
            "select t0-c0, battle.name",
            "select t 0.c0, battle.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the ids and names of the battles that led to less than 10 people killed in total., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t1 t2",
        "score": false,
        "real_pred": "battle death",
        "real_label": "battle ship death",
        "topk_preds": [
            "battle death",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the ids and names of the battles that led to at most 10 people killed in total., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-IN-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-IN-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-IN-TO-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-IN-TO-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the ids and names of the battles that led to at most 10 people killed in total., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select t0.c0, t0.c1",
        "label": "select t0.c0, t0.c1",
        "score": true,
        "real_pred": "select battle.id, battle.name",
        "real_label": "select battle.id, battle.name",
        "topk_preds": [
            "select battle.id, battle.name",
            "select battle.name, battle.id",
            "select battle.date, battle.name",
            "select death.id, battle.name",
            "select battle.name, battle.date",
            "select t0.c, battle.name",
            "select ship.lost_in_battle, battle.name",
            "select t.c0, battle.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the ids and names of the battles that led to at most 10 people killed in total., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t1 t2",
        "score": false,
        "real_pred": "battle death",
        "real_label": "battle ship death",
        "topk_preds": [
            "battle death",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names and id of courses having less than 2 sections?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names and id of courses having less than 2 sections?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0",
        "prediction": "select t1.c1, t1.c0",
        "label": "select t1.c1, t1.c0",
        "score": true,
        "real_pred": "select Courses.course_name, Courses.course_id",
        "real_label": "select Courses.course_name, Courses.course_id",
        "topk_preds": [
            "select Courses.course_name, Courses.course_id",
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Sections.section_id",
            "select Courses.course_name, Departments.department_id",
            "select Courses.course_name, Degree_Programs.degree_program_id",
            "select Courses.course_name, Semesters.semester_id",
            "select Courses.course_name, Addresses.address_id",
            "select Sections.course_id, Courses.course_description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names and id of courses having less than 2 sections?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "t1 t4",
        "label": "t1 t4",
        "score": true,
        "real_pred": "Courses Sections",
        "real_label": "Courses Sections",
        "topk_preds": [
            "Courses Sections",
            "",
            "Courses Departments Sections",
            "",
            "",
            "",
            "Courses Degree_Programs Sections",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names and id of courses having at least 2 sections?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names and id of courses having at least 2 sections?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0",
        "prediction": "select t1.c1, t1.c0",
        "label": "select t1.c1, t1.c0",
        "score": true,
        "real_pred": "select Courses.course_name, Courses.course_id",
        "real_label": "select Courses.course_name, Courses.course_id",
        "topk_preds": [
            "select Courses.course_name, Courses.course_id",
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Sections.section_id",
            "select Courses.course_name, Departments.department_id",
            "select Courses.course_name, Degree_Programs.degree_program_id",
            "select Sections.course_id, Sections.section_id",
            "select Courses.course_name, Semesters.semester_id",
            "select Courses.course_name, Semesters.semester_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names and id of courses having at least 2 sections?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "t1 t4",
        "label": "t1 t4",
        "score": true,
        "real_pred": "Courses Sections",
        "real_label": "Courses Sections",
        "topk_preds": [
            "Courses Sections",
            "",
            "",
            "",
            "",
            "",
            "",
            "Courses Degree_Programs Sections"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the date and id of the transcript with more than 2 course results., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING In-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the date and id of the transcript with more than 2 course results., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "select t8.c5, t8.c0",
        "label": "select t9.c1, t10.c1",
        "score": false,
        "real_pred": "select t8.c5, Student_Enrolment_Courses.student_course_id",
        "real_label": "select Transcripts.transcript_date, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t8.c5, Student_Enrolment_Courses.student_course_id",
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t9.c5, Transcripts.transcript_id",
            "select t12.c5, t12.c0",
            "select t14.c3, t14.c0",
            "select t12.c3, t12.c0",
            "select t14.c5, t14.c0",
            "select t11.c3, t11.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the date and id of the transcript with more than 2 course results., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "t8",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Student_Enrolment_Courses",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Student_Enrolment_Courses",
            "Transcripts",
            "Transcript_Contents",
            "",
            "",
            "Semesters Student_Enrolment_Courses",
            "",
            "Transcripts Transcript_Contents"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the date and id of the transcript with less than 2 course results., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING In-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the date and id of the transcript with less than 2 course results., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "select t8.c5, t8.c0",
        "label": "select t9.c1, t10.c1",
        "score": false,
        "real_pred": "select t8.c5, Student_Enrolment_Courses.student_course_id",
        "real_label": "select Transcripts.transcript_date, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t8.c5, Student_Enrolment_Courses.student_course_id",
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t12.c5, t12.c0",
            "select t9.c5, Transcripts.transcript_id",
            "select t12.c3, t12.c0",
            "select t14.c3, t14.c0",
            "select t11.c3, t11.c4",
            "select t14.c5, t14.c0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the date and id of the transcript with less than 2 course results., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "t8",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Student_Enrolment_Courses",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Student_Enrolment_Courses",
            "Transcripts",
            "Transcript_Contents",
            "",
            "",
            "Semesters Student_Enrolment_Courses",
            "Semesters Student_Enrolment",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the date and id of the transcript with at most 2 course results., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAGLE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GAGLE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the date and id of the transcript with at most 2 course results., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "select t8.c5, t8.c0",
        "label": "select t9.c1, t10.c1",
        "score": false,
        "real_pred": "select t8.c5, Student_Enrolment_Courses.student_course_id",
        "real_label": "select Transcripts.transcript_date, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t8.c5, Student_Enrolment_Courses.student_course_id",
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t9.c5, Transcripts.transcript_id",
            "select t12.c5, t12.c0",
            "select t14.c3, t14.c0",
            "select t12.c3, t12.c0",
            "select t11.c3, t11.c4",
            "select t14.c5, t14.c0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the date and id of the transcript with at most 2 course results., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "t9",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Transcripts",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Transcripts",
            "Student_Enrolment_Courses",
            "Transcript_Contents",
            "Student_Enrolment",
            "Semesters Student_Enrolment_Courses",
            "",
            "Semesters Student_Enrolment",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the date and id of the transcript with more than 2 courses listed?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING In-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING, SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the date and id of the transcript with more than 2 courses listed?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(",
        "prediction": "select t10.c5, t10.c0",
        "label": "select t9.c1, t10.c1",
        "score": false,
        "real_pred": "select t10.c5, Transcript_Contents.student_course_id",
        "real_label": "select Transcripts.transcript_date, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t14.c3, t14.c0",
            "select t14.c5, t14.c0",
            "select t12.c5, t12.c0",
            "select t8.c5, Student_Enrolment_Courses.student_course_id",
            "select t11.c3, t11.c4",
            "select t14.c3, t14.c4",
            "select t10.c3, t10.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the date and id of the transcript with more than 2 courses listed?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "t1 t8",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Courses Student_Enrolment_Courses",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Courses Student_Enrolment_Courses",
            "Courses Student_Enrolment",
            "Courses Transcripts",
            "Courses",
            "",
            "Courses Transcript_Contents",
            "Semesters Student_Enrolment_Courses",
            "Courses Sections"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the date and id of the transcript with less than 2 courses listed?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING In-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the date and id of the transcript with less than 2 courses listed?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(",
        "prediction": "select t10.c5, t10.c0",
        "label": "select t9.c1, t10.c1",
        "score": false,
        "real_pred": "select t10.c5, Transcript_Contents.student_course_id",
        "real_label": "select Transcripts.transcript_date, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t8.c5, Student_Enrolment_Courses.student_course_id",
            "select t12.c5, t12.c0",
            "select t14.c3, t14.c0",
            "select t11.c3, t11.c4",
            "select t14.c3, t14.c4",
            "select t12.c3, t12.c0",
            "select t8.c3, Student_Enrolment_Courses.student_course_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the date and id of the transcript with less than 2 courses listed?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "t1 t8",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Courses Student_Enrolment_Courses",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Courses Student_Enrolment_Courses",
            "Courses Student_Enrolment",
            "Courses Transcripts",
            "Courses",
            "",
            "Courses Transcript_Contents",
            "",
            "Semesters Student_Enrolment_Courses"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the date and id of the transcript with at most 2 courses listed?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING In-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the date and id of the transcript with at most 2 courses listed?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(",
        "prediction": "select t14.c3, t14.c0",
        "label": "select t9.c1, t10.c1",
        "score": false,
        "real_pred": "select t14.c3, t14.c0",
        "real_label": "select Transcripts.transcript_date, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t14.c3, t14.c0",
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t14.c5, t14.c0",
            "select t12.c5, t12.c0",
            "select t8.c5, Student_Enrolment_Courses.student_course_id",
            "select t11.c3, t11.c4",
            "select t12.c3, t12.c0",
            "select t14.c3, t14.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the date and id of the transcript with at most 2 courses listed?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "t1 t8",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Courses Student_Enrolment_Courses",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Courses Student_Enrolment_Courses",
            "Courses Student_Enrolment",
            "Courses Transcripts",
            "Semesters Student_Enrolment_Courses",
            "",
            "",
            "Semesters Student_Enrolment",
            "Students Student_Enrolment_Courses"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: find id of the tv channels that from the countries where have less than two tv channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: find id of the tv channels that from the countries where have less than two tv channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select TV_Channel.id",
        "real_label": "select TV_Channel.id",
        "topk_preds": [
            "select TV_Channel.id",
            "select TV_Channel.id, TV_Channel.Country",
            "select t0.c, TV_Channel.Country",
            "select TV_Channel.id, TV_Channel.Country, TV_Channel.Language",
            "select TV_Channel.id, TV_Channel.Country",
            "select TV_Channel.id, TV_Channel.Country, TV_Channel.Content",
            "select TV_Channel.id, TV_Channel.Country, max(TV_Channel.id)",
            "select TV_Channel.id, TV_Channel.Country, max(TV_Channel.Country)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: find id of the tv channels that from the countries where have less than two tv channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "TV_Channel TV_series Cartoon",
            "TV_Channel TV_series",
            "",
            "",
            "TV_Channel Cartoon",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: find id of the tv channels that from the countries where have at least two tv channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: find id of the tv channels that from the countries where have at least two tv channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select TV_Channel.id",
        "real_label": "select TV_Channel.id",
        "topk_preds": [
            "select TV_Channel.id",
            "select TV_Channel.id, TV_Channel.Country",
            "select t0.c, TV_Channel.Country",
            "select TV_Channel.id, TV_Channel.Country, max(TV_Channel.id)",
            "select TV_Channel.id, TV_Channel.Country, min(TV_Channel.Content)",
            "select TV_Channel.id, TV_Channel.Country, TV_Channel.Language",
            "select TV_Channel.id, TV_Channel.Country, min(TV_Channel.id)",
            "select TV_Channel.id, TV_Channel.Country, max(TV_Channel.Content)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: find id of the tv channels that from the countries where have at least two tv channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "TV_Channel TV_series Cartoon",
            "TV_Channel TV_series Cartoon",
            "TV_Channel TV_series",
            "",
            "TV_Channel Cartoon",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: find id of the tv channels that from the countries where have at most two tv channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTANCE-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: find id of the tv channels that from the countries where have at most two tv channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select TV_Channel.id",
        "real_label": "select TV_Channel.id",
        "topk_preds": [
            "select TV_Channel.id",
            "select TV_Channel.id, TV_Channel.Country",
            "select t0.c, TV_Channel.Country",
            "select TV_Channel.id, TV_Channel.Country, TV_Channel.Language",
            "select TV_Channel.id, TV_Channel.Country, max(TV_Channel.Country)",
            "select TV_Channel.id, TV_Channel.Country, TV_Channel.Content",
            "select TV_Channel.id, TV_Channel.Country",
            "select TV_Channel.id, TV_Channel.Country, max(TV_Channel.Content)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: find id of the tv channels that from the countries where have at most two tv channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "TV_Channel TV_series Cartoon",
            "TV_Channel TV_series",
            "",
            "",
            "TV_Channel Cartoon",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the ids of all tv channels that have less than 2 TV channels?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING\u2013UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the ids of all tv channels that have less than 2 TV channels?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select TV_Channel.id",
        "real_label": "select TV_Channel.id",
        "topk_preds": [
            "select TV_Channel.id",
            "select tv0.c0",
            "select TV_Channel.id, TV_Channel.Hight_definition_TV",
            "select TV_Channel.id, TV_Channel.Pixel_aspect_ratio_PAR",
            "select tv.c0",
            "select tv_channel.c0",
            "select TV_Channel.id, TV_Channel.Pay_per_view_PPV",
            "select tTV_Channel.id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the ids of all tv channels that have less than 2 TV channels?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "TV_Channel TV_series",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the ids of all tv channels that have at least 2 TV channels?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the ids of all tv channels that have at least 2 TV channels?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select TV_Channel.id",
        "real_label": "select TV_Channel.id",
        "topk_preds": [
            "select TV_Channel.id",
            "select TV_Channel.id, TV_Channel.Hight_definition_TV",
            "select TV_Channel.id, TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.id, TV_Channel.Pay_per_view_PPV",
            "select TV_Channel.id, TV_Channel.Country",
            "select TV_Channel.id, TV_Channel.series_name",
            "select tv0.c0",
            "select TV_Channel.id, TV_Channel.Language"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the ids of all tv channels that have at least 2 TV channels?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "TV_Channel TV_series",
            "TV_Channel Cartoon",
            "",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the ids of all tv channels that have at most 2 TV channels?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the ids of all tv channels that have at most 2 TV channels?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select TV_Channel.id",
        "real_label": "select TV_Channel.id",
        "topk_preds": [
            "select TV_Channel.id",
            "select TV_Channel.id, TV_Channel.Hight_definition_TV",
            "select tv0.c0",
            "select TV_Channel.id, TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.id, TV_Channel.Pay_per_view_PPV",
            "select tv.c0",
            "select tv_channel.c0",
            "select TV_Channel.id, TV_Channel.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the ids of all tv channels that have at most 2 TV channels?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "",
            "TV_Channel TV_series",
            "TV_Channel Cartoon",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the maximum number of final tables made among poker players with earnings more than 200000?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE max(t0.c2)",
            "SELECT-FROM-WHERE - GROUP BY-HAVING",
            "SELECT-FROM-WHERE.GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the maximum number of final tables made among poker players with earnings more than 200000?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select max(t0.c2)",
        "label": "select max(t0.c2)",
        "score": true,
        "real_pred": "select max(poker_player.Final_Table_Made)",
        "real_label": "select max(poker_player.Final_Table_Made)",
        "topk_preds": [
            "select max(poker_player.Final_Table_Made)",
            "select max(poker_player.Final_Table_Made), poker_player.Earnings",
            "select max(poker_player.Final_Table_Made), poker_player.Earnings",
            "select max(poker_player.Final_Table_Made) de poker_player.Poker_Player_ID",
            "select max(poker_player.Final_Table_Made), poker_player.Best_Finish",
            "select max(poker_player.Final_Table_Made) (poker_player.Poker_Player_ID)",
            "select max(poker_player.Final_Table_Made) (poker_player.Earnings)",
            "select max(poker_player.Final_Table_Made), poker_player.Earnings."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the maximum number of final tables made among poker players with earnings more than 200000?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the maximum number of final tables made among poker players with earnings at least 200000?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE max(t0.c2)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE - GROUP BY-HAVING",
            "SELECT-FROM-WHERE-MAX(t0.c2)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the maximum number of final tables made among poker players with earnings at least 200000?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select max(t0.c2)",
        "label": "select max(t0.c2)",
        "score": true,
        "real_pred": "select max(poker_player.Final_Table_Made)",
        "real_label": "select max(poker_player.Final_Table_Made)",
        "topk_preds": [
            "select max(poker_player.Final_Table_Made)",
            "select max(poker_player.Final_Table_Made), poker_player.Earnings",
            "select max(poker_player.Final_Table_Made), poker_player.Earnings",
            "select max(poker_player.Final_Table_Made), poker_player.Best_Finish",
            "select max(poker_player.Final_Table_Made) de poker_player.Poker_Player_ID",
            "select max(poker_player.Final_Table_Made) (poker_player.Poker_Player_ID)",
            "select max(poker_player.Final_Table_Made), t0.c7",
            "select max(poker_player.Final_Table_Made), poker_player.Money_Rank"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the maximum number of final tables made among poker players with earnings at least 200000?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the maximum final tables made across all poker players who have earnings over 200000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (GROUP BY-HAVING",
            "SELECT-FROM-WHERE (max(t0.c2)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the maximum final tables made across all poker players who have earnings over 200000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select max(t0.c2)",
        "label": "select max(t0.c2)",
        "score": true,
        "real_pred": "select max(poker_player.Final_Table_Made)",
        "real_label": "select max(poker_player.Final_Table_Made)",
        "topk_preds": [
            "select max(poker_player.Final_Table_Made)",
            "select max(poker_player.Final_Table_Made), poker_player.Earnings",
            "select max(poker_player.Final_Table_Made) de poker_player.Poker_Player_ID",
            "select max(poker_player.Final_Table_Made), poker_player.Best_Finish",
            "select max(poker_player.Final_Table_Made) devs poker_player.Poker_Player_ID",
            "select max(t0.c6)",
            "select max(poker_player.Final_Table_Made), poker_player.Earnings.",
            "select max(poker_player.Final_Table_Made), poker_player.Poker_Player_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the maximum final tables made across all poker players who have earnings over 200000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "poker_player people",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of poker players whose earnings is lower than 300000?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WITH-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of poker players whose earnings is lower than 300000?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, poker_player.People_ID",
            "select people.Name, poker_player.Poker_Player_ID",
            "select people.Name, t1.c5",
            "select people.Name, poker_player.Best_Finish",
            "select people.Name, poker_player.Earnings",
            "select people.Name, people.Nationality"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of poker players whose earnings is lower than 300000?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of poker players whose earnings is at most 300000?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of poker players whose earnings is at most 300000?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, poker_player.People_ID",
            "select people.Name, t1.c5",
            "select people.Name, poker_player.Poker_Player_ID",
            "select people.Name, people.Nationality",
            "select people.Name, poker_player.Best_Finish",
            "select people.Name, people.Height"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of poker players whose earnings is at most 300000?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give the names of poker players who have earnings below 300000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give the names of poker players who have earnings below 300000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, poker_player.People_ID",
            "select people.Name, poker_player.Poker_Player_ID",
            "select people.Name, t1.c5",
            "select people.Name, people.Nationality",
            "select people.Name, poker_player.Best_Finish",
            "select people.Name, people.People_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give the names of poker players who have earnings below 300000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the average earnings of poker players with height lower than 200?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (Avg(t0.c5)",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (avg(t0.c5)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the average earnings of poker players with height lower than 200?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select avg(t0.c5)",
        "label": "select avg(t0.c5)",
        "score": true,
        "real_pred": "select avg(poker_player.Earnings)",
        "real_label": "select avg(poker_player.Earnings)",
        "topk_preds": [
            "select avg(poker_player.Earnings)",
            "select avg(poker_player.Earnings), people.Height",
            "select an avg(poker_player.Earnings)",
            "select  avg(poker_player.Earnings)",
            "select Avg(poker_player.Earnings)",
            "select avg(t0, poker_player.Earnings)",
            "select the avg(poker_player.Earnings)",
            "select avg(poker_player.Earnings), people.People_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the average earnings of poker players with height lower than 200?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the average earnings of poker players with height at most 200?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (Avg(t0.c5)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE -GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the average earnings of poker players with height at most 200?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select avg(t0.c5)",
        "label": "select avg(t0.c5)",
        "score": true,
        "real_pred": "select avg(poker_player.Earnings)",
        "real_label": "select avg(poker_player.Earnings)",
        "topk_preds": [
            "select avg(poker_player.Earnings)",
            "select avg(poker_player.Earnings), people.Height",
            "select an avg(poker_player.Earnings)",
            "select  avg(poker_player.Earnings)",
            "select avg(poker_player.Earnings), people.People_ID",
            "select Avg(poker_player.Earnings)",
            "select avg(t0, poker_player.Earnings)",
            "select the avg(poker_player.Earnings)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the average earnings of poker players with height at most 200?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the nationalities that are shared by less than two people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the nationalities that are shared by less than two people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select people.Nationality",
        "real_label": "select people.Nationality",
        "topk_preds": [
            "select people.Nationality",
            "select people.Nationality, people.Name",
            "select people.Nationality, people.Birth_Date",
            "select people.Nationality, people.People_ID",
            "select people.Nationality, max(people.Nationality)",
            "select people.Nationality, min(people.Name)",
            "select people.Nationality, people.Height",
            "select people.Nationality, max(people.Name)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the nationalities that are shared by less than two people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the nationalities that are shared by at most two people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSIST-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GATHER-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTANCE-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the nationalities that are shared by at most two people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select people.Nationality",
        "real_label": "select people.Nationality",
        "topk_preds": [
            "select people.Nationality",
            "select people.Nationality, people.Name",
            "select people.Nationality, max(people.Name)",
            "select people.Nationality, people.Birth_Date",
            "select people.Nationality, people.People_ID",
            "select people.Nationality, min(people.Name)",
            "select people.Nationality, people.Height",
            "select people.Nationality, max(people.Nationality)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the nationalities that are shared by at most two people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the nationalities for which there are two or less people., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-PROGRAM-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-PROGRAM-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-PROGRAM-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the nationalities for which there are two or less people., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select people.Nationality",
        "real_label": "select people.Nationality",
        "topk_preds": [
            "select people.Nationality",
            "select people.Nationality, count(*)",
            "select people.Nationality, people.Name",
            "select people.Nationality, min(people.Nationality)",
            "select people.Nationality, people.Birth_Date",
            "select people.Nationality, max(people.Nationality)",
            "select people.Nationality (people.Name)",
            "select people.Nationality, min(people.Name)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the nationalities for which there are two or less people., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the contestant numbers and names of the contestants who had less than two votes?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-T1.C0, SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups by-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the contestant numbers and names of the contestants who had less than two votes?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select t1.c0, t1.c1",
        "label": "select t1.c0, t1.c1",
        "score": true,
        "real_pred": "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name",
        "real_label": "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name",
        "topk_preds": [
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name",
            "select VOTES.contestant_number, CONTESTANTS.contestant_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name, VOTES.contestant_number",
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name, t1.c2",
            "select CONTESTANTS.contestant_name, CONTESTANTS.contestant_number",
            "select t1, CONTESTANTS.contestant_number, CONTESTANTS.contestant_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name,",
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name, CONTESTANTS.contestant_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the contestant numbers and names of the contestants who had less than two votes?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "CONTESTANTS VOTES",
        "real_label": "CONTESTANTS VOTES",
        "topk_preds": [
            "CONTESTANTS VOTES",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the contestant numbers and names of the contestants who had at most two votes?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the contestant numbers and names of the contestants who had at most two votes?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select t1.c0, t1.c1",
        "label": "select t1.c0, t1.c1",
        "score": true,
        "real_pred": "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name",
        "real_label": "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name",
        "topk_preds": [
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name",
            "select VOTES.contestant_number, CONTESTANTS.contestant_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name, t1.c2",
            "select CONTESTANTS.contestant_name, CONTESTANTS.contestant_number",
            "select t1, CONTESTANTS.contestant_number, CONTESTANTS.contestant_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name, t1.c3",
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name, VOTES.contestant_number",
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the contestant numbers and names of the contestants who had at most two votes?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "CONTESTANTS VOTES",
        "real_label": "CONTESTANTS VOTES",
        "topk_preds": [
            "CONTESTANTS VOTES",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of all the countries that became independent before 1950?, database: Database: world_1. t0: city(c0: id, c1: name (Independence), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of all the countries that became independent before 1950?, database: Database: world_1. t0: city(c0: id, c1: name (Independence), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Code",
            "select country.Name, country.Capital",
            "select country.Name, country.LocalName",
            "select country.Name, country.Region",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Code2",
            "select country.Name, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of all the countries that became independent before 1950?, database: Database: world_1. t0: city(c0: id, c1: name (Independence), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give the names of the nations that were founded before 1950., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give the names of the nations that were founded before 1950., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Capital",
            "select distinct country.Name",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.LocalName",
            "select country.Name (or country.Capital)",
            "select country.Name, country.Code2",
            "select country.Name, country.Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give the names of the nations that were founded before 1950., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total number of unique official languages spoken in the countries that are founded after 1930?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (count(distinct t3.c2)",
            "SELECT-FROM-WHERE (count(distinct t3.c1)",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE(count(distinct t3.c2)",
            "SELECT-FROM-WHERE(count(distinct t3.c1)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total number of unique official languages spoken in the countries that are founded after 1930?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(distinct t3.c2)",
        "label": "select count(distinct t3.c1)",
        "score": false,
        "real_pred": "select count(distinct countrylanguage.IsOfficial)",
        "real_label": "select count(distinct countrylanguage.Language)",
        "topk_preds": [
            "select count(distinct countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.Language)",
            "select count(distinct countrylanguage.Language, countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.Language, count(distinct countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.IsOfficial), country.Name",
            "select count(distinct countrylanguage.Language), country.Code",
            "select count(distinct countrylanguage.Language), country.Name",
            "select count(distinct countrylanguage.Language, countrylanguage.IsOfficial"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total number of unique official languages spoken in the countries that are founded after 1930?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For the countries founded after 1930, what is the total number of distinct official languages?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (count(distinct t3.c2)",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(distinct t3.c1)",
            "SELECT-FROM-WHERE(distinct t3.c2)",
            "SELECT-FROM-WHERE GROSS(t3.c2)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For the countries founded after 1930, what is the total number of distinct official languages?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(distinct t3.c2)",
        "label": "select count(distinct t3.c1)",
        "score": false,
        "real_pred": "select count(distinct countrylanguage.IsOfficial)",
        "real_label": "select count(distinct countrylanguage.Language)",
        "topk_preds": [
            "select count(distinct countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.Language)",
            "select sum(countrylanguage.IsOfficial)",
            "select sum(distinct countrylanguage.IsOfficial)",
            "select count(distinct t3.c6)",
            "select count(distinct t3.c)",
            "select count(distinct t3.c5)",
            "select count(distinct countrylanguage.IsOfficial"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For the countries founded after 1930, what is the total number of distinct official languages?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "",
            "",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which Asian countries have a population that is smaller than any country in Africa?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which Asian countries have a population that is smaller than any country in Africa?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Code, country.Name",
            "select country.Name, country.Continent",
            "select distinct country.Name",
            "select country.Name, country.Region",
            "select country.Name, country.IndepYear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which Asian countries have a population that is smaller than any country in Africa?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which Asian countries have a population that is at most any country in Africa?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-COMBINAT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-COMBINAT-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which Asian countries have a population that is at most any country in Africa?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Code, country.Name",
            "select country.Name, country.Region",
            "select country.Name, country.Continent",
            "select country.Name, country.IndepYear",
            "select country.Name, country.Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which Asian countries have a population that is at most any country in Africa?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of countries that speak less than 2 languages, as well as how many languages they speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of countries that speak less than 2 languages, as well as how many languages they speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, count(distinct t3.c1)",
        "label": "select count(t3.c1), t2.c1",
        "score": false,
        "real_pred": "select country.Name, count(distinct countrylanguage.Language)",
        "real_label": "select count(countrylanguage.Language), country.Name",
        "topk_preds": [
            "select country.Name, count(distinct countrylanguage.Language)",
            "select country.Name, countrylanguage.Language",
            "select country.Name, country.Name",
            "select country.Name, count(countrylanguage.Language)",
            "select country.Name, count(distinct country.Name)",
            "select country.Name, count(*)",
            "select country.Name, count(count(distinct countrylanguage.Language)",
            "select country.Name, count(distinct countrylanguage.IsOfficial)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of countries that speak less than 2 languages, as well as how many languages they speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence countrylanguage",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of countries that speak at least 2 languages, as well as how many languages they speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of countries that speak at least 2 languages, as well as how many languages they speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, count(distinct t3.c1)",
        "label": "select count(t3.c1), t2.c1",
        "score": false,
        "real_pred": "select country.Name, count(distinct countrylanguage.Language)",
        "real_label": "select count(countrylanguage.Language), country.Name",
        "topk_preds": [
            "select country.Name, count(distinct countrylanguage.Language)",
            "select country.Name, count(distinct country.Name)",
            "select country.Name, count(countrylanguage.Language)",
            "select country.Name, count(count(distinct countrylanguage.Language)",
            "select country.Name, count(distinct countrylanguage.IsOfficial)",
            "select country.Name, count(*)",
            "select country.Name, count(distinct countrylanguage.Language )",
            "select country.Name, count(distinct countrylanguage.Language)."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of countries that speak at least 2 languages, as well as how many languages they speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "",
            "",
            "",
            "",
            "",
            "city country countrylanguage"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of countries that speak at most 2 languages, as well as how many languages they speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of countries that speak at most 2 languages, as well as how many languages they speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, count(distinct t3.c1)",
        "label": "select count(t3.c1), t2.c1",
        "score": false,
        "real_pred": "select country.Name, count(distinct countrylanguage.Language)",
        "real_label": "select count(countrylanguage.Language), country.Name",
        "topk_preds": [
            "select country.Name, count(distinct countrylanguage.Language)",
            "select country.Name, count(distinct country.Name)",
            "select country.Name, count(countrylanguage.Language)",
            "select country.Name, countrylanguage.Language",
            "select country.Name, country.Name",
            "select country.Name, count(count(distinct countrylanguage.Language)",
            "select country.Name, count(distinct countrylanguage.IsOfficial)",
            "select country.Name, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of countries that speak at most 2 languages, as well as how many languages they speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the number of cities in each district whose population is less than the average population of cities?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY",
        "label": "SELECT-FROM-WHERE-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY",
        "real_label": "SELECT-FROM-WHERE-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the number of cities in each district whose population is less than the average population of cities?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(*), t0.c3",
        "label": "select count(*), t0.c3",
        "score": true,
        "real_pred": "select count(*), city.District",
        "real_label": "select count(*), city.District",
        "topk_preds": [
            "select count(*), city.District",
            "select city.District, count(*)",
            "select count(*), city.District, city.Population",
            "select count(*), city.District,",
            "select count(*), city.District, max(city.Population)",
            "select count(*), city.District, min(city.Population)",
            "select counts(*), city.District",
            "select count(*), city.District, city.Population"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the number of cities in each district whose population is less than the average population of cities?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "city",
        "real_label": "city",
        "topk_preds": [
            "city",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the number of cities in each district whose population is at most the average population of cities?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY max(t0.c4)",
            "SELECT-FROM-WHERE-GROUP BY at-HAVING",
            "SELECT-FROM-WHERE-GROUP BY AT-HAVING",
            "SELECT-FROM-WHERE-GROUP BY HAVING",
            "SELECT-FROM-WHERE-GROUP BY the-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the number of cities in each district whose population is at most the average population of cities?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(*), t0.c3",
        "label": "select count(*), t0.c3",
        "score": true,
        "real_pred": "select count(*), city.District",
        "real_label": "select count(*), city.District",
        "topk_preds": [
            "select count(*), city.District",
            "select city.District, count(*)",
            "select count(*), city.District, max(city.Population)",
            "select count(*), city.District, city.Population",
            "select count(*), city.District, min(city.Population)",
            "select count(*), city.District,",
            "select counts(*), city.District",
            "select count(*), t0.c 3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the number of cities in each district whose population is at most the average population of cities?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "city",
        "real_label": "city",
        "topk_preds": [
            "city",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many cities in each district have a population that is below the average population across all cities?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY",
        "label": "SELECT-FROM-WHERE-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY",
        "real_label": "SELECT-FROM-WHERE-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM -WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY ",
            "SELECT-FROM in-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many cities in each district have a population that is below the average population across all cities?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(*), t0.c3",
        "label": "select count(*), t0.c3",
        "score": true,
        "real_pred": "select count(*), city.District",
        "real_label": "select count(*), city.District",
        "topk_preds": [
            "select count(*), city.District",
            "select city.District, count(*)",
            "select count(*), city.District, city.Population",
            "select count(*), city.District, max(city.Population)",
            "select count(*), city.District, min(city.Population)",
            "select counts(*), city.District",
            "select count(*), city.District,",
            "select city.District.c3, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many cities in each district have a population that is below the average population across all cities?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "city",
        "real_label": "city",
        "topk_preds": [
            "city",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the gbelownment form name and total population for each gbelownment form whose average life expectancy is longer than 72., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-AVG(t2.c7)-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the gbelownment form name and total population for each gbelownment form whose average life expectancy is longer than 72., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c11, sum(t2.c6)",
        "label": "select sum(t2.c6), t2.c11",
        "score": false,
        "real_pred": "select country.GovernmentForm, sum(country.Population)",
        "real_label": "select sum(country.Population), country.GovernmentForm",
        "topk_preds": [
            "select country.GovernmentForm, sum(country.Population)",
            "select country.Name, sum(country.Population)",
            "select country.GovernmentForm, count(*)",
            "select country.GNPOld, sum(country.Population)",
            "select country.Capital, sum(country.Population)",
            "select country.Name, count(*)",
            "select country.GovernmentForm, sum(country.IndepYear)",
            "select country.LocalName, sum(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the gbelownment form name and total population for each gbelownment form whose average life expectancy is longer than 72., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the different gbelownment forms and what is the total population of each for gbelownment forms that have an average life expectancy greater than 72?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GEOGRAPHY-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GEOGRAPHY-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GWHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the different gbelownment forms and what is the total population of each for gbelownment forms that have an average life expectancy greater than 72?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c11, sum(t2.c6)",
        "label": "select sum(t2.c6), t2.c11",
        "score": false,
        "real_pred": "select country.GovernmentForm, sum(country.Population)",
        "real_label": "select sum(country.Population), country.GovernmentForm",
        "topk_preds": [
            "select country.GovernmentForm, sum(country.Population)",
            "select country.Name, sum(country.Population)",
            "select country.GNPOld, sum(country.Population)",
            "select country.GovernmentForm, count(*)",
            "select country.Capital, sum(country.Population)",
            "select country.LocalName, sum(country.Population)",
            "select country.GNP, sum(country.Population)",
            "select count(*), country.GovernmentForm"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the different gbelownment forms and what is the total population of each for gbelownment forms that have an average life expectancy greater than 72?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the different continents and the total popuation and average life expectancy corresponding to each, for continents that have an average life expectancy more than 72?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-CONTEXT-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-CONTEXT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the different continents and the total popuation and average life expectancy corresponding to each, for continents that have an average life expectancy more than 72?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c2, sum(t2.c6), avg(t2.c6)",
        "label": "select sum(t2.c6), avg(t2.c7), t2.c2",
        "score": false,
        "real_pred": "select country.Continent, sum(country.Population), avg(country.Population)",
        "real_label": "select sum(country.Population), avg(country.LifeExpectancy), country.Continent",
        "topk_preds": [
            "select country.Continent, sum(country.Population), avg(country.Population)",
            "select country.Continent, sum(country.Population), avg(country.LifeExpectancy)",
            "select country.Continent, sum(country.Population), sum(country.LifeExpectancy)",
            "select country.Continent, count(*), avg(country.Population)",
            "select country.Name, sum(country.Population), avg(country.Population)",
            "select country.Continent, sum(country.LifeExpectancy), avg(country.Population)",
            "select country.Continent, sum(country.GNP), avg(country.Population)",
            "select country.Name, sum(country.Population), avg(country.LifeExpectancy)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the different continents and the total popuation and average life expectancy corresponding to each, for continents that have an average life expectancy more than 72?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the different continents and the total popuation and average life expectancy corresponding to each, for continents that have an average life expectancy at least 72?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-CONTEXT-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-CONTEXT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the different continents and the total popuation and average life expectancy corresponding to each, for continents that have an average life expectancy at least 72?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c2, sum(t2.c6), avg(t2.c6)",
        "label": "select sum(t2.c6), avg(t2.c7), t2.c2",
        "score": false,
        "real_pred": "select country.Continent, sum(country.Population), avg(country.Population)",
        "real_label": "select sum(country.Population), avg(country.LifeExpectancy), country.Continent",
        "topk_preds": [
            "select country.Continent, sum(country.Population), avg(country.Population)",
            "select country.Continent, sum(country.Population), avg(country.LifeExpectancy)",
            "select country.Continent, sum(country.Population), sum(country.LifeExpectancy)",
            "select country.Continent, count(*), avg(country.Population)",
            "select country.Continent, sum(country.LifeExpectancy), avg(country.Population)",
            "select country.Name, sum(country.Population), avg(country.Population)",
            "select country.Continent, sum(country.GNP), avg(country.Population)",
            "select country.Name, sum(country.Population), avg(country.LifeExpectancy)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the different continents and the total popuation and average life expectancy corresponding to each, for continents that have an average life expectancy at least 72?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please show the name of the conductor that has conducted orchestras founded before 2008., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please show the name of the conductor that has conducted orchestras founded before 2008., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name (ORDER BY-LIMIT)",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name (ORDER BY-LIMIT",
            "select distinct conductor.Name",
            "select conductor.Name, orchestra.Orchestra_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please show the name of the conductor that has conducted orchestras founded before 2008., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of conductors who have conducted orchestras founded before the year 2008?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of conductors who have conducted orchestras founded before the year 2008?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select orchestra.Conductor_ID, conductor.Name",
            "select distinct conductor.Name",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, orchestra.Orchestra_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of conductors who have conducted orchestras founded before the year 2008?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of high schoolers who have less than 3 friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of high schoolers who have less than 3 friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name (Highschooler.ID)",
            "select Highschooler.name, t1.c3",
            "select Highschooler.name(Highschooler.grade)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of high schoolers who have less than 3 friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of high schoolers who have at most 3 friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of high schoolers who have at most 3 friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name (Highschooler.ID)",
            "select Highschooler.name, t1.c3",
            "select Highschooler.name (Highschooler.grade)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of high schoolers who have at most 3 friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of high schoolers who have 3 or less friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of high schoolers who have 3 or less friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Highschooler.grade",
            "select distinct Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name (Highschooler.ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of high schoolers who have 3 or less friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which professionals live in the state of Indiana or have done treatment on less than 2 treatments? List his or her id, last name and cell phone., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_",
        "prediction": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-CALL-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-C0, t6.c7, t6.c10",
            "SELECT-FROM-WHERE-C2, t6.c7, t6.c10",
            "SELECT-FROM-WHERE-GROUP BY-HAVING OR-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which professionals live in the state of Indiana or have done treatment on less than 2 treatments? List his or her id, last name and cell phone., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c",
        "prediction": "select t6.c0, t6.c7, t6.c10",
        "label": "select t6.c0, t6.c7, t6.c10",
        "score": true,
        "real_pred": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
            "select Professionals.first_name, Professionals.last_name, Professionals.cell_number",
            "select Treatments.professional_id, Professionals.last_name, Professionals.cell_number",
            "select Professionals.role_code, Professionals.last_name, Professionals.cell_number",
            "select t8.c2, Professionals.last_name, Professionals.cell_number",
            "select Charges.charge_id, Professionals.last_name, Professionals.cell_number",
            "select Sizes.size_code, Professionals.last_name, Professionals.cell_number",
            "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which professionals live in the state of Indiana or have done treatment on less than 2 treatments? List his or her id, last name and cell phone., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Breeds Professionals Treatments",
            "Sizes Professionals Treatments",
            "Charges Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which professionals live in the state of Indiana or have done treatment on at least 2 treatments? List his or her id, last name and cell phone., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-MULTI-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-C0-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which professionals live in the state of Indiana or have done treatment on at least 2 treatments? List his or her id, last name and cell phone., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c",
        "prediction": "select t6.c0, t6.c7, t6.c10",
        "label": "select t6.c0, t6.c7, t6.c10",
        "score": true,
        "real_pred": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
            "select Professionals.first_name, Professionals.last_name, Professionals.cell_number",
            "select Treatments.professional_id, Professionals.last_name, Professionals.cell_number",
            "select Professionals.role_code, Professionals.last_name, Professionals.cell_number",
            "select t8.c2, Professionals.last_name, Professionals.cell_number",
            "select Charges.charge_id, Professionals.last_name, Professionals.cell_number",
            "select Sizes.size_code, Professionals.last_name, Professionals.cell_number",
            "select t2.c2, Professionals.last_name, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which professionals live in the state of Indiana or have done treatment on at least 2 treatments? List his or her id, last name and cell phone., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Breeds Professionals Treatments",
            "Sizes Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Charges Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which professionals live in the state of Indiana or have done treatment on at most 2 treatments? List his or her id, last name and cell phone., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUPS-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING OR-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-CONDITION-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which professionals live in the state of Indiana or have done treatment on at most 2 treatments? List his or her id, last name and cell phone., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c",
        "prediction": "select t6.c0, t6.c7, t6.c10",
        "label": "select t6.c0, t6.c7, t6.c10",
        "score": true,
        "real_pred": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
            "select Professionals.first_name, Professionals.last_name, Professionals.cell_number",
            "select Professionals.role_code, Professionals.last_name, Professionals.cell_number",
            "select Treatments.professional_id, Professionals.last_name, Professionals.cell_number",
            "select t8.c2, Professionals.last_name, Professionals.cell_number",
            "select Charges.charge_id, Professionals.last_name, Professionals.cell_number",
            "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number.",
            "select t 6.c0, Professionals.last_name, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which professionals live in the state of Indiana or have done treatment on at most 2 treatments? List his or her id, last name and cell phone., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Sizes Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Breeds Professionals Treatments",
            "Charges Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the id, last name and cell phone of the professionals who live in the state of Indiana or have performed less than two treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment",
        "prediction": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-LIMIT-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-CONDITION-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNITED-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the id, last name and cell phone of the professionals who live in the state of Indiana or have performed less than two treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost",
        "prediction": "select t6.c0, t6.c7, t6.c10",
        "label": "select t6.c0, t6.c7, t6.c10",
        "score": true,
        "real_pred": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
            "select Professionals.first_name, Professionals.last_name, Professionals.cell_number",
            "select Treatments.professional_id, Professionals.last_name, Professionals.cell_number",
            "select Professionals.role_code, Professionals.last_name, Professionals.cell_number",
            "select t8.c2, Professionals.last_name, Professionals.cell_number",
            "select Charges.charge_id, Professionals.last_name, Professionals.cell_number",
            "select Sizes.size_code, Professionals.last_name, Professionals.cell_number",
            "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the id, last name and cell phone of the professionals who live in the state of Indiana or have performed less than two treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Sizes Professionals Treatments",
            "Breeds Professionals Treatments",
            "Charges Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the id, last name and cell phone of the professionals who live in the state of Indiana or have performed at least two treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment",
        "prediction": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING OR-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the id, last name and cell phone of the professionals who live in the state of Indiana or have performed at least two treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost",
        "prediction": "select t6.c0, t6.c7, t6.c10",
        "label": "select t6.c0, t6.c7, t6.c10",
        "score": true,
        "real_pred": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
            "select Professionals.first_name, Professionals.last_name, Professionals.cell_number",
            "select Treatments.professional_id, Professionals.last_name, Professionals.cell_number",
            "select Professionals.role_code, Professionals.last_name, Professionals.cell_number",
            "select t8.c2, Professionals.last_name, Professionals.cell_number",
            "select Charges.charge_id, Professionals.last_name, Professionals.cell_number",
            "select Sizes.size_code, Professionals.last_name, Professionals.cell_number",
            "select Dogs.dog_id, Professionals.last_name, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the id, last name and cell phone of the professionals who live in the state of Indiana or have performed at least two treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Breeds Professionals Treatments",
            "Sizes Professionals Treatments",
            "Charges Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the id, last name and cell phone of the professionals who live in the state of Indiana or have performed at most two treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment",
        "prediction": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ATTACH-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ATTACH-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the id, last name and cell phone of the professionals who live in the state of Indiana or have performed at most two treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost",
        "prediction": "select t6.c0, t6.c7, t6.c10",
        "label": "select t6.c0, t6.c7, t6.c10",
        "score": true,
        "real_pred": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
            "select Professionals.first_name, Professionals.last_name, Professionals.cell_number",
            "select Treatments.professional_id, Professionals.last_name, Professionals.cell_number",
            "select Professionals.role_code, Professionals.last_name, Professionals.cell_number",
            "select t8.c2, Professionals.last_name, Professionals.cell_number",
            "select Charges.charge_id, Professionals.last_name, Professionals.cell_number",
            "select Dogs.dog_id, Professionals.last_name, Professionals.cell_number",
            "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the id, last name and cell phone of the professionals who live in the state of Indiana or have performed at most two treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Breeds Professionals Treatments",
            "Sizes Professionals Treatments",
            "Charges Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which dogs have not cost their owner less than 1000 for treatment? List the dog names., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-HAVE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which dogs have not cost their owner less than 1000 for treatment? List the dog names., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c5",
        "label": "select t5.c5",
        "score": true,
        "real_pred": "select Dogs.name",
        "real_label": "select Dogs.name",
        "topk_preds": [
            "select Dogs.name",
            "select Dogs.name, Treatments.dog_id",
            "select Dogs.name, Treatments.professional_id",
            "select Dogs.name, Treatments.treatment_type_code",
            "select Dogs.name, Dogs.owner_id",
            "select Dogs.dog_id, Dogs.name",
            "select Dogs.name, Treatments.treatment_id",
            "select Dogs.name, Treatments.cost_of_treatment"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which dogs have not cost their owner less than 1000 for treatment? List the dog names., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Charges Dogs Treatments",
            "Treatment_Types Dogs Treatments",
            "Owners Dogs Treatments",
            "Sizes Dogs Treatments",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which dogs have not cost their owner at most 1000 for treatment? List the dog names., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which dogs have not cost their owner at most 1000 for treatment? List the dog names., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c5",
        "label": "select t5.c5",
        "score": true,
        "real_pred": "select Dogs.name",
        "real_label": "select Dogs.name",
        "topk_preds": [
            "select Dogs.name",
            "select Dogs.name, Treatments.dog_id",
            "select Dogs.name, Treatments.professional_id",
            "select Dogs.name, Treatments.treatment_type_code",
            "select Dogs.name, Treatments.treatment_id",
            "select Dogs.name, Treatments.cost_of_treatment",
            "select Dogs.name, Dogs.owner_id",
            "select Dogs.dog_id, Dogs.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which dogs have not cost their owner at most 1000 for treatment? List the dog names., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Charges Dogs Treatments",
            "Treatment_Types Dogs Treatments",
            "Breeds Dogs Treatments",
            "Owners Dogs Treatments",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the dogs for which the owner has not spend less than 1000 for treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the dogs for which the owner has not spend less than 1000 for treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c5",
        "label": "select t5.c5",
        "score": true,
        "real_pred": "select Dogs.name",
        "real_label": "select Dogs.name",
        "topk_preds": [
            "select Dogs.name",
            "select Dogs.name, Treatments.dog_id",
            "select Dogs.name, Dogs.age",
            "select Dogs.name, Dogs.breed_code",
            "select Dogs.name, Dogs.owner_id",
            "select Dogs.name, Dogs.dog_id",
            "select Dogs.name, Dogs.date_of_birth",
            "select Dogs.name, Treatments.professional_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the dogs for which the owner has not spend less than 1000 for treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Charges Dogs Treatments",
            "Treatment_Types Dogs Treatments",
            "Owners Dogs Treatments",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the dogs for which the owner has not spend at most 1000 for treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the dogs for which the owner has not spend at most 1000 for treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c5",
        "label": "select t5.c5",
        "score": true,
        "real_pred": "select Dogs.name",
        "real_label": "select Dogs.name",
        "topk_preds": [
            "select Dogs.name",
            "select Dogs.name, Dogs.owner_id",
            "select Dogs.name, Dogs.age",
            "select Dogs.name, Treatments.dog_id",
            "select Dogs.name, Dogs.dog_id",
            "select Dogs.name, Dogs.breed_code",
            "select Dogs.name, Dogs.date_of_birth",
            "select Dogs.name, Dogs.abandoned_yn"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the dogs for which the owner has not spend at most 1000 for treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Charges Dogs Treatments",
            "Owners Dogs Treatments",
            "Treatment_Types Dogs Treatments",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which professionals have done more than two treatments? List the professional's id, role, and first name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING, SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which professionals have done more than two treatments? List the professional's id, role, and first name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c0, t6.c1, t6.c2",
        "label": "select t6.c0, t6.c1, t6.c2",
        "score": true,
        "real_pred": "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
        "real_label": "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
            "select Treatments.professional_id, Professionals.role_code, Professionals.first_name",
            "select Professionals.professional_id, Professionals.first_name, Professionals.role_code",
            "select t8.c2, Professionals.role_code, Professionals.first_name",
            "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
            "select Sizes.size_code, Professionals.role_code, Professionals.first_name",
            "select Charges.charge_id, Professionals.role_code, Professionals.first_name",
            "select Dogs.dog_id, Professionals.role_code, Professionals.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which professionals have done more than two treatments? List the professional's id, role, and first name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Breeds Professionals Treatments",
            "Charges Professionals Treatments",
            "Sizes Professionals Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which professionals have done less than two treatments? List the professional's id, role, and first name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which professionals have done less than two treatments? List the professional's id, role, and first name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c0, t6.c1, t6.c2",
        "label": "select t6.c0, t6.c1, t6.c2",
        "score": true,
        "real_pred": "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
        "real_label": "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
            "select Professionals.professional_id, Professionals.first_name, Professionals.role_code",
            "select Treatments.professional_id, Professionals.role_code, Professionals.first_name",
            "select t8.c2, Professionals.role_code, Professionals.first_name",
            "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
            "select Sizes.size_code, Professionals.role_code, Professionals.first_name",
            "select Charges.charge_id, Professionals.role_code, Professionals.first_name",
            "select t 6.c0, Professionals.role_code, Professionals.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which professionals have done less than two treatments? List the professional's id, role, and first name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "",
            "Breeds Professionals Treatments",
            "Sizes Professionals Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which professionals have done at most two treatments? List the professional's id, role, and first name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GAGUE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which professionals have done at most two treatments? List the professional's id, role, and first name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c0, t6.c1, t6.c2",
        "label": "select t6.c0, t6.c1, t6.c2",
        "score": true,
        "real_pred": "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
        "real_label": "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
            "select Professionals.professional_id, Professionals.first_name, Professionals.role_code",
            "select Treatments.professional_id, Professionals.role_code, Professionals.first_name",
            "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
            "select t8.c2, Professionals.role_code, Professionals.first_name",
            "select Charges.charge_id, Professionals.role_code, Professionals.first_name",
            "select Sizes.size_code, Professionals.role_code, Professionals.first_name",
            "select t6).c0, Professionals.role_code, Professionals.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which professionals have done at most two treatments? List the professional's id, role, and first name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "",
            "",
            "",
            "",
            "Dogs Professionals Treatments",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the id, role, and first name of the professionals who have performed two or less treatments?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING, SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the id, role, and first name of the professionals who have performed two or less treatments?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c0, t6.c1, t6.c2",
        "label": "select t6.c0, t6.c1, t6.c2",
        "score": true,
        "real_pred": "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
        "real_label": "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
            "select Treatments.professional_id, Professionals.role_code, Professionals.first_name",
            "select t8.c2, Professionals.role_code, Professionals.first_name",
            "select Professionals.professional_id, Professionals.first_name, Professionals.role_code",
            "select Sizes.size_code, Professionals.role_code, Professionals.first_name",
            "select Charges.charge_id, Professionals.role_code, Professionals.first_name",
            "select Professionals.first_name, Professionals.role_code, Professionals.first_name",
            "select t2.c2, Professionals.role_code, Professionals.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the id, role, and first name of the professionals who have performed two or less treatments?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "",
            "Breeds Professionals Treatments",
            "Sizes Professionals Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which professionals have done more than two types of treatments? List the professional id and cell phone., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING-",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM.GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which professionals have done more than two types of treatments? List the professional id and cell phone., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c0, t6.c10",
        "label": "select t6.c0, t6.c10",
        "score": true,
        "real_pred": "select Professionals.professional_id, Professionals.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.cell_number",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.cell_number",
            "select Treatments.professional_id, Professionals.cell_number",
            "select Professionals.first_name, Professionals.cell_number",
            "select Professionals.role_code, Professionals.cell_number",
            "select t2.c2, Professionals.cell_number",
            "select t8.c2, Professionals.cell_number",
            "select Charges.charge_id, Professionals.cell_number",
            "select t 6.c0, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which professionals have done more than two types of treatments? List the professional id and cell phone., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Charges Professionals Treatments",
            "Breeds Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which professionals have done less than two types of treatments? List the professional id and cell phone., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which professionals have done less than two types of treatments? List the professional id and cell phone., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c0, t6.c10",
        "label": "select t6.c0, t6.c10",
        "score": true,
        "real_pred": "select Professionals.professional_id, Professionals.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.cell_number",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.cell_number",
            "select Professionals.first_name, Professionals.cell_number",
            "select Treatments.professional_id, Professionals.cell_number",
            "select Professionals.role_code, Professionals.cell_number",
            "select t2.c2, Professionals.cell_number",
            "select Professionals.professional_id2, Professionals.cell_number",
            "select Charges.charge_id, Professionals.cell_number",
            "select t 6.c0, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which professionals have done less than two types of treatments? List the professional id and cell phone., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Charges Professionals Treatments",
            "Breeds Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which professionals have done at most two types of treatments? List the professional id and cell phone., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM.GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which professionals have done at most two types of treatments? List the professional id and cell phone., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c0, t6.c10",
        "label": "select t6.c0, t6.c10",
        "score": true,
        "real_pred": "select Professionals.professional_id, Professionals.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.cell_number",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.cell_number",
            "select Treatments.professional_id, Professionals.cell_number",
            "select Professionals.first_name, Professionals.cell_number",
            "select Professionals.role_code, Professionals.cell_number",
            "select Charges.charge_id, Professionals.cell_number",
            "select t2.c2, Professionals.cell_number",
            "select t 6.c0, Professionals.cell_number",
            "select Sizes.size_code, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which professionals have done at most two types of treatments? List the professional id and cell phone., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Charges Professionals Treatments",
            "Breeds Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the id and cell phone of the professionals who operate two or less types of treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the id and cell phone of the professionals who operate two or less types of treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c0, t6.c10",
        "label": "select t6.c0, t6.c10",
        "score": true,
        "real_pred": "select Professionals.professional_id, Professionals.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.cell_number",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.cell_number",
            "select Professionals.first_name, Professionals.cell_number",
            "select Treatments.professional_id, Professionals.cell_number",
            "select Professionals.role_code, Professionals.cell_number",
            "select t2.c2, Professionals.cell_number",
            "select t8.c2, Professionals.cell_number",
            "select Dogs.dog_id, Professionals.cell_number",
            "select Charges.charge_amount, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the id and cell phone of the professionals who operate two or less types of treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Owners Professionals Treatments",
            "Charges Professionals Treatments",
            "Breeds Professionals Treatments",
            "Sizes Professionals Treatments",
            "Sizes Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many dogs have an age over the average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many dogs have an age over the average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Dogs.dog_id",
            "select count(*), Dogs.age",
            "select count(*), Dogs.breed_code",
            "select count(*), Dogs.owner_id",
            "select count(*), Dogs.date_of_birth",
            "select count(*), Dogs.size_code",
            "select count(*), Dogs.weight"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many dogs have an age over the average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Count the number of dogs of an age over the average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE_GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE.GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Count the number of dogs of an age over the average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Dogs.age",
            "select count(*), Dogs.dog_id",
            "select count(*), Dogs.owner_id",
            "select count(*), Dogs.date_of_birth",
            "select count(*) the Dogs.dog_id",
            "select count(*), Dogs.breed_code",
            "select count(*), Dogs.size_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Count the number of dogs of an age over the average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "Dogs Professionals",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show distinct names of singers that have songs with sales less than 300000., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-SEPARATE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show distinct names of singers that have songs with sales less than 300000., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select distinct t0.c1",
        "label": "select distinct t0.c1",
        "score": true,
        "real_pred": "select distinct singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select distinct singer.Name",
            "select distinct singer.Name, song.Singer_ID",
            "select distinct singer.Name, singer.Birth_Year",
            "select singer.Name",
            "select distinct singer.Name, singer.Singer_ID",
            "select distinct singer.Name de song.Singer_ID",
            "select distinct singer.Name song.Singer_ID",
            "select distinct singer.Name (singer.Singer_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show distinct names of singers that have songs with sales less than 300000., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show distinct names of singers that have songs with sales at most 300000., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show distinct names of singers that have songs with sales at most 300000., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select distinct t0.c1",
        "label": "select distinct t0.c1",
        "score": true,
        "real_pred": "select distinct singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select distinct singer.Name",
            "select distinct singer.Name, song.Singer_ID",
            "select distinct singer.Name, singer.Birth_Year",
            "select singer.Name",
            "select distinct singer.Name, singer.Net_Worth_Millions",
            "select distinct singer.Name (singer.Singer_ID)",
            "select distinct singer.Name, song.Singer_ID",
            "select distinct singer.Name de song.Singer_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show distinct names of singers that have songs with sales at most 300000., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: what are the different names of the singers that have sales less than 300000?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: what are the different names of the singers that have sales less than 300000?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select distinct t0.c1",
        "label": "select distinct t0.c1",
        "score": true,
        "real_pred": "select distinct singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select distinct singer.Name",
            "select distinct singer.Name, song.Singer_ID",
            "select distinct singer.Name, singer.Birth_Year",
            "select distinct singer.Name, singer.Net_Worth_Millions",
            "select count(distinct singer.Name)",
            "select distinct singer.Name, song.Singer_ID",
            "select distinct singer.Name, singer.Singer_ID",
            "select distinct singer.Name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: what are the different names of the singers that have sales less than 300000?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: what are the different names of the singers that have sales at most 300000?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: what are the different names of the singers that have sales at most 300000?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select distinct t0.c1",
        "label": "select distinct t0.c1",
        "score": true,
        "real_pred": "select distinct singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select distinct singer.Name",
            "select distinct singer.Name, singer.Birth_Year",
            "select distinct singer.Name, song.Singer_ID",
            "select distinct singer.Name, singer.Net_Worth_Millions",
            "select count(distinct singer.Name)",
            "select distinct singer.Name, song.Singer_ID",
            "select distinct singer.Name, t0.c6",
            "select distinct singer.Name song.Singer_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: what are the different names of the singers that have sales at most 300000?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of singers that have at least one song., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-INSIST-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of singers that have at least one song., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select distinct singer.Name",
            "select count(*), singer.Name",
            "select singer.Name, count(*)",
            "select singer.Name, song.Singer_ID",
            "select at least singer.Name",
            "select singer.Name, min(song.Sales)",
            "select singer.Name, min(song.Singer_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of singers that have at least one song., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of singers that have at most one song., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of singers that have at most one song., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select singer.Name, singer.Singer_ID",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, song.Title",
            "select singer.Name (singer.Singer_ID)",
            "select singer.Name (single-song.Singer_ID)",
            "select singer.Name, singer.Net_Worth_Millions"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of singers that have at most one song., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the singers that have at least one songs?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the singers that have at least one songs?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select count(*), singer.Name",
            "select distinct singer.Name",
            "select singer.Name, min(song.Singer_ID)",
            "select at least singer.Name",
            "select singer.Name, count(*)",
            "select count(distinct singer.Name)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the singers that have at least one songs?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the singers that have at most one songs?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the singers that have at most one songs?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, song.Title",
            "select singer.Name, singer.Singer_ID",
            "select singer.Name (singer.Singer_ID)",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name (single-song.Singer_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the singers that have at most one songs?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of properties that are either houses or apartments with less than 1 room?, database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of properties that are either houses or apartments with less than 1 room?, database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "select t3.c4",
        "label": "select t3.c4",
        "score": true,
        "real_pred": "select Properties.property_name",
        "real_label": "select Properties.property_name",
        "topk_preds": [
            "select Properties.property_name",
            "select Properties.property_name, Properties.room_count",
            "select Properties.property_name, Properties.property_address",
            "select Properties.property_name, Properties.property_address, Properties.room_count",
            "select Properties.property_name, Properties.room_count, Properties.buyer_offered_price",
            "select Properties.property_name, Properties.room_count, Properties.vendor_requested_price",
            "select Properties.property_name, Properties.property_address.c5",
            "select Properties.property_name, Properties.vendor_requested_price"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of properties that are either houses or apartments with less than 1 room?, database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Properties",
        "real_label": "Properties",
        "topk_preds": [
            "Properties",
            "",
            "",
            "",
            "",
            "",
            "Other_Available_Features Properties",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of properties that are either houses or apartments with at most 1 room?, database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of properties that are either houses or apartments with at most 1 room?, database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "select t3.c4",
        "label": "select t3.c4",
        "score": true,
        "real_pred": "select Properties.property_name",
        "real_label": "select Properties.property_name",
        "topk_preds": [
            "select Properties.property_name",
            "select Properties.property_name, Properties.property_address",
            "select Properties.property_name, Properties.room_count",
            "select Properties.property_name, Properties.property_address, Properties.room_count",
            "select Properties.property_name, Properties.property_address, min(Properties.room_count)",
            "select Properties.property_name, Properties.property_address.c5",
            "select Properties.property_name, Properties.property_address, max(Properties.room_count)",
            "select Properties.property_name, Properties.room_count, Properties.vendor_requested_price"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of properties that are either houses or apartments with at most 1 room?, database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Properties",
        "real_label": "Properties",
        "topk_preds": [
            "Properties",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    }
]